//Feel free to use code, MAKE SURE TO GIVE CREDIT WHERE DUE! -ineedbot
const
      fVersion = 2.12;

      fScriptPage = 'https://raw.githubusercontent.com/ineedbots/Scripts/master/%5BReflection%5D%20ineedbot''s%20functions.simba';

      Widget_LevelUp_Container = 233;
      LevelUp_Continue = 2;

      Widget_LevelUpExtra_Container = 193;
      LevelUpExtra_Continue = 2;

      Widget_Lamp_Container = 134;
      Lamp_Confirm = 26;

type TReflectDoor = record
     TileEncompass : TPointArray;
     Tile : TPoint;
     Plane : Integer;
     Offset : array[0..2] of integer;
     TileOffset : array[0..1] of integer;
     Actions : TStringArray;
end;

type TLoot = record
     SpawnTimer : TReflectTimer;
     HowLongToWait, World : Integer;
     Name : string;
end;
type TLootArray = array of TLoot;

procedure TLootArray.Add(theWorld : TLoot);
begin
  setLength(self, length(self)+1);
  self[high(self)] := theWorld;
end;

procedure TLootArray.Update;
var i : integer;
    temp : TLootArray;
begin
  temp := self;
  self := [];

  for i:=0 to high(temp) do
    if temp[i].SpawnTimer.ElapsedTime < temp[i].HowLongToWait then
      self.Add(temp[i]);
end;

function TLootArray.GetWorlds:TIntegerArray;
var i : integer;
begin
  for i:=0 to high(self) do begin
    setLength(result, length(result)+1);
    result[high(result)] := self[i].World;
  end;
end;

var
  ProggieLocation,me_name,SoundString: string;

  daLogger: TReflectLogger;

  ReflectPlayer: TReflectLocalPlayer;

  breaks,breakInFinal,breakIn,breakFor,breakinRandom,breakForRandom,
  AntiAmount,chatTimeOften,closeAllOften,updateAllOften,me_indice,
  dismissAllOften,lookForChatOften,checkForLevelOften: integer;

  breakInTimer,breakForTimer,closeAllTimer,updateAllTimer,debugTime,
  dismissAllTimer,lookForChatTimer,checkForLevelTimer,
  updateScreenTimer: TReflectTimer;

  rewardIDs: TIntegerArray;

  chatTimers: array of TReflectTimer;

  useAutoResponder,useFakeWaitTime,wasWorking: boolean;

  commonHelloStrings,youStrings,whatStrings,howStrings,areStrings,thatStrings,
  questionStrings,doingStrings,hiStrings,helloStrings,lolStrings,heyStrings,
  puncStrings,imStrings,botStrings,dontStrings,levelStrings,whyStrings,
  niceStrings,thanksStrings,randomsStrings: TStringArray;

  SkillStringsArray: array of TStringArray;

procedure updateScreen(_string:string);
begin
end;

procedure sleepScript(tim : integer);
begin
  sleep(tim);
end;

function GetWordsEx(text, wordCharacters: string): TStringArray;  //thanks  Janilabo
var
  l, i, r: Integer;
begin
  l := Length(text);
  if ((l > 0) and (wordCharacters <> '')) then
  begin
    SetLength(Result, l);
    for i := 1 to l do
      if (Pos(text[i], wordCharacters) > 0) then
      begin
        Result[r] := text[i];
        for i := (i + 1) to l do
          if (Pos(text[i], wordCharacters) > 0) then
            Result[r] := (Result[r] + text[i])
          else
            Break;
        Inc(r);
      end;
  end;
  SetLength(Result, r);
end;

function getPriceGE(id : integer) : integer;   //thx hoodz and flight!
var sellSource, webSource : string;
    i : integer;
    _strings : TStringArray;
begin
  try
    webSource := getPage('http://services.runescape.com/m=itemdb_oldschool/viewitem?obj='+intToStr(id));
  except
    daLogger.Warn('Failed to connect to grand exchange database', []);
    exit;
  end;
  sellSource := between('<h3>Current Guide Price <span title=''', '''', webSource);
  _strings := GetWordsEx(sellSource, '0123456789');

  sellSource := '';
  if length(_strings) > 0 then
    for i:=0 to high(_strings) do
      sellSource := sellSource+_strings[i];

  if (Length(sellSource) > 0) then
    result := strToInt(sellSource)
  else
    daLogger.Warn('Failed to get grand exchange price for item ID: '+intToStr(id), []);
end;

function R_DidLevelUp(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_LevelUp_Container, LevelUp_Continue);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('0');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

function R_DidLevelUpExtra(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_LevelUpExtra_Container, LevelUpExtra_Continue);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('1');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

function TReflectionGametab.CurrentColor:Integer;
var i : integer;
    TNB : TBox;
    Pnt : TPoint;
begin
  for i:=0 to 13 do begin
    case i of
      0: TNB:=[535,172,540,176];
      1: TNB:=[564,172,571,176];
      2: TNB:=[596,172,600,176];
      3: TNB:=[630,172,635,176];
      4: TNB:=[663,172,670,176];
      5: TNB:=[696,172,703,176];
      6: TNB:=[730,173,736,180];
      7: TNB:=[525,469,534,473];
      8: TNB:=[563,469,570,473];
      9: TNB:=[596,469,602,473];
      10:TNB:=[629,469,634,473];
      11:TNB:=[662,469,669,473];
      12:TNB:=[695,469,700,473];
      13:TNB:=[728,469,733,473];
    end;

    if findColorTolerance(Pnt.x, Pnt.y, 1910383, TNB.X1, TNB.Y1, TNB.X2, TNB.Y2, 13) then
      break;
  end;

  if i <> 14 then begin
    case i of
      0: Result := Gametab_CombatOptions;
      1: Result := Gametab_Stats;
      2: Result := Gametab_QuestList;
      3: Result := GameTab_Inventory;
      4: Result := Gametab_WornEquipment;
      5: Result := Gametab_Prayer;
      6: Result := Gametab_Magic;
      7: Result := Gametab_ClanChat;
      8: Result := Gametab_FriendsList;
      9: Result := Gametab_IgnoreList;
      10:Result := Gametab_Logout;
      11:Result := Gametab_Options;
      12:Result := Gametab_Emotes;
      13:Result := Gametab_MusicPlayer;
    end;
  end else begin
    Result := -1;
  end;
end;

function R_GetEquipText: string;
begin
  result := Reflect.Gametab.GetWieldedWeapon;
  if result = '' then begin
    if Reflect.Gametab.CurrentColor <> Gametab_CombatOptions then
      Reflect.Gametab.Open(Gametab_CombatOptions);
    result := Reflect.Gametab.GetWieldedWeapon;
  end;
end;

function ExpFromLevel(Level: integer): integer;   //thanks tehq!
begin
  Result := (round((Level / 4) + (75 * pow(2, (Level / 7)))));
end;

function LevelFromExp(Experience: integer): integer;  //thanks tehq!
var
  CurrentExp, n: integer;
begin
  for n := 1 to 120 do
  begin
    if CurrentExp < Experience then
      CurrentExp := round((1 / 4) *((n + (300 * pow(2, n / 7))))) + CurrentExp
    else
      break;
    Result := n;
  end;
end;

function statExpToGoal(CurrentLevel, EndLevel: integer): integer;   //thanks tehq!
var
  i: integer;
begin
  for i := CurrentLevel to EndLevel - 1 do
    Result := ExpFromLevel(i) + Result;
end;

function varExpToGoal(Experience, EndLevel: integer): integer;   //thanks tehq!
var
  CurrentLevel, NextLevel, i: integer;
begin
  CurrentLevel := LevelFromExp(Experience);
  NextLevel := statExpToGoal(1, CurrentLevel + 1);
  Result := NextLevel - Experience;
  for i := CurrentLevel + 1 to EndLevel - 1 do
    incEx(Result, ExpFromLevel(i));
end;

Procedure TMufasaBitmap.DrawClippedText(Text, Font: String; Position: TPoint; shadow: boolean; Colour: TColor = clRed);
var
  W, H: Integer;
  TPA: Array of TPoint;
Begin
  TPA := TPAFromText(Text, Font, W, H);
  OffsetTPA(TPA, Position);
  if shadow then begin
    OffsetTPA(TPA, Point(1, 1));
    Self.DrawTPA(TPA, clBlack+1);
    OffsetTPA(TPA, Point(-1, -1));
  end;
  Self.DrawTPA(TPA, Colour);
End;

Procedure TMufasaBitmap.DrawEllipse(Center: TPoint; XRadius, YRadius: Integer; Colour: TColor = clRed; Fill: Boolean = False);
var
  TPA: Array of TPoint;
Begin
  TPA := TPAFromEllipse(Center.X, Center.Y, XRadius, YRadius);
  If (Fill) then FillEllipse(TPA);
  Self.DrawTPA(TPA, Colour);
End;

function R_TileOnMS(Tile : TPoint; var OutputPoint : TPoint; x : integer = 0; y : integer = 0; z : integer = 0):boolean;
begin
  OutputPoint := Reflect.Tiles.TileToMS(Tile, x, y, z);
  result := PointInBox(OutputPoint, AREA_MS);
end;

function R_TileOnMM(Tile : TPoint; var OutputPoint : TPoint):boolean;
begin
  OutputPoint := Reflect.Tiles.TileToMM(Tile);
  result := PointInBox(OutputPoint, AREA_MM);
end;

procedure R_TryMakeTileOnMS(Tile:TPOint;x : integer = 0; y : integer = 0; z : integer = 0);
var t:TReflectTimer;
    _tile : TPoint;
begin
  if not R_TileOnMS(tile, _Tile, x, y, z) and (Reflect.Tiles.DistanceFromTile(Tile) <= 25) then begin
    Reflect.Tiles.RotateCameraToTile(tile);
    t.Restart;
    keyDown(VK_Down);
    while(t.ElapsedTime < 2500) and not R_TileOnMS(tile, _Tile, x, y, z) do
      sleepScript(50);
    keyUp(VK_Down);
  end;
end;

procedure fastClick(button: Integer);
var
  x, y: integer;
begin
  getMousePos(x, y);
  holdMouse(x, y, button);

  Wait(RandomRange(50, 100));

  getMousePos(x, y);
  releaseMouse(x, y, button);
end;

function TReflectionText.chooseOptionFast(Option: string): Boolean;
var
  Index, MenuX, MenuY, MenuWidth, XOff, YOff,x ,y: Integer;
  Options: TStringArray;
  Left: Boolean;
begin
  if not Reflect.Text.IsMenuOpen then
    Exit;
  Options := Reflect.Text.GetMenuOptions;

  Index := Reflect.Text.GetMenuIndex(Option, Options);
  MenuX := Reflect.Smart.GetFieldInt(0, Client_MenuX) + 4;
  MenuY := Reflect.Smart.GetFieldInt(0, Client_MenuY) + 4;
  MenuWidth := Reflect.Smart.GetFieldInt(0, Client_MenuWidth);
  XOff := RandomRange(4, MenuWidth - 4);
  YOff := RandomRange(20, 25) + (Index * 15);
  if (MenuX + (MenuWidth div 2) > 765) then
    Left := True;
  if (MenuX - (MenuWidth div 2) < 0) then
    Left := False;
  if (Index = -1) then
  begin
    GetMousePos(MenuX, MenuY);
    if Left then
      Reflect.Mouse.Move(Point(
        MenuX - 30 - MenuWidth + Random(10), MenuY + RandomRange(-2, 2)), 2, 2)
    else
      Reflect.Mouse.Move(Point(
        MenuX + 30 + MenuWidth + Random(10), MenuY + RandomRange(-2, 2)), 2, 2);
    Exit;
  end;
  GetMousePos(x, y);
  MoveMouse(x, randomRange((MenuY+YOff)-2, (MenuY+YOff)+2));
  fastClick(Mouse_Left);
  Result := True;
end;

function TReflectLocalPlayer.isDoingAnim(animationIDs:TIntegerArray;time:integer):Boolean;
var _time:treflecttimer;
begin
  _time.restart;
  while (_time.Elapsedtime < time) and Self.isLoggedIn do begin
     if(InIntArray(animationIDs, Self.GetAnimation)) then
     begin
       result := true;
       exit;
     end;
     sleepScript(50);
  end;
end;

procedure doProggy(where:string);
var w, h, bmp, graphic : integer;
begin
  graphic := Reflect.Smart.Graphics.ToBitmap(false);
  getClientDimensions(w, h);
  bmp := bitmapFromClient(0, 0, w, h);
  SetTransparentColor(graphic, 0);
  fastDrawTransparent(0, 0, graphic, bmp);
  saveBitmap(bmp, where);
  daLogger.Status('Saved Proggy to: '+where, []);
  FreeBitmap(bmp);
end;

function findAndSetTarget(TitlePrefix: String; SetAsTarget: Boolean): Boolean;
var
  T : TSysProcArr;
  I : Integer;
begin
  T := GetProcesses;
  for I := High(T) downto 0 do
    if Pos(TitlePrefix, T[I].Title) <> 0 then
    begin
      Result := True;
      if SetAsTarget then SetTarget(T[I]);
      Exit;
    end;
end;

function isKeyDownReal(_key:Word):boolean;
var
  KMTarget, ITarget: Integer;
begin
  if not IsTargetValid() then daLogger.Error('Target invalid', []);
  KMTarget := GetKeyMouseTarget;
  ITarget := GetImageTarget;
  if not findAndSetTarget('SMART', True) then
    findAndSetTarget('Old', True);

  result := isKeyDown(_key);

  FreeTarget(GetImageTarget);
  SetKeyMouseTarget(KMTarget);
  SetImageTarget(ITarget);
end;

procedure getRealMousePos(var X, Y : Integer);
var
  KMTarget, ITarget: Integer;
begin
  if not IsTargetValid() then daLogger.Error('Target invalid', []);
  KMTarget := GetKeyMouseTarget;
  ITarget := GetImageTarget;
  if not findAndSetTarget('SMART', True) then
    findAndSetTarget('Old', True);

  GetMousePos(X, Y);
  FreeTarget(GetImageTarget);
  SetKeyMouseTarget(KMTarget);
  SetImageTarget(ITarget);

  X := X - 3;
  Y := Y - 25;
end;

function R_MSToMSTile(TP:TPoint;var myTile:Tpoint;dist:integer=10):TPoint;
var _x, _y, i: integer;
    tiles, realTiles : TPointArray;
    found : boolean;
begin
  myTile := Reflect.Tiles.GetGlobalTile;
  for _x:=(-dist) to dist do
    for _y:=(-dist) to dist do begin
      inc(i);
      setLength(tiles, i);
      setLength(realTiles, i);
      tiles[i-1] := Reflect.Tiles.TileToMS(Point(myTile.x+_x, myTile.y+_y), 0, 0, 0);
      realTiles[i-1] := Point(myTile.x+_x, myTile.y+_y);
    end;

  for i:=0 to high(tiles) do
    if not found or (distance(TP.X, TP.Y, tiles[i].X, tiles[i].Y) < distance(TP.X, TP.Y, myTile.X, myTile.Y)) then begin
      myTile := tiles[i];
      result := realTiles[i];
      found := true;
    end;
end;

function R_MSToMMTile(TP:TPoint;var myTile:Tpoint;dist:integer=10):TPoint;
var _x, _y, i: integer;
    tiles, realTiles : TPointArray;
    found : boolean;
begin
  myTile := Reflect.Tiles.GetGlobalTile;
  for _x:=(-dist) to dist do
    for _y:=(-dist) to dist do begin
      inc(i);
      setLength(tiles, i);
      setLength(realTiles, i);
      tiles[i-1] := Reflect.Tiles.TileToMM(Point(myTile.x+_x, myTile.y+_y));
      realTiles[i-1] := Point(myTile.x+_x, myTile.y+_y);
    end;

  for i:=0 to high(tiles) do
    if not found or (distance(TP.X, TP.Y, tiles[i].X, tiles[i].Y) < distance(TP.X, TP.Y, myTile.X, myTile.Y)) then begin
      myTile := tiles[i];
      result := realTiles[i];
      found := true;
    end;
end;

Function GetUpText_WhiteColor: String;
Begin
  Result:=GetTextAt(8, 8, 0, 5, 4, 14541281, 55, 25, 'UpChars07');
End;

function slotActivated(i : integer):boolean;
var TB:Tbox;
    x,y : integer;
begin
  TB := Reflect.Inv.InvBox(i);
  Result := findColor(x, y, 16777215, TB.x1, TB.y1, TB.x2, TB.y2);
end;

function anySlotActivated(soft:boolean=false):boolean;
var _string : string;
    i : integer;
begin
  if Reflect.GameTab.CurrentColor <> Gametab_Inventory then
    exit(false);

  if not soft then begin
    _string := GetUpText_WhiteColor;
    if (pos('->', _string) <= 0) or (pos('Use', _string) <= 0) then
      exit(false);
  end;

  for i:=1 to 28 do
    if slotActivated(i) then
      exit(true);
end;

procedure FixActive;
var tempBox:TBox;
    i : integer;
    upt : string;
begin
  if Reflect.GameTab.CurrentColor <> Gametab_Inventory then
    exit;

  upt := GetUpText_WhiteColor;
  if (pos('->', upt) > 0) and (pos('Use', upt) > 0) then
    for i:=1 to 28 do
      if slotActivated(i) then begin
        if Reflect.GameTab.CurrentColor <> Gametab_Inventory then
          Reflect.Gametab.Open(Gametab_Inventory);
        tempBox := Reflect.Inv.invBox(i);
        Reflect.Mouse.Move(point(randomRange(tempBox.x1, tempBox.x2), randomRange(tempBox.y1, tempBox.y2)), 0, 0);
        sleepScript(500+random(250));
        Reflect.Mouse.Click(Mouse_left);
        sleepScript(500+random(250));
      end;
end;

function itemInSlot(I: Integer): Boolean;
var
  X, Y: Integer;
  TB: TBox;
begin
  if not inRange(I, 1, 28) then
    Exit;

  if Reflect.Bank.IsDepositBoxOpen then
    TB := Reflect.Bank.DepositBoxBox(I)
  else
    TB := Reflect.Inv.invBox(I);
  result := findColor(x, y, 65536, TB.x1, TB.y1, TB.x2, TB.y2);
end;

function IsMenuOpen:boolean;
var p : tpoint;
    tempTPA : TPointArray;
begin
  getClientDimensions(P.X, P.Y);
  if findColorsTolerance(tempTPA, 4674653, 0, 0, P.x-1, P.y-1, 0) then
    result := true;
end;

procedure exitMenu;
var timer : TReflectTimer;
    _x, _y : integer;
begin
  timer.Restart;
  while IsMenuOpen and (timer.Elapsedtime < 2500) do begin
    getMousePos(_x, _y);
    Reflect.Mouse.Move(Point(_x, _y-10), 5, 5);
  end;
end;

function R_InteractTile(tile:Tpoint; actions:tstringarray; x:integer = 0; y:integer = 0; z:integer = 0; doSecond:boolean=true):boolean;
var tries, pitch : integer;
    RSTile, MouseLoc : TPoint;
    yaw : extended;
begin
  for tries:=0 to 1 do begin
    if tries = 1 then begin
      yaw := 360 - Reflect.Compass.AngleDeg;
      pitch := round((Reflect.Compass.GetPitch - 128) / 25.5);
      Reflect.Compass.Make('rand');
      Reflect.Compass.MakePitch(9);
    end;

    if R_TileOnMS(Tile, RSTile, x, y, z) then begin
      getMousePos(MouseLoc.x, MouseLoc.y);
      if not Reflect.Text.OptionExistsMulti(actions) or (distance(MouseLoc.x, MouseLoc.y, rsTile.x, rsTile.y) > 5) then
        Reflect.Mouse.Move(rsTile, 5, 5);

      if Reflect.Text.IsUpTextMulti(actions) then begin
        if isMenuOpen then begin
          result := Reflect.Text.ChooseOptionMulti(actions);
        end else begin
          FastClick(mouse_left);
          if isArrInStr(actions, 'Walk') then
            result := Reflect.Mouse.DidClick(false)
          else
            result := Reflect.Mouse.DidClick(True);
        end;
      end else begin
        if isMenuOpen then begin
          result := Reflect.Text.ChooseOptionMulti(actions);
        end else begin
          if Reflect.Text.OptionExistsMulti(actions) then begin
            FastClick(mouse_right);
            result := Reflect.Text.ChooseOptionMulti(actions);
          end;
        end;
      end;
    end;

    if tries = 1 then begin
      Reflect.Compass.Make(yaw);
      Reflect.Compass.MakePitch(pitch);
    end;

    if result then
      break
    else if isMenuOpen then
      exitMenu;

    if not doSecond then
      break;
  end;
end;

function R_InteractNPC(IDs:TIntegerArray; actions:tstringarray; x:integer = 0; y:integer = 0; z:integer = 50):boolean;
var RsTile, npcTile : TPoint;
    i : integer;
    _npcs : TReflectNPCArray;
begin
  _npcs.GetAll;
  for i:=0 to high(_npcs) do begin
    npcTile := _npcs[i].GetTile;
    if inIntArray(IDs, _npcs[i].GetId) then begin
      if not R_TileOnMS(npcTile, RSTile, x, y, z) then begin
        ReflectPlayer.BlindWalkMM(npcTile, 5);
        ReflectPlayer.FFlag(2+randomRange(-2, 2));
        sleepScript(random(1500));
      end;

      result := R_InteractTile(npcTile, actions, x, y, z, false);
      exit;
    end;
  end;
end;

function R_TryInteractNPC(IDs:TIntegerArray; actions:tstringarray; tries:integer; x:integer = 0; y:integer = 0; z:integer = 50):boolean;
var i : integer;
begin
  i := 0;
  result := false;
  while (i<tries) and not result and ReflectPlayer.isLoggedIn do begin
    result := R_InteractNPC(IDs, actions, x, y, z);
    inc(i);
  end;
end;

function TReflectDoor.Open(wantOut: boolean): boolean;

function openDaDoor(daDoor:TReflectDoor):boolean;
var tP : TPoint;
    tObj : TReflectObject;
    timer : TReflectTimer;
begin
  tObj.GetAt(ObjBoundary, daDoor.Tile);
  if not Reflect.Smart.IsNull(tObj.Reference) then begin
    if not R_TileOnMS(daDoor.Tile, tP, daDoor.Offset[0], daDoor.Offset[1], daDoor.Offset[2]) then begin
      updateScreen('Going to door.');
      ReflectPlayer.BlindWalkMM(Point(daDoor.Tile.x+daDoor.TileOffset[0], daDoor.Tile.y+daDoor.TileOffset[1]), 1);
      ReflectPlayer.FFlag(0, 2500+random(500));
    end;
    updateScreen('Opening door.');
    result := R_InteractTile(daDoor.Tile, daDoor.Actions, daDoor.Offset[0], daDoor.Offset[1], daDoor.Offset[2]);
    if result then begin
      ReflectPlayer.FFlag(0, 2500+random(500));
      timer.restart;
      tObj.GetAt(ObjBoundary, daDoor.Tile);
      while (timer.Elapsedtime < 2500) and not Reflect.Smart.IsNull(tObj.Reference) do begin
        sleepScript(50);
        tObj.GetAt(ObjBoundary, daDoor.Tile);
      end;
    end;
  end else begin
    result := true;
    if not Reflect.Tiles.NearTile(daDoor.Tile, 60) then
      ReflectPlayer.BlindWalkMM(daDoor.Tile, 1);
  end;
end;

begin
  if self.Plane <> Reflect.Tiles.GetPlane then
    exit(true);

  if wantOut then begin
    if Reflect.Tiles.InPolygon(Self.TileEncompass) then
      result := openDaDoor(self)
    else
      result := true;
  end else begin
    if not Reflect.Tiles.InPolygon(Self.TileEncompass) then
      result := openDaDoor(self)
    else
      result := true;
  end;
end;

procedure updateAllRefVars;
begin
  updateScreen('Updating ref vars');
  ReflectPlayer.Create;
  me_name := ReflectPlayer.GetName;
  me_indice := ReflectPlayer.GetIndex;
end;

function GenerateRandomString:string;
var letters : tstringarray;
    i, leng : integer;
begin
  letters := [' ','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','''','"','!','@','#','?','$','^','&','*','(',')','-', '_','=','+','0','1','2','3','4','5','6','7','8','9','{','}','|','/','.',',','<','>',';',':','\'];
  leng := random(30);
  result := '';
  for i:=0 to leng do begin
    result:=result+letters[random(length(letters))];
  end;
end;

function GenerateRandomString2:string;
var letters : tstringarray;
    i, leng : integer;
begin
  letters := [' ','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];
  leng := random(30);
  result := '';
  for i:=0 to leng do begin
    result:=result+letters[random(length(letters))];
  end;
end;

function GenerateRandomString3:string;
var letters : tstringarray;
    i, leng : integer;
begin
  letters := ['a', 'w', 's', 'd', ' '];
  leng := random(30);
  result := '';
  for i:=0 to leng do begin
    result:=result+letters[random(length(letters))];
  end;
end;

procedure doBreakCheck;
var breakForFinal : integer;
    breakForTimer, breakUpdate : TReflectTimer;
begin
  if breakInTimer.Elapsedtime < breakInFinal then
    exit;

  breakForFinal := breakFor + randomRange(-breakForRandom, breakForRandom);
  breakForTimer.restart;
  breakUpdate.restart;

  updateScreen('Taking a break. '+Reflect.Time.msToTime((breakForFinal-breakForTimer.Elapsedtime), TIME_Bare)+' break time left.');
  daLogger.Status('Its been '+Reflect.Time.msToTime(breakInFinal, TIME_FORMAL)+'. Taking a '+Reflect.Time.msToTime(breakForFinal, TIME_FORMAL)+' long break.', []);
  ReflectPlayer.LogOut;
  while breakForTimer.Elapsedtime < breakForFinal do begin
    updateScreen('Taking a break. '+Reflect.Time.msToTime((breakForFinal-breakForTimer.Elapsedtime), TIME_Bare)+' break time left.');
    sleepScript(1500+random(5000));
    if breakUpdate.Elapsedtime > 300000 then begin
      breakUpdate.restart;
      daLogger.Status(Reflect.Time.msToTime((breakForFinal-breakForTimer.Elapsedtime), TIME_FORMAL)+' break time left.', []);
    end;
  end;

  breakInTimer.restart;
  breakInFinal := breakIn + randomRange(-breakInRandom, breakInRandom);
  inc(breaks);
  updateScreen('Break time is up.');
  daLogger.Status('Break time is up. Next break in '+Reflect.Time.msToTime(breakInFinal, TIME_FORMAL), []);
end;

function getNearPlayersAmount:integer;
var _players : TReflectPlayerArray;
    i : integer;
    tempP : TPoint;
begin
  _players.GetAll;
  for i:=0 to high(_players) do begin
    if R_TileOnMS(_players[i].GetTile, tempP, 0, 0, 50) then begin
      inc(result);
    end;
  end;
end;

procedure doAntibanTalk;
var _string:tstringarray;
    i, maxS, people : integer;
begin
  people := getNearPlayersAmount-1;
  if (people <= 0) then
    exit;

  if (chatTimers[high(chatTimers)].Elapsedtime < chatTimeOften) then
    exit;

  chatTimers[high(chatTimers)].Restart;

  maxS := 130;
  {$IFDEF CHOPPER}
    maxS := 160;
  {$ENDIF}
  {$IFDEF FISHER}
    maxS := 152;
  {$ENDIF}
  {$IFDEF FIREMAKER}
    maxS := 152;
  {$ENDIF}
  {$IFDEF MINER}
    maxS := 152;
  {$ENDIF}
  {$IFDEF COOKER}
    maxS := 152;
  {$ENDIF}
  case random(maxS) of
    0:_string:=['am i muted?'];
    1:_string:=['wtf'];
    2:_string:=['ok'];
    3:_string:=['hi'];
    4:_string:=['anyone there'];
    5:_string:=['w00t'];
    6:_string:=['woot'];
    7:_string:=['wewt'];
    8:_string:=['u there?'];
    9:_string:=['lagggg?'];
    10:_string:=['hello'];
    11:_string:=['hello?'];
    12:_string:=['hi?'];
    13:_string:=['wtf?'];
    14:_string:=['lol'];
    15:_string:=['lol?'];
    16:_string:=['anyone there?'];
    17:_string:=['any1 there'];
    18:_string:=['any1 there?'];
    19:_string:=['you there'];
    20:_string:=['u there'];
    21:_string:=['you there?'];
    22:_string:=['l'];
    23:_string:=['l00l'];
    24:_string:=['l0l'];
    25:_string:=['l000l'];
    26:_string:=['am i muted'];
    27:_string:=['yo'];
    28:_string:=['sup'];
    29:_string:=['sup?'];
    30:_string:=['boring'];
    31:_string:=['this is boring'];
    32:_string:=['anyone here'];
    33:_string:=['anyone here?'];
    34:_string:=['any1 here'];
    35:_string:=['any1 here?'];
    36:_string:=['bot'];
    37:_string:=['bot?'];
    38:_string:=['bots'];
    39:_string:=['bots?'];
    40:_string:=['loool'];
    41:_string:=['lool'];
    42:_string:=[':)'];
    43:_string:=['=)'];
    44:_string:=['yes'];
    45:_string:=['yes!'];
    46:_string:=['gf'];
    47:_string:=['gg'];
    48:_string:=['rekt'];
    49:_string:=['ayy lmao'];
    50:_string:=['ayyy lmao'];
    51:_string:=['ayyyy lmao'];
    52:_string:=['how'];
    53:_string:=['how?'];
    54:_string:=['k'];
    55:_string:=['ok?'];
    56:_string:=['k?'];
    57:_string:=[' '];
    58:_string:=['a q p','     W'];
    59:_string:=['stfu'];
    60:_string:=['stfu?'];
    61:_string:=['how cum'];
    62:_string:=['how cum?'];
    63:_string:=['how com'];
    64:_string:=['how com?'];
    65:_string:=['how come?'];
    66:_string:=['how come'];
    67:_string:=['a q p','    W'];
    68:_string:=['a q p','      W'];
    69:_string:=['|\/\/\/|','|______|'];
    70:_string:=['|\/\/\/|','|_____|'];
    71:_string:=['|\/\/\/|','|_______|'];
    72:_string:=['no'];
    73:_string:=['no?'];
    74:_string:=['wat'];
    75:_string:=['wat?'];
    76:_string:=['what'];
    77:_string:=['what?'];
    78:_string:=['wut'];
    79:_string:=['wut?'];
    80:_string:=['lolwat'];
    81:_string:=['lol wat'];
    82:_string:=['lolwut'];
    83:_string:=['lol wut'];
    84:_string:=['im bored'];
    85:_string:=['i''m bored'];
    86:_string:=['i"m bored'];
    87:_string:=['help'];
    88:_string:=['help?'];
    89:_string:=['umm'];
    90:_string:=['hmm'];
    91:_string:=['uh'];
    92:_string:=['huh'];
    93:_string:=[GenerateRandomString];
    94:_string:=['u w0t m8'];
    95:_string:=['u wot m8'];
    96:_string:=['u w0t m8?'];
    97:_string:=['u wot m8?'];
    98:_string:=[GenerateRandomString2];
    99:_string:=[GenerateRandomString3];
    100:_string:=[GenerateRandomString];
    101:_string:=[intToStr(random(10))];
    102:_string:=[intToStr(random(100))];
    103:_string:=['ha'];
    104:_string:=['haha'];
    105:_string:=['hahaha'];
    106:_string:=['no u'];
    107:_string:=['no you'];
    108:_string:=['n00b'];
    109:_string:=['noob'];
    110:_string:=['n00bs'];
    111:_string:=['noobs'];
    112:_string:=['added'];
    113:_string:=['add me'];
    114:_string:=['add me?'];
    115:_string:=['reported'];
    116:_string:=['ignored'];
    117:_string:=['***'];
    118:_string:=['****'];
    119:_string:=['*****'];
    120:_string:=['******'];
    121:_string:=['wth'];
    122:_string:=['wth?'];
    123:_string:=['lag'];
    124:_string:=['lagg'];
    125:_string:=['lag?'];
    126:_string:=['lagg?'];
    127:_string:=['laggg?'];
    128:_string:=['laggg'];
    129:_string:=['lagggg'];
    {$IFDEF CHOPPER}
      130:_string:=['woodcut lvl'];
      131:_string:=['woodcut level'];
      132:_string:=['woodcut level?'];
      133:_string:=['woodcutting lvl'];
      134:_string:=['woodcutting lvl?'];
      135:_string:=['woodcutting level'];
      136:_string:=['woodcutting level?'];
      137:_string:=['woodcuttin lvl'];
      138:_string:=['woodcuttin lvl?'];
      139:_string:=['woodcuttin level'];
      140:_string:=['woodcuttin level?'];
      141:_string:=['woodcuttin lvls'];
      142:_string:=['woodcuttin lvls?'];
      143:_string:=['woodcuttin levels'];
      144:_string:=['woodcuttin levels?'];
      145:_string:=['woodcut lvls'];
      146:_string:=['woodcut levels'];
      147:_string:=['woodcut levels?'];
      148:_string:=['woodcutting lvls'];
      149:_string:=['woodcutting lvls?'];
      150:_string:=['woodcutting levels'];
      151:_string:=['woodcutting levels?'];
      152:_string:=['wc lvl'];
      153:_string:=['wc lvls'];
      154:_string:=['wc lvl?'];
      155:_string:=['wc lvls?'];
      156:_string:=['wc level'];
      157:_string:=['wc levels'];
      158:_string:=['wc level?'];
      159:_string:=['wc levels?'];
    {$ENDIF}
    {$IFDEF FISHER}
      130:_string:=['fishin lvl'];
      131:_string:=['fishin lvl?'];
      132:_string:=['fishin level'];
      133:_string:=['fishin level?'];
      134:_string:=['fishin lvls'];
      135:_string:=['fishin lvls?'];
      136:_string:=['fishin levels'];
      137:_string:=['fishin levels?'];
      138:_string:=['fish lvl'];
      139:_string:=['fish level'];
      140:_string:=['fish level?'];
      141:_string:=['fishing lvl'];
      142:_string:=['fishing lvl?'];
      143:_string:=['fishing level'];
      144:_string:=['fishing level?'];
      145:_string:=['fish lvls'];
      146:_string:=['fish levels'];
      147:_string:=['fish levels?'];
      148:_string:=['fishing lvls'];
      149:_string:=['fishing lvls?'];
      150:_string:=['fishing levels'];
      151:_string:=['fishing levels?'];
    {$ENDIF}
    {$IFDEF FIREMAKER}
      130:_string:=['firemakin lvl'];
      131:_string:=['firemakin lvl?'];
      132:_string:=['firemakin level'];
      133:_string:=['firemakin level?'];
      134:_string:=['firemakin lvls'];
      135:_string:=['firemakin lvls?'];
      136:_string:=['firemakin levels'];
      137:_string:=['firemakin levels?'];
      138:_string:=['fire levels'];
      139:_string:=['fire levels?'];
      140:_string:=['firemaking lvls'];
      141:_string:=['firemaking lvls?'];
      142:_string:=['firemaking levels'];
      143:_string:=['firemaking levels?'];
      144:_string:=['fire lvl'];
      145:_string:=['fire level'];
      146:_string:=['fire level?'];
      147:_string:=['firemaking lvl'];
      148:_string:=['firemaking lvl?'];
      149:_string:=['firemaking level'];
      150:_string:=['firemaking level?'];
      151:_string:=['fire lvls'];
    {$ENDIF}
    {$IFDEF MINER}
      130:_string:=['minin lvl'];
      131:_string:=['minin lvl?'];
      132:_string:=['minin level'];
      133:_string:=['minin level?'];
      134:_string:=['minin lvls'];
      135:_string:=['minin lvls?'];
      136:_string:=['minin levels'];
      137:_string:=['minin levels?'];
      138:_string:=['mine levels'];
      139:_string:=['mine levels?'];
      140:_string:=['mining lvls'];
      141:_string:=['mining lvls?'];
      142:_string:=['mining levels'];
      143:_string:=['mining levels?'];
      144:_string:=['mine lvls'];
      145:_string:=['mine lvl'];
      146:_string:=['mine level'];
      147:_string:=['mine level?'];
      148:_string:=['mining lvl'];
      149:_string:=['mining lvl?'];
      150:_string:=['mining level'];
      151:_string:=['mining level?'];
    {$ENDIF}
    {$IFDEF COOKER}
      130:_string:=['cookin lvl'];
      131:_string:=['cookin lvl?'];
      132:_string:=['cookin level'];
      133:_string:=['cookin level?'];
      134:_string:=['cookin lvls'];
      135:_string:=['cookin lvls?'];
      136:_string:=['cookin levels'];
      137:_string:=['cookin levels?'];
      138:_string:=['cook levels'];
      139:_string:=['cook levels?'];
      140:_string:=['cooking lvls'];
      141:_string:=['cooking lvls?'];
      142:_string:=['cooking levels'];
      143:_string:=['cooking levels?'];
      144:_string:=['cook lvls'];
      145:_string:=['cook lvl'];
      146:_string:=['cook level'];
      147:_string:=['cook level?'];
      148:_string:=['cooking lvl'];
      149:_string:=['cooking lvl?'];
      150:_string:=['cooking level'];
      151:_string:=['cooking level?'];
    {$ENDIF}
  end;
  daLogger.Status('Saying: '''+toStr(_string)+''' outloud too '+intToStr(people)+' people.', []);
  for i:=0 to high(_string) do
    if useAutoResponder then
      Reflect.Keyboard.TypeSend(_string[i], true);
end;

procedure dismissAllRandoms;
var i, j, lampSkill:integer;
    _npcs:TReflectNPCArray;
    _item : TReflectInvItem;
    name : string;
    tile : TPOint;
    w : TReflectWidget;
    tb : TBox;
begin
  //3 att 4 str 5 range 6 magic 7 def
  //8 hp 9 pray 10 agile 11 herb 12 theiv 13 craft
  //14 rc 22 slay 23 farm 15 mine 16 smith 17 fish
  //18 cook 19 fm 20 wc 21 fletch 24 con 25 hunt
  lampSkill := 18;
  {$IFDEF CHOPPER}
    lampSkill := 20;
  {$ENDIF}
  {$IFDEF FISHER}
    lampSkill := 17;
  {$ENDIF}
  {$IFDEF FIREMAKER}
    lampSkill := 19;
  {$ENDIF}
  {$IFDEF MINER}
    lampSkill := 15;
  {$ENDIF}
  {$IFDEF COOKER}
    lampSkill := 18;
  {$ENDIF}
  for i:=0 to high(rewardIDs) do begin
    if _item.Find(rewardIDs[i]) then begin
      if Reflect.Gametab.CurrentColor <> Gametab_Inventory then
        Reflect.Gametab.Open(Gametab_Inventory);
      updateScreen('Solving lamp.');
      daLogger.Status('Solving lamp...', []);
      tb := _item.getBox;
      Reflect.Mouse.Move(tb, mouse_left);
      sleepScript(1000+random(500));
      W.GetWidget(widget_lamp_container, lampSkill);
      if W.NotNull then begin
        W.Interact;
        W.Free;
        W.GetWidget(widget_lamp_container, lamp_confirm);
        if W.NotNull then begin
          W.Interact;
          W.Free;
        end;
      end;
      sleepScript(1000+random(500));
    end;
  end;
  _npcs.GetAll;
  for i:=0 to high(_npcs) do begin
    if (_npcs[i].getInteractingIndex = me_indice) then begin
      for j:=0 to high(randomsStrings) do begin
        name := _npcs[i].getname;
        if (pos(randomsStrings[j], lowercase(name)) > 0) then begin
          tile := _npcs[i].getTile;
          if useFakeWaitTime and wasWorking then begin
            updateScreen('Doing fake ''antiban'' wait.');
            sleepScript(1000+random(7500));
          end;
          wasWorking := false;
          if randomsStrings[j] = 'genie' then begin
            updateScreen('Talking to: '+name);
            if R_InteractTile(tile, ['Talk'], 0, 0, 50) then begin
              sleepScript(1000+random(1000));
              Reflect.Chat.doConversation([]);
              daLogger.Status('Talked to random: '+name, []);
            end;
          end else begin
            updateScreen('Dismissing: '+name);
            if R_InteractTile(tile, ['Dismiss'], 0, 0, 50) then begin
              sleepScript(1000+random(1000));
              daLogger.Status('Dismissed random: '+name, []);
            end;
          end;
          exit;
        end;
      end;
    end;
  end;
end;

procedure doAnAnti;
var maxS: integer;
begin
  Reflect.MouseSpeed := randomRange(15, 30);
  updateScreen('Performing antiban...');
  maxS := 18;
  {$IFDEF CHOPPER}
    maxS := 19;
  {$ENDIF}
  {$IFDEF FISHER}
    maxS := 19;
  {$ENDIF}
  {$IFDEF FIREMAKER}
    maxS := 19;
  {$ENDIF}
  {$IFDEF MINER}
    maxS := 19;
  {$ENDIF}
  {$IFDEF COOKER}
    maxS := 19;
  {$ENDIF}
  case random(maxS) of
    0:Reflect.Antiban.RandomRClick;
    1:Reflect.Antiban.hoverSkill(-1);
    2:Reflect.Antiban.PickUpMouse;
    3:Reflect.Antiban.SleepAndMoveMouse(random(2500));
    4:Reflect.Antiban.RandomMovement;
    5:Reflect.Antiban.CompassMovement(0, 360, false);
    6:Reflect.Antiban.HumanRandomMouse;
    7:Reflect.Antiban.ExamineInv;
    8:Reflect.Antiban.RandomFKeys(false);
    9:Reflect.Antiban.RandomTab(false);
    10:Reflect.Antiban.BoredHuman;
    11:Reflect.Antiban.RandomTab(true);
    12:Reflect.Antiban.MMouseOffClient('rand');
    13:Reflect.Antiban.MMouseOffClient('top');
    14:Reflect.Antiban.MMouseOffClient('bottom');
    15:Reflect.Antiban.MMouseOffClient('left');
    16:Reflect.Antiban.MMouseOffClient('right');
    17:doAntibanTalk;
    {$IFDEF CHOPPER}
      18:Reflect.Antiban.hoverSkill(Skill_Woodcutting);
    {$ENDIF}
    {$IFDEF FISHER}
      18:Reflect.Antiban.hoverSkill(Skill_Fishing);
    {$ENDIF}
    {$IFDEF FIREMAKER}
      18:Reflect.Antiban.hoverSkill(Skill_Firemaking);
    {$ENDIF}
    {$IFDEF MINER}
      18:Reflect.Antiban.hoverSkill(Skill_Mining);
    {$ENDIF}
    {$IFDEF COOKER}
      18:Reflect.Antiban.hoverSkill(Skill_Cooking);
    {$ENDIF}
  end;
end;

procedure levelUpCheck;
var i : integer;
begin
  if R_DidLevelUp or R_DidLevelUpExtra then begin
    if useFakeWaitTime and wasWorking then begin
      updateScreen('Doing fake ''antiban'' wait.');
      sleepScript(1000+random(7500));
    end;
    wasWorking := false;
    updateScreen('Clicking level up!');

    for i:=0 to 1000 do
      if not FileExists(ScriptPath+'ineedbot''s clicking level up '+toStr(i)+'.png')then
        break;
    doProggy(ScriptPath+'ineedbot''s clicking level up '+toStr(i)+'.png');

    R_DidLevelUp(true);
    R_DidLevelUpExtra(true);
  end;
end;

procedure doAntiban;
var i : integer;
begin
  if checkForLevelTimer.Elapsedtime > checkForLevelOften then begin
    levelUpCheck;
    checkForLevelTimer.Restart;
  end;

  i:=random(AntiAmount);
  case i of
    1..10:doAnAnti;
    else begin
      {$IFDEF iDEBUG}
        writeln(debugTime.Elapsedtime, ' ', i);
      {$ENDIF}
    end;
  end;
  {$IFDEF iDEBUG}
    debugTime.Restart;
  {$ENDIF}
end;

type AutoChatRefPlayer = record
     SayText, RSName : string;
     isInteracting : boolean;
end;

function getAutoChatRefPlayers(var amountOfPeople : integer):array of AutoChatRefPlayer;
var _players : TReflectPlayerArray;
    i, h : integer;
    tempP : TPoint;
    name : string;
begin
  _players.GetAll;
  for i:=0 to high(_players) do begin
    name := _players[i].GetName;
    if (pos('mod ', lowercase(name)) > 0) then begin
      daLogger.Status('FOUND JMOD '+name+', LOGGING OUT!', []);
      updateScreen('FOUND JMOD '+name+', LOGGING OUT!');
      ReflectPlayer.LogOut;
      sleepScript(100000+random(50000));
      exit;
    end;
    if (name <> me_name) and R_TileOnMS(_players[i].GetTile, tempP, 0, 0, 50) then begin
      inc(amountOfPeople);
      setLength(result, amountOfPeople);

      h := amountOfPeople-1;
      result[h].SayText := _players[i].GetSpokenText;
      result[h].RSName := name;
      if (_players[i].GetInteractingIndex = me_indice) then
        result[h].isInteracting := true;
    end;
  end;
end;

function getChatThink(_player : AutoChatRefPlayer; var sendType : integer):string;
var msg : string;
    checkStrings : TStringArray;
    i, h, j : integer;
begin
  msg := lowercase(_player.SayText);
  if _player.isInteracting or (pos(lowercase(me_name), msg) > 0) then begin
    checkStrings := ['wat', 'what?', 'wat?', '?', 'what'];
    sendType := 6;
    exit(checkStrings[random(length(checkStrings))]);
  end;

  sendType := -1;
  if length(msg) > 0 then begin
    for i:=0 to high(commonHelloStrings) do
      if (commonHelloStrings[i] = msg) then begin
        checkStrings := ['hey', 'hi', 'hello', 'sup'];
        sendType := 0;
        exit(checkStrings[random(length(checkStrings))]);
      end;

     for i:=0 to high(SkillStringsArray) do
      for h:=0 to high(levelStrings) do
        for j:=0 to high(SkillStringsArray[i]) do
          if (pos(levelStrings[h], msg) > 0) and (pos(SkillStringsArray[i][j], msg) > 0) then begin
            checkStrings := [intToStr(TReflectLocalPlayer.GetMaxSkillLevel(i))];
            sendType := 2;
            exit(checkStrings[random(length(checkStrings))]);
          end;

    for i:=0 to high(levelStrings) do
      if (pos(levelStrings[i], msg) > 0) then begin
        checkStrings := ['?'];
        sendType := 4;
        exit(checkStrings[random(length(checkStrings))]);
      end;

    checkStrings := GetWordsEx(msg, 'abcdefghijklmnopqrstuvwxyz0123456789-''');

    for i:=0 to high(botStrings) do
      for h:=0 to high(checkStrings) do
        if(botStrings[i] = checkStrings[h]) then begin
          checkStrings := ['no', 'lol', '?'];
          sendType := 1;
          exit(checkStrings[random(length(checkStrings))]);
        end;

    for i:=0 to high(lolStrings) do
      for h:=0 to high(checkStrings) do
        if (lolStrings[i] = checkStrings[h]) then begin
          checkStrings := ['lol', 'l0l', 'lel', 'lool'];
          sendType := 3;
          exit(checkStrings[random(length(checkStrings))]);
        end;

    for i:=0 to high(niceStrings) do
      for h:=0 to high(checkStrings) do
        if (niceStrings[i] = checkStrings[h]) then begin
          checkStrings := ['thx', 'thanks', 'ty'];
          sendType := 5;
          exit(checkStrings[random(length(checkStrings))]);
        end;
  end;
end;

procedure autoChat;
var AutoChatRefPlayers : array of AutoChatRefPlayer;
    amountOfPeople, i, sendType : integer;
    respondString, theString : string;
begin
  AutoChatRefPlayers := getAutoChatRefPlayers(amountOfPeople);
  for i:=0 to amountOfPeople-1 do begin
    respondString := getChatThink(AutoChatRefPlayers[i], sendType);
    if sendType > -1 then begin
      if ((sendType = 5) and (chatTimers[2].Elapsedtime < chatTimeOften) and (chatTimers[sendType].Elapsedtime > chatTimeOften)) or ((chatTimers[sendType].Elapsedtime > chatTimeOften) and (sendType <> 5)) then begin
        theString := Reflect.Text.RemoveFormatting(AutoChatRefPlayers[i].SayText);
        daLogger.Status('Responding to player '''+AutoChatRefPlayers[i].RSName+''' who said '''+theString+''' with '''+respondString+''' ('+intToStr(sendType)+')', []);
        updateScreen('Doing autoChat...');
        chatTimers[sendType].Restart;
        sleepScript(1000+random(5000));
        if useAutoResponder then
          Reflect.Keyboard.typeSend(respondString, true);
        sleepScript(random(750));
      end;
      if sendType = 6 then
        playSound(SoundString);
    end;
  end;
end;

procedure randomHandler;
begin
  if dismissAllTimer.Elapsedtime > dismissAllOften then begin
    dismissAllRandoms;
    dismissAllTimer.Restart;
  end;
  doAntiban;
  if closeAllTimer.Elapsedtime > closeAllOften then begin
    Reflect.Interfaces.CloseAll;
    closeAllTimer.Restart;
  end;
  if lookForChatTimer.Elapsedtime > lookForChatOften then begin
    autoChat;
    lookForChatTimer.Restart;
  end;
  if updateAllTimer.Elapsedtime > updateAllOften then begin
    updateAllRefVars;
    updateAllTimer.Restart;
  end;
end;

procedure doFUpdate;     //thanks shuttleu
var NetworkVersion : extended;
    FileNew, fscript : string;
    ThisFile : integer;
begin
  if DirectoryExists(ScriptPath + '.git\') then
    exit;

  fscript := Reflect.Misc.GetPage(fscriptPage);
  try
    NetworkVersion := strToFloat(between('fVersion = ', ';', fscript));
  except
    begin
      daLogger.Error('Failed get update fversion.', []);
      exit;
    end;
  end;
  daLogger.Status('ineedbot''s functions:  Local Version: '+floatToStr(fVersion)+'  Network Version: '+floatToStr(NetworkVersion), []);
  if(fVersion < NetworkVersion)then begin
    FileNew := ScriptPath + '[Reflection] ineedbot''s functions.simba';
    ThisFile := Rewritefile(FileNew, true);
    try
        WriteFileString(ThisFile, fScript);
      except
        begin
          daLogger.Error('Failed writing to: '+FileNew, []);
          CloseFile(ThisFile);
          exit;
        end;
      end;
      CloseFile(ThisFile);
      daLogger.Status('Successfully downloaded new functions to '+FileNew+'. Please rerun this script.', []);
  end else begin
    if(fVersion = NetworkVersion)then begin
    end else begin
    end;
  end;
end;

procedure setupAutoChat;
var i, h, l : integer;
    tempString : string;

    woodcuttingStrings, fishingStrings, mageStrings, rangedStrings, prayerStrings, hpStrings, defenceStrings,
    strengthStrings, attackStrings, miningStrings, hunterStrings, slayerStrings, herbStrings, fletchingStrings, runecraftingStrings, cookingStrings, firemakingStrings, itsStrings,
    agilityStrings, thievingStrings, smithingStrings, craftingStrings, combatStrings, totalStrings, constructionStrings, farmingStrings : TStringArray;
begin
  setLength(chatTimers, 8);
  for i:=0 to high(chatTimers) do begin
    chatTimers[i].Restart;
    chatTimers[i].StartTime := -1;
  end;

  youStrings := ['you', 'u'];
  whatStrings := ['what', 'whats', 'what''s', 'wat', 'wats', 'wat''s', 'wut', 'wuts', 'wut''s', 'w0t', 'w0ts', 'w0t''s', 'wot', 'wots', 'wot''s'];
  howStrings := ['how', 'how''s', 'hows'];
  thanksStrings := ['thanks', 'thx', 'ty'];
  doingStrings := ['doing', 'doin'];
  areStrings := ['r', 'are'];
  thatStrings := ['dat', 'that', 'tht', 'dats', 'thats', 'thts', 'that''s', 'dat''s', 'tht''s'];
  imStrings := ['im', 'i''m', 'i am'];
  puncStrings := ['', ',', '.'];
  whyStrings := ['why', 'y'];
  itsStrings := ['its', 'it''s', 'it is'];
  dontStrings := ['dont', 'don''t', 'do not'];
  levelStrings := ['lvl', 'level', 'lvel', 'levl', 'lvs'];
  woodcuttingStrings := ['wood', 'woodcutting', 'woodcuttin', 'wc', 'woodcut', 'woodcutin', 'woodcuting'];
  fishingStrings := ['fish', 'fishin', 'fishing', '<gt><lt><gt>', '<lt><gt><lt>'];
  miningStrings := ['mine', 'mining', 'minin'];
  attackStrings := ['att', 'attack', 'atk', 'attck', 'attk'];
  strengthStrings := ['str', 'strength'];
  defenceStrings := ['def', 'defence'];
  hpStrings := ['hp', 'health', 'hitpoints'];
  prayerStrings := ['pray', 'prayer'];
  rangedStrings := ['range', 'ranger', 'ranged'];
  mageStrings := ['mage', 'magic', 'splash'];
  hunterStrings := ['hunt', 'hunter'];
  slayerStrings := ['slay', 'slayer'];
  herbStrings := ['herb', 'herblore'];
  fletchingStrings := ['fletch', 'fletching', 'fletchin'];
  runecraftingStrings := ['rc', 'runecraft', 'runecrafting', 'runecraftin', 'rune craft', 'rune craftin', 'rune crafting', 'r c'];
  cookingStrings := ['cook', 'cookin', 'cooking'];
  firemakingStrings := ['fm', 'fire', 'firemaking', 'fire making', 'fire makin', 'firemakin', 'f m'];
  agilityStrings := ['agility', 'agile', 'agil'];
  thievingStrings := ['theiving', 'theivin', 'theiv'];
  smithingStrings := ['smith', 'smithing', 'smithin'];
  craftingStrings := ['craft', 'craftin', 'crafting'];
  combatStrings := ['cmb', 'combat'];
  totalStrings := ['total'];
  constructionStrings := ['con', 'const', 'construction'];
  farmingStrings := ['farm', 'farming', 'farmin'];
  botStrings := ['bot', 'botters', 'b0tters', 'botting', 'b0tting', 'bots', 'b0ts', 'b0t', 'robot', 'botting', 'bottin', 'macro', 'macroing', 'macroin', 'auto', 'autoing', 'autoin', 'botter', 'b0tter', 'macroer', 'autoer'];
  niceStrings := ['awesome'];
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'c';

    setLength(niceStrings, length(niceStrings)+1);
    niceStrings[high(niceStrings)] := 'ni'+tempString+'e';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'o';

    setLength(niceStrings, length(niceStrings)+1);
    niceStrings[high(niceStrings)] := 'co'+tempString+'l';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'e';

    setLength(niceStrings, length(niceStrings)+1);
    niceStrings[high(niceStrings)] := 'swe'+tempString+'t';
  end;
  questionStrings := [''];
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + '?';

    setLength(questionStrings, length(questionStrings)+1);
    questionStrings[high(questionStrings)] := tempString;
  end;
  hiStrings := ['hiya'];
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'i';

    setLength(hiStrings, length(hiStrings)+1);
    hiStrings[high(hiStrings)] := 'h'+tempString;
  end;
  helloStrings := [];
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'o';

    setLength(helloStrings, length(helloStrings)+1);
    helloStrings[high(helloStrings)] := 'hell'+tempString;
  end;
  heyStrings := [];
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'y';

    setLength(heyStrings, length(heyStrings)+1);
    heyStrings[high(heyStrings)] := 'he'+tempString;
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'y';

    setLength(heyStrings, length(heyStrings)+1);
    heyStrings[high(heyStrings)] := 'e'+tempString;
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'y';

    setLength(heyStrings, length(heyStrings)+1);
    heyStrings[high(heyStrings)] := 'a'+tempString;
  end;
  lolStrings := [];
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'o';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'l'+tempString+'l';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + '0';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'l'+tempString+'l';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'e';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'l'+tempString+'l';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'u';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'l'+tempString+'l';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'o';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'lma'+tempString;
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'o';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'lmfa'+tempString;
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'o';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'roflma'+tempString;
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'l';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'rof'+tempString;
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'e';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'k'+tempString+'k';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'l';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := tempString;
  end;

  setLength(SkillStringsArray, 25);
  SkillStringsArray[SKILL_WOODCUTTING] := woodcuttingStrings;
  SkillStringsArray[SKILL_FISHING] := fishingStrings;
  SkillStringsArray[SKILL_MINING] := miningStrings;
  SkillStringsArray[SKILL_HUNTER] := hunterStrings;
  SkillStringsArray[SKILL_HERBLORE] := herbStrings;
  SkillStringsArray[SKILL_SLAYER] := slayerStrings;
  SkillStringsArray[24] := totalStrings;
  SkillStringsArray[23] := combatStrings;
  SkillStringsArray[SKILL_FLETCHING] := fletchingStrings;
  SkillStringsArray[SKILL_COOKING] := cookingStrings;
  SkillStringsArray[SKILL_FIREMAKING] := firemakingStrings;
  SkillStringsArray[SKILL_FARMING] := farmingStrings;
  SkillStringsArray[SKILL_ATTACK] := attackStrings;
  SkillStringsArray[SKILL_STRENGTH] := strengthStrings;
  SkillStringsArray[SKILL_DEFENCE] := defenceStrings;
  SkillStringsArray[SKILL_HITPOINTS] := hpStrings;
  SkillStringsArray[SKILL_MAGIC] := mageStrings;
  SkillStringsArray[SKILL_PRAYER] := prayerStrings;
  SkillStringsArray[SKILL_RANGE] := rangedStrings;
  SkillStringsArray[SKILL_CONSTRUCTION] := constructionStrings;
  SkillStringsArray[SKILL_RUNECRAFTING] := runecraftingStrings;
  SkillStringsArray[SKILL_CRAFTING] := craftingStrings;
  SkillStringsArray[SKILL_SMITHING] := smithingStrings;
  SkillStringsArray[SKILL_AGILITY] := agilityStrings;
  SkillStringsArray[SKILL_THIEVING] := thievingStrings;

  commonHelloStrings := [];
  for l:=0 to high(questionStrings) do
    for i:=0 to high(whatStrings) do begin
      setLength(commonHelloStrings, length(commonHelloStrings)+1);
      commonHelloStrings[high(commonHelloStrings)] := whatStrings[i]+' up'+questionStrings[l];
    end;
  for l:=0 to high(questionStrings) do
    for i:=0 to high(hiStrings) do begin
      setLength(commonHelloStrings, length(commonHelloStrings)+1);
      commonHelloStrings[high(commonHelloStrings)] := hiStrings[i]+questionStrings[l];
    end;
  for l:=0 to high(questionStrings) do
    for i:=0 to high(helloStrings) do begin
      setLength(commonHelloStrings, length(commonHelloStrings)+1);
      commonHelloStrings[high(commonHelloStrings)] := helloStrings[i]+questionStrings[l];
    end;
  for l:=0 to high(questionStrings) do
    for i:=0 to high(heyStrings) do begin
      setLength(commonHelloStrings, length(commonHelloStrings)+1);
      commonHelloStrings[high(commonHelloStrings)] := heyStrings[i]+questionStrings[l];
    end;
  for i:=0 to high(questionStrings) do begin
    setLength(commonHelloStrings, length(commonHelloStrings)+1);
    commonHelloStrings[high(commonHelloStrings)] := 'sup'+questionStrings[i];
  end;
end;

procedure setupINeedFuncs;
begin
  doFUpdate;

  setupAutoChat;

  breaks := 0;

  randomsStrings := ['molly', 'niles', 'miles', 'giles', 'sandwich lady',
  'drunken dwarf', 'genie', 'highwayman', 'dr jekyll', 'cap''n hand', 'security guard',
  'rick turpentine', 'mysterious old man', 'frog', 'null', 'mime', 'sergeant damien', 'freaky forester',
  'postie pete', 'tilt', 'flippa', 'leo', 'pillory guard', 'evil bob', 'dunce', 'capt'' arnav', 'bee keeper'];

  rewardIDs := [2528];

  closeAllTimer.Restart;
  checkForLevelTimer.Restart;
  dismissAllTimer.Restart;
  lookForChatTimer.Restart;
  {$IFDEF iDEBUG}
    debugTime.Restart;
  {$ENDIF}
  updateAllTimer.Restart;
  updateScreenTimer.Restart;
end;
