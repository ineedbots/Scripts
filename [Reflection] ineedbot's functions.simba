//Feel free to use code, MAKE SURE TO GIVE CREDIT WHERE DUE! -ineedbot
const
      fVersion = 2.093;

      fScriptPage = 'https://raw.githubusercontent.com/ineedbots/Scripts/master/%5BReflection%5D%20ineedbot''s%20functions.simba';

      Widget_StatsTab_Container = 320;

      Widget_Ded_Container = 153;
      Ded_Close = 107;

      Widget_WorldSwitch_Container = 69;
      WorldSwitch_LogOut = 19;

      Widget_Achieve_Container = 259;
      Widget_MiniGame_Container = 76;
      MiniGame_Check = 15;
      Widget_ZeahTab_Container = 245;
      ZeahTab_Check = 5;

      Widget_Teleother_Container = 326;
      Teleother_Close = -1;

      Widget_Zeah_Container = 243;
      Zeah_Close = 2;
      Zeah_Close_Child = 13;

      Widget_GameBug_Container = 156;
      GameBug_Close = 1;
      GameBug_Close_Child = 11;

      Widget_LevelUp_Container = 233;
      LevelUp_Continue = 2;

      Widget_LevelUpExtra_Container = 193;
      LevelUpExtra_Continue = 2;

      Widget_ShopMenu_Container = 300;
      ShopMenu_Close = 1;
      ShopMenu_Close_Child = 11;
      ShopMenu_Items = 2;//childs 0-39

      Widget_Lamp_Container = 134;
      Lamp_Confirm = 26;

      Widget_fallyBank_Container = 220;
      fallyBank_Close = 16;

      Widget_DepositMenu_Container = 192;
      DepositMenu_Close = 1;
      DepositMenu_Close_Child = 11;
      DepositMenu_Items = 2;  //0-27 childs
      DepositMenu_DepositInv = 3;
      DepositMenu_DepositEqu = 5;
      DepositMenu_DepositLoot = 7;

      BankMenu_DepositInv = 27;
      BankMenu_DepositEqu = 29;

      Widget_PollMenu_Container = 310;
      PollMenu_Close = 1;
      PollMenu_Close_Child = 11;

      Widget_GEMenu_Container = 465;
      GEMenu_Close = 2;
      GEMenu_Close_Child = 11;

      Widget_GEHistMenu_Container = 383;
      GEHistMenu_Close = 1;
      GEHistMenu_Close_Child = 11;

      Widget_GESetsMenu_Container = 451;
      GESetsMenu_Close = 1;
      GESetsMenu_Close_Child = 11;

      Widget_CollectMenu_Container = 402;
      CollectMenu_Close = 2;
      CollectMenu_Close_Child = 11;

      Widget_TradeScreen_Container = 335;
      TradeScreen_Close = 3;
      TradeScreen_Close_Child = 13;

      Widget_StatMenu_Container = 214;
      StatMenu_Close = 25;

      Widget_QuestMenu_Container = 275;
      QuestMenu_Close = 134;

      Widget_EquipMenu_Container = 84;
      EquipMenu_Close = 4;

      Widget_TradeConf_Container = 334;
      TradeConf_Close = 32;

      Widget_ReportMenu_Container = 553;
      ReportMenu_Close = 1;
      ReportMenu_Close_Child = 11;

      Widget_KeptMenu_Container = 102;
      KeptMenu_Close = 13;

      Widget_HouseOptions_Container = 370;
      HouseOptions_Close = 16;

      Widget_ClanOptions_Container = 590;
      ClanOptions_Close = 17;

      Widget_Lobby_Container = 378;
      Lobby_Close = 6;

      Widget_AdvancedOptions_Container = 60;
      AdvancedOptions_Close = 2;
      AdvancedOptions_Close_Child = 11;

      Widget_PriceCheck_Container = 464;
      PriceCheck_Close = 1;
      PriceCheck_Close_Child = 11;

      Widget_KeyBind_Container = 121;
      KeyBind_Close = 1;
      KeyBind_Close_Child = 11;

      Widget_BondMenu_Container = 65;
      BondMenu_Close = 3;
      BondMenu_Close_Child = 13;

      Widget_PinSettings_Container = 14;
      PinSettings_Close = 1;
      PinSettings_Close_Child = 11;

      Widget_XPMenu_Container = 137;
      XPMenu_Close = 2;
      XPMenu_Close_Child = 11;

      Widget_Orbs_Container = 160;
      Orbs_RunToggle = 22;

type TReflectDoor = record
     TileEncompass : TPointArray;
     Tile : TPoint;
     IDs : TIntegerArray;
     Offset : array[0..2] of integer;
     TileOffset : array[0..1] of integer;
end;

type TLoot = record
     SpawnTimer : TReflectTimer;
     HowLongToWait, World : Integer;
     Name : string;
end;
type TLootArray = array of TLoot;

procedure TLootArray.Add(theWorld : TLoot);
begin
  setLength(self, length(self)+1);
  self[high(self)] := theWorld;
end;

procedure TLootArray.Update;
var i : integer;
    temp : TLootArray;
begin
  temp := self;
  self := [];

  for i:=0 to high(temp) do
    if temp[i].SpawnTimer.ElapsedTime < temp[i].HowLongToWait then
      self.Add(temp[i]);
end;

function TLootArray.GetWorlds:TIntegerArray;
var i : integer;
begin
  for i:=0 to high(self) do begin
    setLength(result, length(result)+1);
    result[high(result)] := self[i].World;
  end;
end;

var SmartUserAgent, ProggieLocation, me_name, SoundString, fScript : string;
    daLogger : TReflectLogger;
    ReflectPlayer : TReflectLocalPlayer;
    breaks, breakInFinal, breakIn, breakFor, breakinRandom, breakForRandom, AntiAmount, chatTimeOften, closeAllOften, updateAllOften, me_indice, dismissAllOften, lookForChatOften, checkForLevelOften : integer;
    breakInTimer, breakForTimer, closeAllTimer, updateAllTimer, tim3, dismissAllTimer, lookForChatTimer, checkForLevelTimer, updateScreenTimer : TReflectTimer;
    rewardIDs : TIntegerArray;
    chatTimers : array of TReflectTimer;
    useAutoResponder, forceUpdate, useFakeWaitTime, wasWorking: boolean;

    commonHelloStrings, youStrings, whatStrings, howStrings, areStrings, thatStrings, questionStrings,
    doingStrings, hiStrings, helloStrings, lolStrings, heyStrings, puncStrings, imStrings,
    botStrings, dontStrings, levelStrings, whyStrings, niceStrings, thanksStrings, randomsStrings : TStringArray;

    SkillStringsArray : array of TStringArray;

procedure updateScreen(_string:string);
begin
end;

procedure sleepScript(tim : integer);
begin
  sleep(tim);
end;

Function getDirectoryName(Directory, Path: String): String;
var
  I: Integer;
  Directories: TStringArray;
Begin
  Directories := GetDirectories(Path);
  For I := 0 To High(Directories) Do
    If ExecRegExpr(Directory, Directories[I]) Then
    Begin
      Result := Directories[I];
      Exit;
    End;
End;

Function findDirectory(Directory, Path: String): Boolean;
Begin
  Result := Length(GetDirectoryName(Directory, Path)) > 0;
End;

// by Brandon
Function getJavaPath(Console: Boolean): String;
var
  Drive: String;
  CurrentPath: String;
Begin
  Drive := Copy(PluginPath, 0, 3);

  If (FindDirectory('Program\sFiles\s\(x86\)', Drive)) Then
  Begin
    CurrentPath := Drive + 'Program Files (x86)\';
  End Else
    CurrentPath := Drive + 'Program Files\';

  If (FindDirectory('Java|java', CurrentPath + '\')) Then
  Begin
    CurrentPath := CurrentPath + 'Java\';
  End Else
    Begin
      Reflect.Logger.Error('Failed To Find Path: '+CurrentPath+'Java\', []);
      Exit;
    End;

  Drive := GetDirectoryName('jre', CurrentPath);
  If (Length(Drive) > 0) Then
  Begin
    If (Console) Then
      CurrentPath := CurrentPath + Drive + '\bin\java.exe'
    Else
      CurrentPath := CurrentPath + Drive + '\bin\javaw.exe';
  End Else
    Begin
      Drive := GetDirectoryName('jdk', CurrentPath);
      If (Console) Then
      CurrentPath := CurrentPath + Drive + 'jre\bin\java.exe'
    Else
      CurrentPath := CurrentPath + Drive + 'jre\bin\javaw.exe';
    End;

  If (FileExists(CurrentPath)) Then
    Result := CurrentPath
  Else
    Reflect.Logger.Error('Failed To Find Java.exe or Javaw.exe. Please add ...\JRE\Bin to your PATH environment variable.', []);
End;

procedure TReflectionSmart.Create(
  Width, Height: Integer; Unused_UserAgent: string); override;
var
  World: Variant;
  JavaString: string;
begin
  if SmartUserAgent = '' then
    SmartUserAgent := 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0';

  Self.Width := Width;
  Self.Height := Height;
  Self.UserAgent := SmartUserAgent;
  AddOnTerminate('_TReflectionSmartFreeAll');
  if (not Self.ForceNew) and Self.Pair then
    Exit;
  World := Self.GetWorld;
  Reflect.Logger.Status('Using world %s.', [World]);
  if SmartShowConsole then
    JavaString := 'java.exe'
  else
    JavaString := 'javaw.exe';

  Self.Target := SmartSpawnClient(JavaString, StringReplace(PluginPath, '\',
    '/', [rfReplaceAll]), Format('http://oldschool%s.runescape.com/', [World]),
    'j1', Width, Height, '', SmartUserAgent, '', '');

  if Self.Target = 0 then
  begin
    Reflect.Logger.Warn('Error while finding default Java, searching for Java...', []);
    JavaString := getJavaPath(SmartShowConsole);

    Self.Target := SmartSpawnClient(JavaString, StringReplace(PluginPath, '\',
      '/', [rfReplaceAll]), Format('http://oldschool%s.runescape.com/', [World]),
      'j1', Width, Height, '', SmartUserAgent, '', '');
  end;
  if Self.Target = 0 then
    Reflect.Logger.Fatal('Failed to spawn SMART client.');
  if not Self.Init then
  begin
    SmartFreeClient(Self.Target);
    Reflect.Logger.Fatal('Failed to pair SMART client.');
  end;
end;

function TReflectionInternals.CheckIncludeUpdate: Boolean;override;
var
  Full, TempRev, TempSubRev: string;
  NewFile, tempRevInt, tempSubRevInt : Integer
begin
  Full := Reflect.Misc.GetPage('https://raw.githubusercontent.com/Elfyyy/OSR-Reflection/master/lib/internal/updating/Update.txt');
  TempRev := Between('includerev = ''', '''', Full);
  TempSubRev := Between('includesubrev = ''', '''', Full);

  try
    tempRevInt := StrToInt(TempRev);
  except
    begin
      Reflect.Logger.Error('Failed get update version.', []);
      exit;
    end;
  end;
  try
    tempSubRevInt := StrToInt(TempSubRev);
  except
    begin
      Reflect.Logger.Error('Failed get update sub version.', []);
      exit;
    end;
  end;

  if (tempRevInt > IncludeRevision) or tempSubRevInt > SubRev then
    begin
        Reflect.Logger.Warn('Reflection Update Available');
      Result := True;
    end;
end;

function TReflectionSmart.GetWorld: string;override;
var Worlds : TIntegerArray;
begin
  if (World < 299) then
  begin
    Reflect.Logger.Warn('World variable not valid, trying recommended world...');
    Result := Between('id=''member-world'' href=''http://oldschool.runescape.com/game?world=', '''>',
    GetPage('http://oldschool.runescape.com/slu'));
    if (Result <> '') and InRange(StrToIntDef(ExtractFromStr(Result, Numbers),
      -1), 301, 394) then begin
      Result := IntToStr(StrToInt(Result) - 300);
      Exit;
    end;

    Reflect.Logger.Warn('Failed to get recommended world, trying random world...');
    Worlds := [301, 302, 303, 304, 305, 306, 308, 309, 310, 311, 312, 313, 314, 316, 317, 318, 319, 320,
               321, 322, 325, 326, 327, 328, 329, 330, 333, 334, 335, 336, 337, 338, 341, 342, 343, 344,
               345, 346, 349, 350, 351, 352, 353, 354, 357, 358, 359, 360, 361, 362, 365, 366, 367, 368,
               369, 370, 373, 374, 375, 376, 377, 378, 381, 382, 383, 384, 385, 386, 393, 394];
    Result := IntToStr(Worlds[random(length(Worlds))] - 300);
  end else
    Result := IntToStr(World - 300);
end;

function TReflectionText.GetUpText: string;override;
var
  Options: TStringArray;
begin
  Options := Reflect.Text.GetMenuOptions;
  if (High(Options) - 1) > 0 then
    Result := Options[0] + ' / ' + ToStr(High(Options) - 1) + ' more options'
  else
    if length(Options) > 0 then
      Result := Options[0]
    else
      result := '';
  if Result = 'Cancel' then
    Result := '';
end;

function TReflectionChat.NpcChooseOption(Options: TStringArray): Boolean;Override;
var
  Wid, Child : TReflectWidget;
  I, J, K, L : Integer;
  daString : string;
begin
  for I := 0 to 600 do
    for J := 0 to 6 do
    begin
      if not Wid.Exists(I, J) then
          Continue();

      Wid.GetWidget(I, J);
      daString := Wid.GetText();

      for l:=0 to high(options) do
        if pos(options[l], daString) > 0 then
        begin
          Wid.Interact();
          Wid.Free();
          exit(true);
        end;

      if Wid.HasChild() then
      begin
        for K := 0 to 6 do
        begin
          Child.GetChild(Wid, K);
          daString := Child.GetText();
          for l:=0 to high(options) do
            if pos(options[l], daString) > 0 then
            begin
              Child.Interact();
              Child.Free();
              Wid.Free();
              exit(true);
            end;

          Child.Free();
        end;
      end;
      Wid.Free();
    end;
end;

procedure TReflectInvItemArray.GetAllIncludeEmpty;
var
  I, TheId, Count: Integer;
  InvWidget: TReflectWidget;
begin
  Reflect.Mem.FreeObjects(ckInvItems, True);
  InvWidget.GetWidget(WIDGET_Inventory_Container, 0);
  HookCache[ckInvItems][0] := InvWidget.Reference;
  for I := 0 to 27 do
  begin
    TheId := Reflect.Smart.GetFieldArrayInt(
      InvWidget.Reference, Widget_InvIDs, I);
    Inc(Count);
    SetLength(Self, Count);
    with Self[Count - 1] do
    begin
      Reference := InvWidget.Reference;
      _Id := TheId - 1;
      _InvSlot := I + 1;
    end;
  end;
end;

function TReflectLocalPlayer._GetName: string; //this should be in the include
begin
  Result := Reflect.Smart.GetFieldString(Self.Reference, Player_Name);
end;

function GetWordsEx(text, wordCharacters: string): TStringArray;  //thanks  Janilabo
var
  l, i, r: Integer;
begin
  l := Length(text);
  if ((l > 0) and (wordCharacters <> '')) then
  begin
    SetLength(Result, l);
    for i := 1 to l do
      if (Pos(text[i], wordCharacters) > 0) then
      begin
        Result[r] := text[i];
        for i := (i + 1) to l do
          if (Pos(text[i], wordCharacters) > 0) then
            Result[r] := (Result[r] + text[i])
          else
            Break;
        Inc(r);
      end;
  end;
  SetLength(Result, r);
end;

procedure TReflectLocalPlayer.Logout;override;
var
  LogoutWidget: TReflectWidget;
begin
  if (not Self.IsLoggedIn) then
    Exit;

  LogoutWidget.GetWidget(Widget_WorldSwitch_Container, WorldSwitch_LogOut);
  if LogoutWidget.Interact then begin
    LogoutWidget.Free;
    exit;
  end;
  LogoutWidget.Free;

  if not Reflect.Gametab.Open(Gametab_Logout) then
    exit;
  LogoutWidget.GetWidget(Widget_Logout_Container, 6);
  LogoutWidget.Interact;
  LogoutWidget.Free;
end;

procedure TReflectGroundItemArray.GetAt(RealTile: TTile);override;
var
  BaseX, BaseY, Plane: Integer;
  temp : TReflectGroundItemArray;
begin
  Reflect.Mem.FreeObjects(ckGroundList, False);
  BaseX := Reflect.Misc.BaseX;
  BaseY := Reflect.Misc.BaseY;
  Plane := Reflect.Tiles.GetPlane;
  temp._GetAt(
    Point(RealTile.X - BaseX, RealTile.Y - BaseY), BaseX, BaseY, Plane);
  Reflect.Mem.FreeObjects(ckGroundArray, False);
  if high(temp) > -1 then
    self := temp
  else
    self := [];
end;

function getPriceGE(id : integer) : integer;   //thx hoodz and flight!
var sellSource, webSource : string;
    i : integer;
    _strings : TStringArray;
begin
  if not InRange(id, 0, 12856) then
    exit;
  try
    webSource := getPage('http://services.runescape.com/m=itemdb_oldschool/viewitem?obj='+intToStr(id));
  except
    daLogger.Warn('Failed to connect to grand exchange database', []);
    exit;
  end;
  sellSource := between('<h3>Current Guide Price <span title=''', '''', webSource);
  _strings := GetWordsEx(sellSource, '0123456789');

  sellSource := '';
  if length(_strings) > 0 then
    for i:=0 to high(_strings) do
      sellSource := sellSource+_strings[i];

  if (Length(sellSource) > 0) then
    result := strToInt(sellSource)
  else
    daLogger.Warn('Failed to get grand exchange price for item ID: '+intToStr(id), []);
end;

function R_DidLevelUp(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_LevelUp_Container, LevelUp_Continue);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('0');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

function R_DidLevelUpExtra(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_LevelUpExtra_Container, LevelUpExtra_Continue);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('1');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

function R_StatMenuOpen(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_StatMenu_Container, StatMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('2');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

function R_TradeConfOpen(doClick: boolean = false): boolean;
var W : TReflectWidget;
    _B : TBox;
begin
  W.GetWidget(Widget_TradeConf_Container, TradeConf_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('3');
    {$ENDIF}
    _B := W.GetBounds;
    result := (_B.X1 > 0);
    if result then begin
      if doClick then
        W.Interact;
    end;
    W.Free;
  end;
end;

function R_LobbyOpen(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_Lobby_Container, Lobby_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('4');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

function R_QuestMenuOpen(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_QuestMenu_Container, QuestMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('5');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

function R_EquipMenuOpen(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_EquipMenu_Container, EquipMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('6');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

function R_ReportMenuOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_ReportMenu_Container, ReportMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('11');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, ReportMenu_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_KeptMenuOpen(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_KeptMenu_Container, KeptMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('8');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

function R_HouseOptionsOpen(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_HouseOptions_Container, HouseOptions_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('9');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

function R_ClanOptionsOpen(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_ClanOptions_Container, ClanOptions_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('10');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

function R_DepositMenuOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_DepositMenu_Container, DepositMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('11');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, DepositMenu_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_CollectMenuOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_CollectMenu_Container, CollectMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('12');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, CollectMenu_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_GEHistMenuOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_GEHistMenu_Container, GEHistMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('13');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, GEHistMenu_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_TradeScreenOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
    _B : TBox;
begin
  W.GetWidget(Widget_TradeScreen_Container, TradeScreen_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('14');
    {$ENDIF}
    _B := W.GetBounds;
    result := (_B.X1 > 0);
    if result then begin
      if doClick then begin
        C.GetChild(W, TradeScreen_Close_Child);
        C.Interact;
        C.Free;
      end;
    end;
    W.Free;
  end;
end;

function R_PinSettingsOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_PinSettings_Container, PinSettings_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('15');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, PinSettings_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_XPMenuOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_XPMenu_Container, XPMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('16');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, XPMenu_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_GESetsMenuOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_GESetsMenu_Container, GESetsMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('17');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, GESetsMenu_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_PollMenuOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_PollMenu_Container, PollMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('18');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, PollMenu_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_GEMenuOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_GEMenu_Container, GEMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('19');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, GEMenu_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_SellMenuOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_ShopMenu_Container, ShopMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('20');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, ShopMenu_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_AdvancedOptionsOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_AdvancedOptions_Container, AdvancedOptions_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('21');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, AdvancedOptions_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_PriceCheckOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_PriceCheck_Container, PriceCheck_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('22');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, PriceCheck_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_KeyBindOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_KeyBind_Container, KeyBind_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('23');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, KeyBind_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_BondMenuOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_BondMenu_Container, BondMenu_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('24');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, BondMenu_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_GameBugOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_GameBug_Container, GameBug_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('26');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, GameBug_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_ZeahOpen(doClick: boolean = false): boolean;
var W, C : TReflectWidget;
begin
  W.GetWidget(Widget_Zeah_Container, Zeah_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('27');
    {$ENDIF}
    if doClick then begin
      C.GetChild(W, Zeah_Close_Child);
      C.Interact;
      C.Free;
    end;
    W.Free;
  end;
end;

function R_TeleotherOpen(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_Teleother_Container, Teleother_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('28');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

function R_fallyBankOpen(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_fallyBank_Container, fallyBank_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('29');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

function R_dedOpen(doClick: boolean = false): boolean;
var W : TReflectWidget;
begin
  W.GetWidget(Widget_Ded_Container, Ded_Close);
  result := W.NotNull;
  if result then begin
    {$IFDEF iDEBUG}
      writeln('30');
    {$ENDIF}
    if doClick then
      W.Interact;
    W.Free;
  end;
end;

procedure R_closeAllMenus;
begin
  {$IFDEF iDEBUG}
    if Reflect.Bank.IsOpen or Reflect.Bank.isPinOpen then
      writeln('25');
  {$ENDIF}
  if Reflect.Bank.IsOpen or Reflect.Bank.isPinOpen or R_BondMenuOpen(false) or R_PriceCheckOpen(false) or R_AdvancedOptionsOpen(false) or
  R_HouseOptionsOpen(false) or R_KeptMenuOpen(false) or R_ReportMenuOpen(false) or R_EquipMenuOpen(false) or R_QuestMenuOpen(false) or
  R_StatMenuOpen(false) or R_ClanOptionsOpen(false) or R_SellMenuOpen(false) or R_DepositMenuOpen(false) or
  R_GEMenuOpen(false) or R_PollMenuOpen(false) or R_TradeScreenOpen(false) or R_GESetsMenuOpen(false) or
  R_GEHistMenuOpen(false) or R_CollectMenuOpen(false) or R_TradeConfOpen(false) or R_LobbyOpen(false) or
  R_KeyBindOpen(false) or R_XPMenuOpen(false) or R_PinSettingsOpen(false) or R_GameBugOpen(false) or R_ZeahOpen(false)
  or R_fallyBankOpen(false) or R_dedOpen(false) then begin
    updateScreen('Closing interface');
    if ((Reflect.Bank.IsOpen or Reflect.Bank.isPinOpen) and Reflect.Bank.Close) or R_BondMenuOpen(true) or R_PriceCheckOpen(true) or R_AdvancedOptionsOpen(true) or
    R_HouseOptionsOpen(true) or R_KeptMenuOpen(true) or R_ReportMenuOpen(true) or R_EquipMenuOpen(true) or R_QuestMenuOpen(true) or
    R_StatMenuOpen(true) or R_ClanOptionsOpen(true) or R_SellMenuOpen(true) or R_DepositMenuOpen(true) or
    R_GEMenuOpen(true) or R_PollMenuOpen(true) or R_TradeScreenOpen(true) or R_GESetsMenuOpen(true) or
    R_GEHistMenuOpen(true) or R_CollectMenuOpen(true) or R_TradeConfOpen(true) or R_LobbyOpen(true) or
    R_KeyBindOpen(true) or R_XPMenuOpen(true) or R_PinSettingsOpen(true) or R_GameBugOpen(true) or R_ZeahOpen(true)
    or R_fallyBankOpen(true) or R_dedOpen(true) then
      updateScreen('Closed interface');
  end;
end;

function TReflectionGametab.CurrentColor:Integer;
var i : integer;
    TNB : TBox;
    Pnt : TPoint;
begin
  for i:=0 to 14 do begin
    case i of
      0: TNB:=[535,172,540,176];
      1: TNB:=[564,172,571,176];
      2: TNB:=[596,172,600,176];
      3: TNB:=[630,172,635,176];
      4: TNB:=[663,172,670,176];
      5: TNB:=[696,172,703,176];
      6: TNB:=[730,173,736,180];
      7: TNB:=[525,469,534,473];
      8: TNB:=[563,469,570,473];
      9: TNB:=[596,469,602,473];
      10:TNB:=[629,469,634,473];
      11:TNB:=[662,469,669,473];
      12:TNB:=[695,469,700,473];
      13:TNB:=[728,469,733,473];
    end;

    if i <> 14 then
      if findColorTolerance(Pnt.x, Pnt.y, 1910383, TNB.X1, TNB.Y1, TNB.X2, TNB.Y2, 13) then
        break;
  end;

  if i <> 14 then begin
    case i of
      0: Result := Gametab_CombatOptions;
      1: Result := Gametab_Stats;
      2: Result := Gametab_QuestList;
      3: Result := GameTab_Inventory;
      4: Result := Gametab_WornEquipment;
      5: Result := Gametab_Prayer ;
      6: Result := Gametab_Magic;
      7: Result := Gametab_ClanChat;
      8: Result := Gametab_FriendsList;
      9: Result := Gametab_IgnoreList;
      10:Result := Gametab_Logout;
      11:Result := Gametab_Options;
      12:Result := Gametab_Emotes;
      13:Result := Gametab_MusicPlayer;
    end;
  end else begin
    if R_DepositMenuOpen or Reflect.Bank.IsOpen then
      Result := GameTab_Inventory
    else
      Result := -1;
  end;
end;

procedure hoverSkill(skill:integer);
var W : TReflectWidget;
    tb : TBox;
begin
  if TReflectionGametab.CurrentColor <> Gametab_Stats then
    TReflectionGametab.Open(Gametab_Stats);
  case skill of
    SKILL_ATTACK:W.GetWidget(Widget_StatsTab_Container, 1);
    SKILL_STRENGTH:W.GetWidget(Widget_StatsTab_Container, 2);
    SKILL_DEFENCE:W.GetWidget(Widget_StatsTab_Container, 3);
    SKILL_RANGE:W.GetWidget(Widget_StatsTab_Container, 4);
    SKILL_PRAYER:W.GetWidget(Widget_StatsTab_Container, 5);
    SKILL_MAGIC:W.GetWidget(Widget_StatsTab_Container, 6);
    SKILL_RUNECRAFTING:W.GetWidget(Widget_StatsTab_Container, 7);
    SKILL_CONSTRUCTION:W.GetWidget(Widget_StatsTab_Container, 8);
    SKILL_HITPOINTS:W.GetWidget(Widget_StatsTab_Container, 9);
    SKILL_AGILITY:W.GetWidget(Widget_StatsTab_Container, 10);
    SKILL_HERBLORE:W.GetWidget(Widget_StatsTab_Container, 11);
    SKILL_THIEVING:W.GetWidget(Widget_StatsTab_Container, 12);
    SKILL_CRAFTING:W.GetWidget(Widget_StatsTab_Container, 13);
    SKILL_FLETCHING:W.GetWidget(Widget_StatsTab_Container, 14);
    SKILL_SLAYER:W.GetWidget(Widget_StatsTab_Container, 15);
    SKILL_HUNTER:W.GetWidget(Widget_StatsTab_Container, 16);
    SKILL_MINING:W.GetWidget(Widget_StatsTab_Container, 17);
    SKILL_SMITHING:W.GetWidget(Widget_StatsTab_Container, 18);
    SKILL_FISHING:W.GetWidget(Widget_StatsTab_Container, 19);
    SKILL_COOKING:W.GetWidget(Widget_StatsTab_Container, 20);
    SKILL_FIREMAKING:W.GetWidget(Widget_StatsTab_Container, 21);
    SKILL_WOODCUTTING:W.GetWidget(Widget_StatsTab_Container, 22);
    SKILL_FARMING:W.GetWidget(Widget_StatsTab_Container, 23);
    -1:W.GetWidget(Widget_StatsTab_Container, randomRange(1, 24));
    else W.GetWidget(Widget_StatsTab_Container, 24);
  end;
  if W.NotNull then begin
    tb := w.GetBounds;
    Reflect.Mouse.Move(tb);
  end;
end;

function TReflectLocalPlayer.FFlag(
  TileDist: Integer; Timeout: Integer = 15000): Boolean;override;
var
  Timer: TReflectTimer;
begin
  Timer.Start;
  while Distance(Self.GetTile.X, Self.GetTile.Y, Self.GetDestination.X,
      Self.GetDestination.Y) > TileDist do
  begin
    if (Timeout > 0) and (Timer.ElapsedTime > Timeout) then
      Exit(False);
    Wait(RandomRange(200, 250));
  end;
  Exit(True);
end;

function TReflectionGametab.Current: Integer;override;
var
  TempWidget: TReflectWidget;
  Containers, Gametabs: TIntegerArray;
  I: Integer;
begin
  Containers := [Widget_ClanChat_Container, Widget_FriendsList_Container,
    Widget_IgnoreList_Container, Widget_Logout_Container,
    Widget_Options_Container, Widget_Emotes_Container,
    Widget_MusicPlayer_Container, Widget_CombatOptions_Container,
    Widget_Stats_Container, Widget_WornEquipment_Container,
    Widget_Prayer_Container, Widget_Magic_Container, Widget_QuestList_Container,
    Widget_ChangeWorld_Container
  ];
  Gametabs := [Gametab_ClanChat, Gametab_FriendsList, Gametab_IgnoreList,
    Gametab_Logout, Gametab_Options, Gametab_Emotes, Gametab_MusicPlayer,
    Gametab_CombatOptions, Gametab_Stats, Gametab_WornEquipment, Gametab_Prayer,
    Gametab_Magic, Gametab_QuestList, GameTab_Inventory
  ];
  for I := 0 to High(Gametabs) do
  begin
    TempWidget.GetWidget(Containers[I], 0);
    if not (TempWidget.IsHidden) and (TempWidget.GetBounds.X1 <> -1) then
    begin
      TempWidget.Free;
      Exit(Gametabs[I]);
    end;
    TempWidget.Free;
  end;

  TempWidget.GetWidget(Widget_Achieve_Container, 0);
  if not (TempWidget.IsHidden) and (TempWidget.GetBounds.X1 <> -1) then
  begin
    TempWidget.Free;
    Exit(Widget_QuestList_Container);
  end;
  TempWidget.Free;

  TempWidget.GetWidget(Widget_MiniGame_Container, MiniGame_Check);
  if not (TempWidget.IsHidden) and (TempWidget.GetBounds.X1 <> -1) then
  begin
    TempWidget.Free;
    Exit(Widget_QuestList_Container);
  end;
  TempWidget.Free;

  TempWidget.GetWidget(Widget_ZeahTab_Container, ZeahTab_Check);
  if not (TempWidget.IsHidden) and (TempWidget.GetBounds.X1 <> -1) then
  begin
    TempWidget.Free;
    Exit(Widget_QuestList_Container);
  end;
  TempWidget.Free;

  Result := GameTab_Inventory;
end;

function getEquippedItemBounds(Which: string): TBox;
begin
  case Which of
    'helm', 'helmet' :
      Result := inttoBox(629, 213, 656, 240);
    'cape' :
      Result := inttoBox(588, 252, 615, 279);
    'amulet', 'neck', 'necklace' :
      Result := inttoBox(629, 252, 656, 279);
    'arrows', 'bolts' :
      Result := inttoBox(670, 252, 697, 279);
    'right hand', 'weapon' :
      Result := inttoBox(573, 291, 600, 318);
    'plate', 'chest', 'platebody' :
      Result := inttoBox(629, 291, 656, 318);
    'left hand', 'sheild', 'shield' :
      Result := inttoBox(685, 291, 712, 318);
    'legs', 'platelegs', 'skirt', 'plateskirt' :
      Result := inttoBox(629, 331, 656, 358);
    'gloves', 'gauntlets' :
      Result := inttoBox(573, 371, 600, 398);
    'boots':
      Result := inttoBox(629, 371, 656, 398);
    'ring' :
      Result := inttoBox(685, 371, 712, 398);
  end;
end;

function R_GetEquipText: string;
begin
  result := TReflectionGametab.GetWieldedWeapon;
  if result = '' then begin
    if TReflectionGametab.CurrentColor <> Gametab_CombatOptions then
      Reflect.Gametab.Open(Gametab_CombatOptions);
    result := TReflectionGametab.GetWieldedWeapon;
  end;
end;

function ExpFromLevel(Level: integer): integer;   //thanks tehq!
begin
  Result := (round((Level / 4) + (75 * pow(2, (Level / 7)))));
end;

function LevelFromExp(Experience: integer): integer;  //thanks tehq!
var
  CurrentExp, n: integer;
begin
  for n := 1 to 120 do
  begin
    if CurrentExp < Experience then
      CurrentExp := round((1 / 4) *((n + (300 * pow(2, n / 7))))) + CurrentExp
    else
      break;
    Result := n;
  end;
end;

function statExpToGoal(CurrentLevel, EndLevel: integer): integer;   //thanks tehq!
var
  i: integer;
begin
  for i := CurrentLevel to EndLevel - 1 do
    Result := ExpFromLevel(i) + Result;
end;

function varExpToGoal(Experience, EndLevel: integer): integer;   //thanks tehq!
var
  CurrentLevel, NextLevel, i: integer;
begin
  CurrentLevel := LevelFromExp(Experience);
  NextLevel := statExpToGoal(1, CurrentLevel + 1);
  Result := NextLevel - Experience;
  for i := CurrentLevel + 1 to EndLevel - 1 do
    incEx(Result, ExpFromLevel(i));
end;

Procedure TMufasaBitmap.DrawClippedText(Text, Font: String; Position: TPoint; shadow: boolean; Colour: TColor = clRed);
var
  W, H: Integer;
  TPA: Array of TPoint;
Begin
  TPA := TPAFromText(Text, Font, W, H);
  OffsetTPA(TPA, Position);
  if shadow then begin
    OffsetTPA(TPA, Point(1, 1));
    Self.DrawTPA(TPA, clBlack+1);
    OffsetTPA(TPA, Point(-1, -1));
  end;
  Self.DrawTPA(TPA, Colour);
End;

Procedure TMufasaBitmap.DrawEllipse(Center: TPoint; XRadius, YRadius: Integer; Colour: TColor = clRed; Fill: Boolean = False);
var
  TPA: Array of TPoint;
Begin
  TPA := TPAFromEllipse(Center.X, Center.Y, XRadius, YRadius);
  If (Fill) then FillEllipse(TPA);
  Self.DrawTPA(TPA, Colour);
End;

function R_TileOnMS(Tile : TPoint; var OutputPoint : TPoint; x : integer = 0; y : integer = 0; z : integer = 0):boolean;
var tempB : TBox;
begin
  OutputPoint := TReflectionTiles.TileToMS(Tile, x, y, z);
  tempB := intToBox(MSX1, MSY1, MSX2, MSY2);
  result := PointInBox(OutputPoint, tempB);
end;

function R_TileOnMM(Tile : TPoint; var OutputPoint : TPoint):boolean;
var tempB : TBox;
begin
  OutputPoint := TReflectionTiles.TileToMM(Tile);
  tempB := intToBox(MmX1, MmY1, MmX2, MmY2);
  result := PointInBox(OutputPoint, tempB);
end;

procedure R_TryMakeTileOnMS(Tile:TPOint;x : integer = 0; y : integer = 0; z : integer = 0);
var t:TReflectTimer;
    _tile : TPoint;
begin
  if not R_TileOnMS(tile, _Tile, x, y, z) and (TReflectionTiles.DistanceFromTile(Tile) <= 25) then begin
    TReflectionTiles.RotateCameraToTile(tile);
    t.Restart;
    keyDown(VK_Down);
    while(t.ElapsedTime < 2500) and not R_TileOnMS(tile, _Tile, x, y, z) do
      sleepScript(50);
    keyUp(VK_Down);
  end;
end;

procedure fastClick(button: Integer);
var
  x, y: integer;
begin
  getMousePos(x, y);
  holdMouse(x, y, button);

  Wait(RandomRange(50, 100));

  getMousePos(x, y);
  releaseMouse(x, y, button);
end;

function chooseOptionMultiFast(Option: string): Boolean;
var
  Index, MenuX, MenuY, MenuWidth, XOff, YOff,x ,y: Integer;
  Options: TStringArray;
  Left: Boolean;
begin
  Options := Reflect.Text.GetMenuOptions;
  if not Reflect.Text.IsMenuOpen then
    Exit;
  Index := Reflect.Text.GetMenuIndex(Option, Options);
  MenuX := Reflect.Smart.GetFieldInt(0, Client_MenuX) + 4;
  MenuY := Reflect.Smart.GetFieldInt(0, Client_MenuY) + 4;
  MenuWidth := Reflect.Smart.GetFieldInt(0, Client_MenuWidth);
  XOff := RandomRange(4, MenuWidth - 4);
  YOff := RandomRange(20, 25) + (Index * 15);
  if (MenuX + (MenuWidth div 2) > 765) then
    Left := True;
  if (MenuX - (MenuWidth div 2) < 0) then
    Left := False;
  if (Index = -1) then
  begin
    GetMousePos(MenuX, MenuY);
    if Left then
      Reflect.Mouse.Move(Point(
        MenuX - 30 - MenuWidth + Random(10), MenuY + RandomRange(-2, 2)), 2, 2)
    else
      Reflect.Mouse.Move(Point(
        MenuX + 30 + MenuWidth + Random(10), MenuY + RandomRange(-2, 2)), 2, 2);
    Exit;
  end;
  GetMousePos(x, y);
  MoveMouse(x, randomRange((MenuY+YOff)-2, (MenuY+YOff)+2));
  fastClick(Mouse_Left);
  Result := True;
end;

function R_isDoingAnimation(animationIDs:array of integer;time:integer):boolean;
var _time:treflecttimer;
begin
  _time.restart;
  while (_time.Elapsedtime < time) and ReflectPlayer.isLoggedIn do begin
     if(InIntArray(animationIDs, ReflectPlayer.GetAnimation)) then
     begin
       result := true;
       exit;
     end;
     sleepScript(50);
  end;
end;

procedure doProggy(where:string);
var w, h, bmp, graphic : integer;
begin
  graphic := Reflect.Smart.Graphics.ToBitmap(false);
  getClientDimensions(w, h);
  bmp := bitmapFromClient(0, 0, w, h);
  SetTransparentColor(graphic, 0);
  fastDrawTransparent(0, 0, graphic, bmp);
  saveBitmap(bmp, where);
  daLogger.Status('Saved Proggy to: '+where, []);
  FreeBitmap(bmp);
end;

function findAndSetTarget(TitlePrefix: String; SetAsTarget: Boolean): Boolean;
var
  T : TSysProcArr;
  I : Integer;
begin
  T := GetProcesses;
  for I := High(T) downto 0 do
    if Pos(TitlePrefix, T[I].Title) <> 0 then
    begin
      Result := True;
      if SetAsTarget then SetTarget(T[I]);
      Exit;
    end;
end;

function isKeyDownReal(_key:Word):boolean;
var
  KMTarget, ITarget: Integer;
begin
  if not IsTargetValid() then daLogger.Error('Target invalid', []);
  KMTarget := GetKeyMouseTarget;
  ITarget := GetImageTarget;
  if not findAndSetTarget('SMART', True) then
    findAndSetTarget('Old', True);

  result := isKeyDown(_key);

  FreeTarget(GetImageTarget);
  SetKeyMouseTarget(KMTarget);
  SetImageTarget(ITarget);
end;

function R_MSToTile(TP:TPoint;dist:integer=10):TPoint;
var _x, _y, i: integer;
    tiles, realTiles : TPointArray;
    myTile : TPoint;
    found : boolean;
begin
  myTile := TReflectionTiles.GetGlobalTile;
  for _x:=(-dist) to dist do
    for _y:=(-dist) to dist do begin
      inc(i);
      setLength(tiles, i);
      setLength(realTiles, i);
      tiles[i-1] := TReflectionTiles.TileToMS(Point(myTile.x+_x, myTile.y+_y), 0, 0, 0);
      realTiles[i-1] := Point(myTile.x+_x, myTile.y+_y);
    end;

  for i:=0 to high(tiles) do
    if not found or (distance(TP.X, TP.Y, tiles[i].X, tiles[i].Y) < distance(TP.X, TP.Y, myTile.X, myTile.Y)) then begin
      myTile := tiles[i];
      result := realTiles[i];
      found := true;
    end;
end;

function R_ToggleRun(turnOn : boolean):boolean;
var W : TReflectWidget;
    prev : boolean;
    tim : TReflectTimer;
begin
  if (turnOn and not TReflectLocalPlayer.IsRunOn) or (not turnOn and TReflectLocalPlayer.IsRunOn) then begin
    W.GetWidget(Widget_Orbs_Container, Orbs_RunToggle);
    if W.NotNull then begin
      prev := TReflectLocalPlayer.IsRunOn;
      result := W.Interact;
      W.Free;
      tim.Restart;
      while (prev = TReflectLocalPlayer.IsRunOn) and (tim.Elapsedtime < 2500) do
        sleepScript(50);
    end;
  end;
end;

function R_QuickDeposit(action : string):boolean;
var W : TReflectWidget;
begin
  if R_DepositMenuOpen then begin
    if action = 'inv' then
      W.GetWidget(Widget_DepositMenu_Container, DepositMenu_DepositInv)
    else if action = 'equ' then
      W.GetWidget(Widget_DepositMenu_Container, DepositMenu_DepositEqu)
    else
      W.GetWidget(Widget_DepositMenu_Container, DepositMenu_DepositLoot);
  end else begin
    if action = 'inv' then
      W.GetWidget(WIDGET_Bank_Container, BankMenu_DepositInv)
    else
      W.GetWidget(WIDGET_Bank_Container, BankMenu_DepositEqu);
  end;
  if W.NotNull then begin
    result := W.Interact;
    W.Free;
  end;
end;

Function GetUpText_WhiteColor: String;
Begin
  Result:=GetTextAt(8, 8, 0, 5, 4, 14541281, 55, 25, 'UpChars07');
End;

function slotActivated(i : integer):boolean;
var TB:Tbox;
    x,y : integer;
begin
  TB := TReflectionInventory.InvBox(i);
  Result := findColor(x, y, 16777215, TB.x1, TB.y1, TB.x2, TB.y2);
end;

function anySlotActivated(soft:boolean=false):boolean;
var _string : string;
    i : integer;
begin
  if TReflectionGametab.CurrentColor <> Gametab_Inventory then
    exit(false);

  if not soft then begin
    _string := GetUpText_WhiteColor;
    if (pos('->', _string) <= 0) or (pos('Use', _string) <= 0) then
      exit(false);
  end;

  for i:=1 to 28 do
    if slotActivated(i) then
      exit(true);
end;

procedure FixActive;
var tempBox:TBox;
    i : integer;
    upt : string;
begin
  if TReflectionGametab.CurrentColor <> Gametab_Inventory then
    exit;

  upt := GetUpText_WhiteColor;
  if (pos('->', upt) > 0) and (pos('Use', upt) > 0) then
    for i:=1 to 28 do
      if slotActivated(i) then begin
        if TReflectionGametab.CurrentColor <> Gametab_Inventory then
          Reflect.Gametab.Open(Gametab_Inventory);
        tempBox := TReflectionInventory.invBox(i);
        Reflect.Mouse.Move(point(randomRange(tempBox.x1, tempBox.x2), randomRange(tempBox.y1, tempBox.y2)), 0, 0);
        sleepScript(500+random(250));
        Reflect.Mouse.Click(Mouse_left);
        sleepScript(500+random(250));
      end;
end;

function depositItemBox(Item: Integer): TBox;
begin
  Result.X1 := 132 + (Item - 1) mod 7 * 40;
  Result.Y1 := 75 + (Item - 1) div 7 * 42;
  Result.X2 := Result.X1 + 30;
  Result.Y2 := Result.Y1 + 30;
end;

function itemInSlot(I: Integer): Boolean;
var
  X, Y: Integer;
  TB: TBox;
begin
  if not inRange(I, 1, 28) then
    Exit;

  if R_DepositMenuOpen(false) then
    TB := depositItemBox(I)
  else
    TB := TReflectionInventory.invBox(I);
  result := findColor(x, y, 65536, TB.x1, TB.y1, TB.x2, TB.y2);
end;

function R_CountItems(IDs:Tintegerarray):integer;
var i : integer;
    _items : TReflectInvItemArray;
begin
  _items.GetAll;
  for i:=0 to high(_items) do
    if inIntArray(IDs, _items[i].GetID) then
      result := result + _items[i].GetQuantity;
end;

function IsMenuOpen:boolean;
var p : tpoint;
    tempTPA : TPointArray;
begin
  getClientDimensions(P.X, P.Y);
  if findColorsTolerance(tempTPA, 4674653, 0, 0, P.x-1, P.y-1, 0) then
    result := true;
end;

procedure exitMenu;
var timer : TReflectTimer;
    _x, _y : integer;
begin
  timer.Restart;
  while IsMenuOpen and (timer.Elapsedtime < 2500) do begin
    getMousePos(_x, _y);
    Reflect.Mouse.Move(Point(_x, _y-10), 5, 5);
  end;
end;

function R_InteractTile(tile:Tpoint; actions:tstringarray; x:integer = 0; y:integer = 0; z:integer = 0; doSecond:boolean=true):boolean;
var RSTile : TPoint;
    yaw : extended;
    _x, _y, pitch, i : integer;
begin
  if R_TileOnMS(Tile, RSTile, x, y, z) then
    for i:=0 to high(actions) do begin
      getMousePos(_x, _y);
      if not Reflect.Text.OptionExists(actions[i]) or (distance(_x, _y, rsTile.x, rsTile.y) > 5) then
        Reflect.Mouse.Move(rsTile, 5, 5);
      if(Reflect.Text.IsUpText(actions[i])) then begin
        FastClick(mouse_left);
        result := true;
        break;
      end else begin
        if Reflect.Text.OptionExists(actions[i]) then begin
          FastClick(mouse_right);
          result := Reflect.Text.ChooseOption(actions[i]);
          break;
        end else begin
          exitMenu;
        end;
      end;
    end;

  if not result and doSecond then begin
    yaw := 360 - Reflect.Compass.AngleDeg;
    pitch := round((Reflect.Compass.GetPitch - 128) / 25.5);
    Reflect.Compass.Make('rand');
    Reflect.Compass.MakePitch(9);

    if R_TileOnMS(Tile, RSTile, x, y, z) then
      for i:=0 to high(actions) do begin
        getMousePos(_x, _y);
        if not Reflect.Text.OptionExists(actions[i]) or (distance(_x, _y, rsTile.x, rsTile.y) > 5) then
          Reflect.Mouse.Move(rsTile, 5, 5);
        if(Reflect.Text.IsUpText(actions[i])) then begin
          FastClick(mouse_left);
          result := true;
          break;
        end else begin
          if Reflect.Text.OptionExists(actions[i]) then begin
            FastClick(mouse_right);
            result := Reflect.Text.ChooseOption(actions[i]);
            break;
          end else begin
            exitMenu;
          end;
        end;
      end;

    Reflect.Compass.Make(yaw);
    Reflect.Compass.MakePitch(pitch);
  end;
end;

function R_InteractNPC(IDs:TIntegerArray; actions:tstringarray; isFree:boolean; x:integer = 0; y:integer = 0; z:integer = 50):boolean;
var RsTile, npcTile : TPoint;
    i : integer;
    _npcs : TReflectNPCArray;
begin
  _npcs.GetAll;
  for i:=0 to high(_npcs) do begin
    npcTile := _npcs[i].GetTile;
    if inIntArray(IDs, _npcs[i].GetId) and ((not(_npcs[i].IsUnderAttack) and ((_npcs[i].GetInteractingIndex <= 0) or (_npcs[i].GetInteractingIndex = me_indice))) or not isFree) then begin
      if not R_TileOnMS(npcTile, RSTile, x, y, z) then begin
        ReflectPlayer.BlindWalkMM(npcTile, 5);
        ReflectPlayer.FFlag(2+randomRange(-2, 2));
        sleepScript(random(1500));
      end;

      result := R_InteractTile(npcTile, actions, x, y, z, false);
      exit;
    end;
  end;
end;

function R_TryInteractNPC(IDs:TIntegerArray; actions:tstringarray; isFree:boolean; tries:integer; x:integer = 0; y:integer = 0; z:integer = 50):boolean;
var i : integer;
begin
  i := 0;
  result := false;
  while (i<tries) and not result and ReflectPlayer.isLoggedIn do begin
    result := R_InteractNPC(IDs, actions, isFree, x, y, z);
    inc(i);
  end;
end;

function TReflectDoor.Open(wantOut: boolean): boolean;
function openDaDoor(daDoor:TReflectDoor):boolean;
var tP : TPoint;
    tObj : TReflectObject;
    timer : TReflectTimer;
begin
  tObj.GetAt(ObjBoundary, daDoor.Tile);
  if inIntArray(daDoor.IDs, tObj.GetID) then begin
    if not R_TileOnMS(daDoor.Tile, tP, daDoor.Offset[0], daDoor.Offset[1], daDoor.Offset[2]) then
      ReflectPlayer.BlindWalkMM(Point(daDoor.Tile.x+daDoor.TileOffset[0], daDoor.Tile.y+daDoor.TileOffset[1]), 1);
    updateScreen('Opening door.');
    result := R_InteractTile(daDoor.Tile, ['Open'], daDoor.Offset[0], daDoor.Offset[1], daDoor.Offset[2]);
    ReflectPlayer.FFlag(0, 2500+random(500));
    timer.restart;
    tObj.GetAt(ObjBoundary, daDoor.Tile);
    while timer.Elapsedtime < 2500 and inIntArray(daDoor.IDs, tObj.GetID) do begin
      sleepScript(50);
      tObj.GetAt(ObjBoundary, daDoor.Tile);
    end;
  end else begin
    result := true;
    if not Reflect.Tiles.NearTile(daDoor.Tile, 40) then
      ReflectPlayer.BlindWalkMM(daDoor.Tile, 1);
  end;
end;
begin
  if wantOut then begin
    if Reflect.Tiles.InPolygon(Self.TileEncompass) then
      result := openDaDoor(self)
    else
      result := true;
  end else begin
    if not Reflect.Tiles.InPolygon(Self.TileEncompass) then
      result := openDaDoor(self)
    else
      result := true;
  end;
end;

procedure updateAllRefVars;
begin
  updateScreen('Updating ref vars');
  ReflectPlayer.Create;
  me_name := ReflectPlayer._GetName;
  me_indice := ReflectPlayer.GetPlayerIndex;
end;

function GenerateRandomString:string;
var letters : tstringarray;
    i, leng : integer;
begin
  letters := [' ','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','''','"','!','@','#','?','$','^','&','*','(',')','-', '_','=','+','0','1','2','3','4','5','6','7','8','9','{','}','|','/','.',',','<','>',';',':','\'];
  leng := random(30);
  result := '';
  for i:=0 to leng do begin
    result:=result+letters[random(length(letters))];
  end;
end;

function GenerateRandomString2:string;
var letters : tstringarray;
    i, leng : integer;
begin
  letters := [' ','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];
  leng := random(30);
  result := '';
  for i:=0 to leng do begin
    result:=result+letters[random(length(letters))];
  end;
end;

function GenerateRandomString3:string;
var letters : tstringarray;
    i, leng : integer;
begin
  letters := ['a', 'w', 's', 'd', ' '];
  leng := random(30);
  result := '';
  for i:=0 to leng do begin
    result:=result+letters[random(length(letters))];
  end;
end;

procedure doBreakCheck;
var breakForFinal : integer;
    breakForTimer, breakUpdate : TReflectTimer;
begin
  if breakInTimer.Elapsedtime < breakInFinal then
    exit;

  breakForFinal := breakFor + randomRange(-breakForRandom, breakForRandom);
  breakForTimer.restart;
  breakUpdate.restart;

  updateScreen('Taking a break. '+TReflectionTime.msToTime((breakForFinal-breakForTimer.Elapsedtime), TIME_Bare)+' break time left.');
  daLogger.Status('Its been '+TReflectionTime.msToTime(breakInFinal, TIME_FORMAL)+'. Taking a '+TReflectionTime.msToTime(breakForFinal, TIME_FORMAL)+' long break.', []);
  ReflectPlayer.LogOut;
  while breakForTimer.Elapsedtime < breakForFinal do begin
    updateScreen('Taking a break. '+TReflectionTime.msToTime((breakForFinal-breakForTimer.Elapsedtime), TIME_Bare)+' break time left.');
    sleepScript(1500+random(5000));
    if breakUpdate.Elapsedtime > 300000 then begin
      breakUpdate.restart;
      daLogger.Status(TReflectionTime.msToTime((breakForFinal-breakForTimer.Elapsedtime), TIME_FORMAL)+' break time left.', []);
    end;
  end;

  breakInTimer.restart;
  breakInFinal := breakIn + randomRange(-breakInRandom, breakInRandom);
  inc(breaks);
  updateScreen('Break time is up.');
  daLogger.Status('Break time is up. Next break in '+TReflectionTime.msToTime(breakInFinal, TIME_FORMAL), []);
end;

function getNearPlayersAmount:integer;
var _players : TReflectPlayerArray;
    i : integer;
    tempP : TPoint;
begin
  _players.GetAll;
  for i:=0 to high(_players) do begin
    if R_TileOnMS(_players[i].GetTile, tempP, 0, 0, 50) then begin
      inc(result);
    end;
  end;
end;

procedure doAntibanTalk;
var _string:tstringarray;
    i, maxS, people : integer;
begin
  people := getNearPlayersAmount-1;
  if (people <= 0) then
    exit;

  if (chatTimers[high(chatTimers)].Elapsedtime < chatTimeOften) then
    exit;

  chatTimers[high(chatTimers)].Restart;

  maxS := 130;
  {$IFDEF CHOPPER}
    maxS := 160;
  {$ENDIF}
  {$IFDEF FISHER}
    maxS := 152;
  {$ENDIF}
  {$IFDEF FIREMAKER}
    maxS := 152;
  {$ENDIF}
  {$IFDEF MINER}
    maxS := 152;
  {$ENDIF}
  {$IFDEF COOKER}
    maxS := 152;
  {$ENDIF}
  case random(maxS) of
    0:_string:=['am i muted?'];
    1:_string:=['wtf'];
    2:_string:=['ok'];
    3:_string:=['hi'];
    4:_string:=['anyone there'];
    5:_string:=['w00t'];
    6:_string:=['woot'];
    7:_string:=['wewt'];
    8:_string:=['u there?'];
    9:_string:=['lagggg?'];
    10:_string:=['hello'];
    11:_string:=['hello?'];
    12:_string:=['hi?'];
    13:_string:=['wtf?'];
    14:_string:=['lol'];
    15:_string:=['lol?'];
    16:_string:=['anyone there?'];
    17:_string:=['any1 there'];
    18:_string:=['any1 there?'];
    19:_string:=['you there'];
    20:_string:=['u there'];
    21:_string:=['you there?'];
    22:_string:=['l'];
    23:_string:=['l00l'];
    24:_string:=['l0l'];
    25:_string:=['l000l'];
    26:_string:=['am i muted'];
    27:_string:=['yo'];
    28:_string:=['sup'];
    29:_string:=['sup?'];
    30:_string:=['boring'];
    31:_string:=['this is boring'];
    32:_string:=['anyone here'];
    33:_string:=['anyone here?'];
    34:_string:=['any1 here'];
    35:_string:=['any1 here?'];
    36:_string:=['bot'];
    37:_string:=['bot?'];
    38:_string:=['bots'];
    39:_string:=['bots?'];
    40:_string:=['loool'];
    41:_string:=['lool'];
    42:_string:=[':)'];
    43:_string:=['=)'];
    44:_string:=['yes'];
    45:_string:=['yes!'];
    46:_string:=['gf'];
    47:_string:=['gg'];
    48:_string:=['rekt'];
    49:_string:=['ayy lmao'];
    50:_string:=['ayyy lmao'];
    51:_string:=['ayyyy lmao'];
    52:_string:=['how'];
    53:_string:=['how?'];
    54:_string:=['k'];
    55:_string:=['ok?'];
    56:_string:=['k?'];
    57:_string:=[' '];
    58:_string:=['a q p','     W'];
    59:_string:=['stfu'];
    60:_string:=['stfu?'];
    61:_string:=['how cum'];
    62:_string:=['how cum?'];
    63:_string:=['how com'];
    64:_string:=['how com?'];
    65:_string:=['how come?'];
    66:_string:=['how come'];
    67:_string:=['a q p','    W'];
    68:_string:=['a q p','      W'];
    69:_string:=['|\/\/\/|','|______|'];
    70:_string:=['|\/\/\/|','|_____|'];
    71:_string:=['|\/\/\/|','|_______|'];
    72:_string:=['no'];
    73:_string:=['no?'];
    74:_string:=['wat'];
    75:_string:=['wat?'];
    76:_string:=['what'];
    77:_string:=['what?'];
    78:_string:=['wut'];
    79:_string:=['wut?'];
    80:_string:=['lolwat'];
    81:_string:=['lol wat'];
    82:_string:=['lolwut'];
    83:_string:=['lol wut'];
    84:_string:=['im bored'];
    85:_string:=['i''m bored'];
    86:_string:=['i"m bored'];
    87:_string:=['help'];
    88:_string:=['help?'];
    89:_string:=['umm'];
    90:_string:=['hmm'];
    91:_string:=['uh'];
    92:_string:=['huh'];
    93:_string:=[GenerateRandomString];
    94:_string:=['u w0t m8'];
    95:_string:=['u wot m8'];
    96:_string:=['u w0t m8?'];
    97:_string:=['u wot m8?'];
    98:_string:=[GenerateRandomString2];
    99:_string:=[GenerateRandomString3];
    100:_string:=[GenerateRandomString];
    101:_string:=[intToStr(random(10))];
    102:_string:=[intToStr(random(100))];
    103:_string:=['ha'];
    104:_string:=['haha'];
    105:_string:=['hahaha'];
    106:_string:=['no u'];
    107:_string:=['no you'];
    108:_string:=['n00b'];
    109:_string:=['noob'];
    110:_string:=['n00bs'];
    111:_string:=['noobs'];
    112:_string:=['added'];
    113:_string:=['add me'];
    114:_string:=['add me?'];
    115:_string:=['reported'];
    116:_string:=['ignored'];
    117:_string:=['***'];
    118:_string:=['****'];
    119:_string:=['*****'];
    120:_string:=['******'];
    121:_string:=['wth'];
    122:_string:=['wth?'];
    123:_string:=['lag'];
    124:_string:=['lagg'];
    125:_string:=['lag?'];
    126:_string:=['lagg?'];
    127:_string:=['laggg?'];
    128:_string:=['laggg'];
    129:_string:=['lagggg'];
    {$IFDEF CHOPPER}
      130:_string:=['woodcut lvl'];
      131:_string:=['woodcut level'];
      132:_string:=['woodcut level?'];
      133:_string:=['woodcutting lvl'];
      134:_string:=['woodcutting lvl?'];
      135:_string:=['woodcutting level'];
      136:_string:=['woodcutting level?'];
      137:_string:=['woodcuttin lvl'];
      138:_string:=['woodcuttin lvl?'];
      139:_string:=['woodcuttin level'];
      140:_string:=['woodcuttin level?'];
      141:_string:=['woodcuttin lvls'];
      142:_string:=['woodcuttin lvls?'];
      143:_string:=['woodcuttin levels'];
      144:_string:=['woodcuttin levels?'];
      145:_string:=['woodcut lvls'];
      146:_string:=['woodcut levels'];
      147:_string:=['woodcut levels?'];
      148:_string:=['woodcutting lvls'];
      149:_string:=['woodcutting lvls?'];
      150:_string:=['woodcutting levels'];
      151:_string:=['woodcutting levels?'];
      152:_string:=['wc lvl'];
      153:_string:=['wc lvls'];
      154:_string:=['wc lvl?'];
      155:_string:=['wc lvls?'];
      156:_string:=['wc level'];
      157:_string:=['wc levels'];
      158:_string:=['wc level?'];
      159:_string:=['wc levels?'];
    {$ENDIF}
    {$IFDEF FISHER}
      130:_string:=['fishin lvl'];
      131:_string:=['fishin lvl?'];
      132:_string:=['fishin level'];
      133:_string:=['fishin level?'];
      134:_string:=['fishin lvls'];
      135:_string:=['fishin lvls?'];
      136:_string:=['fishin levels'];
      137:_string:=['fishin levels?'];
      138:_string:=['fish lvl'];
      139:_string:=['fish level'];
      140:_string:=['fish level?'];
      141:_string:=['fishing lvl'];
      142:_string:=['fishing lvl?'];
      143:_string:=['fishing level'];
      144:_string:=['fishing level?'];
      145:_string:=['fish lvls'];
      146:_string:=['fish levels'];
      147:_string:=['fish levels?'];
      148:_string:=['fishing lvls'];
      149:_string:=['fishing lvls?'];
      150:_string:=['fishing levels'];
      151:_string:=['fishing levels?'];
    {$ENDIF}
    {$IFDEF FIREMAKER}
      130:_string:=['firemakin lvl'];
      131:_string:=['firemakin lvl?'];
      132:_string:=['firemakin level'];
      133:_string:=['firemakin level?'];
      134:_string:=['firemakin lvls'];
      135:_string:=['firemakin lvls?'];
      136:_string:=['firemakin levels'];
      137:_string:=['firemakin levels?'];
      138:_string:=['fire levels'];
      139:_string:=['fire levels?'];
      140:_string:=['firemaking lvls'];
      141:_string:=['firemaking lvls?'];
      142:_string:=['firemaking levels'];
      143:_string:=['firemaking levels?'];
      144:_string:=['fire lvl'];
      145:_string:=['fire level'];
      146:_string:=['fire level?'];
      147:_string:=['firemaking lvl'];
      148:_string:=['firemaking lvl?'];
      149:_string:=['firemaking level'];
      150:_string:=['firemaking level?'];
      151:_string:=['fire lvls'];
    {$ENDIF}
    {$IFDEF MINER}
      130:_string:=['minin lvl'];
      131:_string:=['minin lvl?'];
      132:_string:=['minin level'];
      133:_string:=['minin level?'];
      134:_string:=['minin lvls'];
      135:_string:=['minin lvls?'];
      136:_string:=['minin levels'];
      137:_string:=['minin levels?'];
      138:_string:=['mine levels'];
      139:_string:=['mine levels?'];
      140:_string:=['mining lvls'];
      141:_string:=['mining lvls?'];
      142:_string:=['mining levels'];
      143:_string:=['mining levels?'];
      144:_string:=['mine lvls'];
      145:_string:=['mine lvl'];
      146:_string:=['mine level'];
      147:_string:=['mine level?'];
      148:_string:=['mining lvl'];
      149:_string:=['mining lvl?'];
      150:_string:=['mining level'];
      151:_string:=['mining level?'];
    {$ENDIF}
    {$IFDEF COOKER}
      130:_string:=['cookin lvl'];
      131:_string:=['cookin lvl?'];
      132:_string:=['cookin level'];
      133:_string:=['cookin level?'];
      134:_string:=['cookin lvls'];
      135:_string:=['cookin lvls?'];
      136:_string:=['cookin levels'];
      137:_string:=['cookin levels?'];
      138:_string:=['cook levels'];
      139:_string:=['cook levels?'];
      140:_string:=['cooking lvls'];
      141:_string:=['cooking lvls?'];
      142:_string:=['cooking levels'];
      143:_string:=['cooking levels?'];
      144:_string:=['cook lvls'];
      145:_string:=['cook lvl'];
      146:_string:=['cook level'];
      147:_string:=['cook level?'];
      148:_string:=['cooking lvl'];
      149:_string:=['cooking lvl?'];
      150:_string:=['cooking level'];
      151:_string:=['cooking level?'];
    {$ENDIF}
  end;
  daLogger.Status('Saying: '''+toStr(_string)+''' outloud too '+intToStr(people)+' people.', []);
  for i:=0 to high(_string) do
    if useAutoResponder then
      TReflectionKeyboard.TypeSend(_string[i], true);
end;

procedure doConversation(_strings:TStringArray);
var tim : TReflectTimer;
    newArray : TStringArray;
begin
  newArray := _strings;
  setLength(newArray, length(newArray) + 1);
  newArray[high(newArray)] := 'Click here to continue';

  tim.Restart;
  while (tim.Elapsedtime < 2500) do begin
    if TReflectionChat.NpcChooseOption(newArray) then
      tim.Restart;
    sleepScript(random(1000));
  end;
end;

procedure dismissAllRandoms;
var i, j, lampSkill:integer;
    _npcs:TReflectNPCArray;
    _item : TReflectInvItem;
    name : string;
    tile : TPOint;
    w : TReflectWidget;
    tb : TBox;
begin
  //3 att 4 str 5 range 6 magic 7 def
  //8 hp 9 pray 10 agile 11 herb 12 theiv 13 craft
  //14 rc 22 slay 23 farm 15 mine 16 smith 17 fish
  //18 cook 19 fm 20 wc 21 fletch 24 con 25 hunt
  lampSkill := 18;
  {$IFDEF CHOPPER}
    lampSkill := 20;
  {$ENDIF}
  {$IFDEF FISHER}
    lampSkill := 17;
  {$ENDIF}
  {$IFDEF FIREMAKER}
    lampSkill := 19;
  {$ENDIF}
  {$IFDEF MINER}
    lampSkill := 15;
  {$ENDIF}
  {$IFDEF COOKER}
    lampSkill := 18;
  {$ENDIF}
  for i:=0 to high(rewardIDs) do begin
    if _item.Find(rewardIDs[i]) then begin
      if TReflectionGametab.CurrentColor <> Gametab_Inventory then
        Reflect.Gametab.Open(Gametab_Inventory);
      updateScreen('Solving lamp.');
      daLogger.Status('Solving lamp...', []);
      tb := _item.getBox;
      Reflect.Mouse.Move(tb, mouse_left);
      sleepScript(1000+random(500));
      W.GetWidget(widget_lamp_container, lampSkill);
      if W.NotNull then begin
        W.Interact;
        W.Free;
        W.GetWidget(widget_lamp_container, lamp_confirm);
        if W.NotNull then begin
          W.Interact;
          W.Free;
        end;
      end;
      sleepScript(1000+random(500));
    end;
  end;
  _npcs.GetAll;
  for i:=0 to high(_npcs) do begin
    if (_npcs[i].getInteractingIndex = me_indice) then begin
      for j:=0 to high(randomsStrings) do begin
        name := _npcs[i].getname;
        if (pos(randomsStrings[j], lowercase(name)) > 0) then begin
          tile := _npcs[i].getTile;
          if useFakeWaitTime and wasWorking then begin
            updateScreen('Doing fake ''antiban'' wait.');
            sleepScript(1000+random(7500));
          end;
          wasWorking := false;
          if randomsStrings[j] = 'genie' then begin
            updateScreen('Talking to: '+name);
            if R_InteractTile(tile, ['Talk'], 0, 0, 50) then begin
              sleepScript(1000+random(1000));
              doConversation([]);
              daLogger.Status('Talked to random: '+name, []);
            end;
          end else begin
            updateScreen('Dismissing: '+name);
            if R_InteractTile(tile, ['Dismiss'], 0, 0, 50) then begin
              sleepScript(1000+random(1000));
              daLogger.Status('Dismissed random: '+name, []);
            end;
          end;
          exit;
        end;
      end;
    end;
  end;
end;

procedure doAnAnti;
var maxS: integer;
begin
  Reflect.MouseSpeed := randomRange(15, 30);
  updateScreen('Performing antiban...');
  maxS := 18;
  {$IFDEF CHOPPER}
    maxS := 19;
  {$ENDIF}
  {$IFDEF FISHER}
    maxS := 19;
  {$ENDIF}
  {$IFDEF FIREMAKER}
    maxS := 19;
  {$ENDIF}
  {$IFDEF MINER}
    maxS := 19;
  {$ENDIF}
  {$IFDEF COOKER}
    maxS := 19;
  {$ENDIF}
  case random(maxS) of
    0:TReflectionAntiban.RandomRClick;
    1:hoverSkill(-1);
    2:TReflectionAntiban.PickUpMouse;
    3:TReflectionAntiban.SleepAndMoveMouse(random(2500));
    4:TReflectionAntiban.RandomMovement;
    5:TReflectionAntiban.CompassMovement(0, 360, false);
    6:TReflectionAntiban.HumanRandomMouse;
    7:TReflectionAntiban.ExamineInv;
    8:TReflectionAntiban.RandomFKeys(false);
    9:TReflectionAntiban.RandomTab(false);
    10:TReflectionAntiban.BoredHuman;
    11:TReflectionAntiban.RandomTab(true);
    12:TReflectionAntiban.MMouseOffClient('rand');
    13:TReflectionAntiban.MMouseOffClient('top');
    14:TReflectionAntiban.MMouseOffClient('bottom');
    15:TReflectionAntiban.MMouseOffClient('left');
    16:TReflectionAntiban.MMouseOffClient('right');
    17:doAntibanTalk;
    {$IFDEF CHOPPER}
      18:hoverSkill(Skill_Woodcutting);
    {$ENDIF}
    {$IFDEF FISHER}
      18:hoverSkill(Skill_Fishing);
    {$ENDIF}
    {$IFDEF FIREMAKER}
      18:hoverSkill(Skill_Firemaking);
    {$ENDIF}
    {$IFDEF MINER}
      18:hoverSkill(Skill_Mining);
    {$ENDIF}
    {$IFDEF COOKER}
      18:hoverSkill(Skill_Cooking);
    {$ENDIF}
  end;
end;

procedure doAntiban;
var i : integer;
begin
  if checkForLevelTimer.Elapsedtime > checkForLevelOften then begin
    if R_DidLevelUp or R_DidLevelUpExtra then begin
      if useFakeWaitTime and wasWorking then begin
        updateScreen('Doing fake ''antiban'' wait.');
        sleepScript(1000+random(7500));
      end;
      wasWorking := false;
      updateScreen('Clicking level up!');

      for i:=0 to 1000 do
        if not FileExists(ScriptPath+'ineedbot''s clicking level up '+toStr(i)+'.png')then
          break;
      doProggy(ScriptPath+'ineedbot''s clicking level up '+toStr(i)+'.png');

      R_DidLevelUp(true);
      R_DidLevelUpExtra(true);
    end;
    checkForLevelTimer.Restart;
  end;

  i:=random(AntiAmount);
  case i of
    1..10:doAnAnti;
    else begin
      {$IFDEF iDEBUG}
        writeln(tim3.Elapsedtime, ' ', i);
      {$ENDIF}
    end;
  end;
  {$IFDEF iDEBUG}
    tim3.Restart;
  {$ENDIF}
end;

type AutoChatRefPlayer = record
     SayText, RSName : string;
     isInteracting : boolean;
end;

function getAutoChatRefPlayers(var amountOfPeople : integer):array of AutoChatRefPlayer;
var _players : TReflectPlayerArray;
    i, h : integer;
    tempP : TPoint;
    name : string;
begin
  _players.GetAll;
  for i:=0 to high(_players) do begin
    name := _players[i].GetName;
    if (pos('mod ', lowercase(name)) > 0) then begin
      daLogger.Status('FOUND JMOD '+name+', LOGGING OUT!', []);
      updateScreen('FOUND JMOD '+name+', LOGGING OUT!');
      ReflectPlayer.LogOut;
      sleepScript(100000+random(50000));
      exit;
    end;
    if (name <> me_name) and R_TileOnMS(_players[i].GetTile, tempP, 0, 0, 50) then begin
      inc(amountOfPeople);
      setLength(result, amountOfPeople);

      h := amountOfPeople-1;
      result[h].SayText := _players[i].GetSpokenText;
      result[h].RSName := name;
      if (_players[i].GetInteractingIndex = me_indice) then
        result[h].isInteracting := true;
    end;
  end;
end;

function getChatThink(_player : AutoChatRefPlayer; var sendType : integer):string;
var msg : string;
    checkStrings : TStringArray;
    i, h, j : integer;
begin
  msg := lowercase(_player.SayText);
  if _player.isInteracting or (pos(lowercase(me_name), msg) > 0) then begin
    checkStrings := ['wat', 'what?', 'wat?', '?', 'what'];
    sendType := 6;
    exit(checkStrings[random(length(checkStrings))]);
  end;

  sendType := -1;
  if length(msg) > 0 then begin
    for i:=0 to high(commonHelloStrings) do
      if (commonHelloStrings[i] = msg) then begin
        checkStrings := ['hey', 'hi', 'hello', 'sup'];
        sendType := 0;
        exit(checkStrings[random(length(checkStrings))]);
      end;

     for i:=0 to high(SkillStringsArray) do
      for h:=0 to high(levelStrings) do
        for j:=0 to high(SkillStringsArray[i]) do
          if (pos(levelStrings[h], msg) > 0) and (pos(SkillStringsArray[i][j], msg) > 0) then begin
            checkStrings := [intToStr(TReflectLocalPlayer.GetMaxSkillLevel(i))];
            sendType := 2;
            exit(checkStrings[random(length(checkStrings))]);
          end;

    for i:=0 to high(levelStrings) do
      if (pos(levelStrings[i], msg) > 0) then begin
        checkStrings := ['?'];
        sendType := 4;
        exit(checkStrings[random(length(checkStrings))]);
      end;

    checkStrings := GetWordsEx(msg, 'abcdefghijklmnopqrstuvwxyz0123456789-''');

    for i:=0 to high(botStrings) do
      for h:=0 to high(checkStrings) do
        if(botStrings[i] = checkStrings[h]) then begin
          checkStrings := ['no', 'lol', '?'];
          sendType := 1;
          exit(checkStrings[random(length(checkStrings))]);
        end;

    for i:=0 to high(lolStrings) do
      for h:=0 to high(checkStrings) do
        if (lolStrings[i] = checkStrings[h]) then begin
          checkStrings := ['lol', 'l0l', 'lel', 'lool'];
          sendType := 3;
          exit(checkStrings[random(length(checkStrings))]);
        end;

    for i:=0 to high(niceStrings) do
      for h:=0 to high(checkStrings) do
        if (niceStrings[i] = checkStrings[h]) then begin
          checkStrings := ['thx', 'thanks', 'ty'];
          sendType := 5;
          exit(checkStrings[random(length(checkStrings))]);
        end;
  end;
end;

procedure autoChat;
var AutoChatRefPlayers : array of AutoChatRefPlayer;
    amountOfPeople, i, sendType : integer;
    respondString, theString : string;
begin
  AutoChatRefPlayers := getAutoChatRefPlayers(amountOfPeople);
  for i:=0 to amountOfPeople-1 do begin
    respondString := getChatThink(AutoChatRefPlayers[i], sendType);
    if sendType > -1 then begin
      if ((sendType = 5) and (chatTimers[2].Elapsedtime < chatTimeOften) and (chatTimers[sendType].Elapsedtime > chatTimeOften)) or ((chatTimers[sendType].Elapsedtime > chatTimeOften) and (sendType <> 5)) then begin
        theString := Reflect.Text.RemoveFormatting(AutoChatRefPlayers[i].SayText);
        daLogger.Status('Responding to player '''+AutoChatRefPlayers[i].RSName+''' who said '''+theString+''' with '''+respondString+''' ('+intToStr(sendType)+')', []);
        updateScreen('Doing autoChat...');
        chatTimers[sendType].Restart;
        sleepScript(1000+random(5000));
        if useAutoResponder then
          TReflectionKeyboard.typeSend(respondString, true);
        sleepScript(random(750));
      end;
      if sendType = 6 then
        playSound(SoundString);
    end;
  end;
end;

procedure randomHandler;
begin
  if dismissAllTimer.Elapsedtime > dismissAllOften then begin
    dismissAllRandoms;
    dismissAllTimer.Restart;
  end;
  doAntiban;
  if closeAllTimer.Elapsedtime > closeAllOften then begin
    R_closeAllMenus;
    closeAllTimer.Restart;
  end;
  if lookForChatTimer.Elapsedtime > lookForChatOften then begin
    autoChat;
    lookForChatTimer.Restart;
  end;
  if updateAllTimer.Elapsedtime > updateAllOften then begin
    updateAllRefVars;
    updateAllTimer.Restart;
  end;
end;

procedure doFUpdate;     //thanks shuttleu
var NetworkVersion : extended;
    FileNew : string;
    ThisFile : integer;
begin
  try
    NetworkVersion := strToFloat(between('fVersion = ', ';', fscript));
  except
    begin
      daLogger.Error('Failed get update fversion.', []);
      exit;
    end;
  end;
  daLogger.Status('ineedbot''s functions:  Local Version: '+floatToStr(fVersion)+'  Network Version: '+floatToStr(NetworkVersion), []);
  if((fVersion < NetworkVersion) or forceUpdate)then begin
    FileNew := ScriptPath + '[Reflection] ineedbot''s functions.simba';
    ThisFile := Rewritefile(FileNew, true);
    try
        WriteFileString(ThisFile, fScript);
      except
        begin
          daLogger.Error('Failed writing to: '+FileNew, []);
          CloseFile(ThisFile);
          exit;
        end;
      end;
      CloseFile(ThisFile);
      daLogger.Status('Successfully downloaded new functions to '+FileNew+'. Please rerun this script.', []);
  end else begin
    if(fVersion = NetworkVersion)then begin
    end else begin
    end;
  end;
end;

procedure setupAutoChat;
var i, h, l : integer;
    tempString : string;

    woodcuttingStrings, fishingStrings, mageStrings, rangedStrings, prayerStrings, hpStrings, defenceStrings,
    strengthStrings, attackStrings, miningStrings, hunterStrings, slayerStrings, herbStrings, fletchingStrings, runecraftingStrings, cookingStrings, firemakingStrings, itsStrings,
    agilityStrings, thievingStrings, smithingStrings, craftingStrings, combatStrings, totalStrings, constructionStrings, farmingStrings : TStringArray;
begin
  setLength(chatTimers, 8);
  for i:=0 to high(chatTimers) do begin
    chatTimers[i].Restart;
    chatTimers[i].StartTime := -1;
  end;

  youStrings := ['you', 'u'];
  whatStrings := ['what', 'whats', 'what''s', 'wat', 'wats', 'wat''s', 'wut', 'wuts', 'wut''s', 'w0t', 'w0ts', 'w0t''s', 'wot', 'wots', 'wot''s'];
  howStrings := ['how', 'how''s', 'hows'];
  thanksStrings := ['thanks', 'thx', 'ty'];
  doingStrings := ['doing', 'doin'];
  areStrings := ['r', 'are'];
  thatStrings := ['dat', 'that', 'tht', 'dats', 'thats', 'thts', 'that''s', 'dat''s', 'tht''s'];
  imStrings := ['im', 'i''m', 'i am'];
  puncStrings := ['', ',', '.'];
  whyStrings := ['why', 'y'];
  itsStrings := ['its', 'it''s', 'it is'];
  dontStrings := ['dont', 'don''t', 'do not'];
  levelStrings := ['lvl', 'level', 'lvel', 'levl', 'lvs'];
  woodcuttingStrings := ['wood', 'woodcutting', 'woodcuttin', 'wc', 'woodcut', 'woodcutin', 'woodcuting'];
  fishingStrings := ['fish', 'fishin', 'fishing', '<gt><lt><gt>', '<lt><gt><lt>'];
  miningStrings := ['mine', 'mining', 'minin'];
  attackStrings := ['att', 'attack', 'atk', 'attck', 'attk'];
  strengthStrings := ['str', 'strength'];
  defenceStrings := ['def', 'defence'];
  hpStrings := ['hp', 'health', 'hitpoints'];
  prayerStrings := ['pray', 'prayer'];
  rangedStrings := ['range', 'ranger', 'ranged'];
  mageStrings := ['mage', 'magic', 'splash'];
  hunterStrings := ['hunt', 'hunter'];
  slayerStrings := ['slay', 'slayer'];
  herbStrings := ['herb', 'herblore'];
  fletchingStrings := ['fletch', 'fletching', 'fletchin'];
  runecraftingStrings := ['rc', 'runecraft', 'runecrafting', 'runecraftin', 'rune craft', 'rune craftin', 'rune crafting', 'r c'];
  cookingStrings := ['cook', 'cookin', 'cooking'];
  firemakingStrings := ['fm', 'fire', 'firemaking', 'fire making', 'fire makin', 'firemakin', 'f m'];
  agilityStrings := ['agility', 'agile', 'agil'];
  thievingStrings := ['theiving', 'theivin', 'theiv'];
  smithingStrings := ['smith', 'smithing', 'smithin'];
  craftingStrings := ['craft', 'craftin', 'crafting'];
  combatStrings := ['cmb', 'combat'];
  totalStrings := ['total'];
  constructionStrings := ['con', 'const', 'construction'];
  farmingStrings := ['farm', 'farming', 'farmin'];
  botStrings := ['bot', 'botters', 'b0tters', 'botting', 'b0tting', 'bots', 'b0ts', 'b0t', 'robot', 'botting', 'bottin', 'macro', 'macroing', 'macroin', 'auto', 'autoing', 'autoin', 'botter', 'b0tter', 'macroer', 'autoer'];
  niceStrings := ['awesome'];
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'c';

    setLength(niceStrings, length(niceStrings)+1);
    niceStrings[high(niceStrings)] := 'ni'+tempString+'e';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'o';

    setLength(niceStrings, length(niceStrings)+1);
    niceStrings[high(niceStrings)] := 'co'+tempString+'l';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'e';

    setLength(niceStrings, length(niceStrings)+1);
    niceStrings[high(niceStrings)] := 'swe'+tempString+'t';
  end;
  questionStrings := [''];
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + '?';

    setLength(questionStrings, length(questionStrings)+1);
    questionStrings[high(questionStrings)] := tempString;
  end;
  hiStrings := ['hiya'];
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'i';

    setLength(hiStrings, length(hiStrings)+1);
    hiStrings[high(hiStrings)] := 'h'+tempString;
  end;
  helloStrings := [];
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'o';

    setLength(helloStrings, length(helloStrings)+1);
    helloStrings[high(helloStrings)] := 'hell'+tempString;
  end;
  heyStrings := [];
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'y';

    setLength(heyStrings, length(heyStrings)+1);
    heyStrings[high(heyStrings)] := 'he'+tempString;
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'y';

    setLength(heyStrings, length(heyStrings)+1);
    heyStrings[high(heyStrings)] := 'e'+tempString;
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'y';

    setLength(heyStrings, length(heyStrings)+1);
    heyStrings[high(heyStrings)] := 'a'+tempString;
  end;
  lolStrings := [];
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'o';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'l'+tempString+'l';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + '0';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'l'+tempString+'l';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'e';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'l'+tempString+'l';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'u';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'l'+tempString+'l';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'o';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'lma'+tempString;
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'o';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'lmfa'+tempString;
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'o';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'roflma'+tempString;
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'l';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'rof'+tempString;
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'e';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := 'k'+tempString+'k';
  end;
  for i:=0 to 10 do begin
    tempString := '';
    for h:=0 to i do
      tempString := tempString + 'l';

    setLength(lolStrings, length(lolStrings)+1);
    lolStrings[high(lolStrings)] := tempString;
  end;

  setLength(SkillStringsArray, 25);
  SkillStringsArray[SKILL_WOODCUTTING] := woodcuttingStrings;
  SkillStringsArray[SKILL_FISHING] := fishingStrings;
  SkillStringsArray[SKILL_MINING] := miningStrings;
  SkillStringsArray[SKILL_HUNTER] := hunterStrings;
  SkillStringsArray[SKILL_HERBLORE] := herbStrings;
  SkillStringsArray[SKILL_SLAYER] := slayerStrings;
  SkillStringsArray[24] := totalStrings;
  SkillStringsArray[23] := combatStrings;
  SkillStringsArray[SKILL_FLETCHING] := fletchingStrings;
  SkillStringsArray[SKILL_COOKING] := cookingStrings;
  SkillStringsArray[SKILL_FIREMAKING] := firemakingStrings;
  SkillStringsArray[SKILL_FARMING] := farmingStrings;
  SkillStringsArray[SKILL_ATTACK] := attackStrings;
  SkillStringsArray[SKILL_STRENGTH] := strengthStrings;
  SkillStringsArray[SKILL_DEFENCE] := defenceStrings;
  SkillStringsArray[SKILL_HITPOINTS] := hpStrings;
  SkillStringsArray[SKILL_MAGIC] := mageStrings;
  SkillStringsArray[SKILL_PRAYER] := prayerStrings;
  SkillStringsArray[SKILL_RANGE] := rangedStrings;
  SkillStringsArray[SKILL_CONSTRUCTION] := constructionStrings;
  SkillStringsArray[SKILL_RUNECRAFTING] := runecraftingStrings;
  SkillStringsArray[SKILL_CRAFTING] := craftingStrings;
  SkillStringsArray[SKILL_SMITHING] := smithingStrings;
  SkillStringsArray[SKILL_AGILITY] := agilityStrings;
  SkillStringsArray[SKILL_THIEVING] := thievingStrings;

  commonHelloStrings := [];
  for l:=0 to high(questionStrings) do
    for i:=0 to high(whatStrings) do begin
      setLength(commonHelloStrings, length(commonHelloStrings)+1);
      commonHelloStrings[high(commonHelloStrings)] := whatStrings[i]+' up'+questionStrings[l];
    end;
  for l:=0 to high(questionStrings) do
    for i:=0 to high(hiStrings) do begin
      setLength(commonHelloStrings, length(commonHelloStrings)+1);
      commonHelloStrings[high(commonHelloStrings)] := hiStrings[i]+questionStrings[l];
    end;
  for l:=0 to high(questionStrings) do
    for i:=0 to high(helloStrings) do begin
      setLength(commonHelloStrings, length(commonHelloStrings)+1);
      commonHelloStrings[high(commonHelloStrings)] := helloStrings[i]+questionStrings[l];
    end;
  for l:=0 to high(questionStrings) do
    for i:=0 to high(heyStrings) do begin
      setLength(commonHelloStrings, length(commonHelloStrings)+1);
      commonHelloStrings[high(commonHelloStrings)] := heyStrings[i]+questionStrings[l];
    end;
  for i:=0 to high(questionStrings) do begin
    setLength(commonHelloStrings, length(commonHelloStrings)+1);
    commonHelloStrings[high(commonHelloStrings)] := 'sup'+questionStrings[i];
  end;
end;

procedure setupINeedFuncs;
begin
  doFUpdate;

  setupAutoChat;

  breaks := 0;

  randomsStrings := ['molly', 'niles', 'miles', 'giles', 'sandwich lady',
  'drunken dwarf', 'genie', 'highwayman', 'dr jekyll', 'cap''n hand', 'security guard',
  'rick turpentine', 'mysterious old man', 'frog', 'null', 'mime', 'sergeant damien', 'freaky forester',
  'postie pete', 'tilt', 'flippa', 'leo', 'pillory guard', 'evil bob', 'dunce', 'capt'' arnav', 'bee keeper'];

  rewardIDs := [2528];

  closeAllTimer.Restart;
  checkForLevelTimer.Restart;
  dismissAllTimer.Restart;
  lookForChatTimer.Restart;
  {$IFDEF iDEBUG}
    tim3.Restart;
  {$ENDIF}
  updateAllTimer.Restart;
  updateScreenTimer.Restart;
end;
