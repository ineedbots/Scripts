program newerLapeCutter;
{$DEFINE SMART}
{$DEFINE CHOPPER}
{$i Reflection/Reflection.Simba}
{$i [Reflection] ineedbot's functions.simba}

const Version = 5.03;

      PicturePage = 'http://pastebin.com/raw/zF7qBL4J';
      ScriptPage = 'https://raw.githubusercontent.com/ineedbots/Scripts/master/%5BReflection%5D%20ineedbot''s%20AIO%20Woodcutter.simba';

//Feel free to use code, GIVE CREDIT WHERE DUE! -ineedbot

type TreeObject = record
     Tile : TPoint;
     AliveIDs, DeadIDs : TIntegerArray;
     Name : String;
     Offset : array[0..2] of integer;
     TileOffset : array[0..1] of integer;
     Timer : TReflectTimer;
     Index, Plane : Integer;
     Options : TStringArray;
end;
TreeObjectArray = array of TreeObject;

function TreeObject.isAlive:boolean;
var TempObject : TReflectObject;
begin
  TempObject.GetAt(ObjGame, self.Tile);
  if not Reflect.Smart.IsNull(TempObject.Reference) and inIntArray(self.AliveIDs, TempObject.GetId) then
    exit(true);
end;

function TreeObject.isDead:boolean;
var TempObject : TReflectObject;
begin
  TempObject.GetAt(ObjGame, self.Tile);
  if not Reflect.Smart.IsNull(TempObject.Reference) and inIntArray(self.DeadIDs, TempObject.GetId) then
    exit(true);
end;

function TreeObjectArray.getAliveTrees:TreeObjectArray;
var i : integer;
begin
  for i:=0 to high(self) do
    if self[i].isAlive then begin
      setLength(result, length(result)+1);
      result[high(result)] := self[i];
    end;
end;

function TreeObjectArray.getDeadTrees:TreeObjectArray;
var i : integer;
begin
  for i:=0 to high(self) do
    if self[i].isDead then begin
      setLength(result, length(result)+1);
      result[high(result)] := self[i];
    end;
end;

function TreeObject.isValid:boolean;
begin
  if Self.Tile.x <> 0 then
    exit(true);
end;

function TreeObjectArray.getClosestTree:TreeObject;
var i : integer;
begin
  for i:=0 to high(self) do
    if not result.isValid then
      result := self[i]
    else
      if (Reflect.Tiles.DistanceFromTile(self[i].tile) < Reflect.Tiles.DistanceFromTile(result.tile)) then
        result := self[i];
end;

function TreeObjectArray.getClosestTreeTime:TreeObject;
var i:integer;
begin
  for i:=0 to high(self) do
    if (self[i].Timer.StartTime <> -1) then
      if not result.isValid then
        result := self[i]
      else if (self[i].Timer.Elapsedtime > result.Timer.Elapsedtime) then
          result := self[i];
end;

function TreeObjectArray.getTreeIndex(ind:integer):TreeObject;
var i : integer;
begin
  for i:=0 to high(self) do
    if self[i].Index = ind then
      exit(self[i]);
end;

function TreeObjectArray.getNextTree(PTree:TreeObject):TreeObject;
var CurrentTree : TreeObject;
begin
  CurrentTree := Self.getClosestTree;
  result := CurrentTree;

  if (high(self) < 1) or not PTree.isValid then
    exit;

  if(CurrentTree.Index < PTree.Index) or (CurrentTree.Index = high(self)) then begin
    result := Self.GetTreeIndex(CurrentTree.Index-1);
  end else begin
    result := Self.GetTreeIndex(CurrentTree.Index+1);
  end;
end;

type BankLocation = record
     Tile : TPoint;
     Name : String;
     Plane : integer;
     Offset : array[0..2] of integer;
     TileOffset : array[0..1] of integer;
     Options : TStringArray;
end;

type BankNPC = record
     Locations : TPointArray;
     Options, Names : TStringArray;
     IDs : TIntegerArray;
     Plane : Integer;
     Offset : array[0..2] of integer;
end;

type FireLane = record
     Plane, Length : Integer;
     Tile : TPoint;
end;

type workedLog = record
     chopped, ID, price : integer;
end;

type Location = record
     Name : string;
     RunDirections : TStringArray;
     ID, distanceCheck : integer;
     TreeLocations : TPointArray;
     canFire, canFletch, canBank, isDynamic, isSell, isFar, isPower : boolean;
     FletchPoint : TPoint;
     FireLanes : array of FireLane;
     PathToBank, PathToTree : TPointArray;
     customIDs : array of TIntegerArray;
     customTPAs : array of TPointArray;
     BankLocations : array of BankLocation;
     TreeObjects : TreeObjectArray;
     DoorObjects : array of TReflectDoor;
     BankNPCs : array of BankNPC;
     Logs : array of workedLog;
end;

var
  graphicOpti: TMufasaBitmap;

  statsServer: TStats;

  daLocation: Location;

  PreviousTree: TreeObject;

  statsTimer,LastXPCheck,gItemTim: TReflectTimer;

  playNum,job,RunAmount,AmountAmount,cpuLoadOften,cpuLoadWait,
  updateScreenOften,ItemCheckDistance,statsProfit,
  statsTime,statsFireXP,statsFletchXP,StartFletchXP,
  statsWoodXP,nullINT,gItemOften,Nests,StartWoodLevel,
  startWoodXp,LastXPXP,StartFireXP: integer;

  WorldList,TradingSticksIDs,GreeGreeIDs,ChopAnimationIDs,KnifeIDs,TinderIDs,
  FireIDs,FireAnimIDs,AxeIDs,CoinsIDs,ShaftIDs,FletchAnimationIDs,
  NestIDs: TIntegerArray;

  started,loading,saving,MouseKeys,DisableBank,UseSpec,useBreaks,
  dropOnly,useStats: boolean;

  sdrop,sbrin,sbreak,sbin,sbrfor,sbfor,swait,schat,sname,spass,spin,samount,
  sloc,stype,santi,srun,sworld,sspec,sbank,smouse,ssound,schatt,swaitt,swaito,
  supdatet,sscreent,slchatt,slevelt,scloset,sdismisst,sitemd,scriptstatus,sitemt: string;

  TFormMain,TFormBreak,TFormExtra: TForm;

  TLabelPin,TLabelWorld,TLabelRun,TLabelAnti,TLabelAmount,TLabelPlayNum,
  TLabelbIn,TLabelbrIn,TLabelbFor,TLabelItemDis,TLabelLookForChatTime,
  TLabelCloseTime,TLabelLevelUpTime,TLabelUpdateTime,TLabelDismissTime,
  TLabelWaitTime,TLabelWaitOften,TLabelbrFor,TLabelScreenTime,TLabelSound,
  TLabelChatTime,TLabelItemTime: TLabel;

  TEditUser,TEditPass,TEditPin,TEditWorld,TEditRun,TEditAnti,TEditAmount,
  TEditPlayNum,TEditbIn,TEditbrIn,TEditItemDis,TEditLookForChatTime,
  TEditCloseTime,TEditLevelUpTime,TEditUpdateTime,TEditDismissTime,
  TEditWaitTime,TEditWaitOften,TEditbFor,TEditbrFor,TEditScreenTime,
  TEditSound,TEditChatTime,TEditItemTime: TEdit;

  TButtonPlay,TButtonLoad,TButtonSave,TButtonBreak,TButtonExtra: TButton;

  TCheckBoxBreak,TCheckBoxTalk,TCheckBoxWait,TCheckBoxMouse,TCheckBoxSpec,
  TCheckBoxBank,TCheckBoxDropOnly: TCheckBox;

  TComboBoxLoc,TComboBoxType: TComboBox;

  TMainImage: TImage;

  TMainBMP: TBitmap;

procedure doUpdate;     //thanks shuttleu
var NetworkVersion : extended;
    FileNew, script : string;
    ThisFile : integer;
begin
  if DirectoryExists(ScriptPath + '.git\') then
    exit;
  script := Reflect.Misc.GetPage(scriptPage);
  try
    NetworkVersion := strToFloat(between('Version = ', ';', script));
  except
    begin
      daLogger.Error('Failed get update version.', []);
      exit;
    end;
  end;
  daLogger.Status('ineedbot''s Woodcutter:  Local Version: '+FloatToStr(Version)+'  Network Version: '+FloatToStr(NetworkVersion), []);
  if(Version < NetworkVersion) then begin
    FileNew := ScriptPath + '[Reflection] ineedbot''s AIO Woodcutter.simba';
    ThisFile := Rewritefile(FileNew, true);
    try
        WriteFileString(ThisFile, script);
      except
        begin
          daLogger.Error('Failed writing to: '+FileNew, []);
          CloseFile(ThisFile);
          exit;
        end;
      end;
      CloseFile(ThisFile);
      daLogger.Status('Successfully downloaded new script to '+FileNew+'. Please reopen this script.', []);
      TerminateScript;
  end else begin
    if(Version = NetworkVersion)then begin
    end else begin
    end;
  end;
end;

procedure YourClickProcedure(Sender: TObject);
{$IFNDEF CODEINSIGHT}
native;
{$ENDIF}
begin
  case sender of
    TButtonBreak:begin
      TFormBreak.ShowModal();
    end;
    TButtonExtra:begin
      TFormExtra.ShowModal();
    end;
    TButtonPlay:begin
      started := true;
      TFormMain.Close;
    end;
    TButtonLoad:begin
      loading := true;
      TFormMain.Close;
    end;
    TButtonSave:begin
      schat := tostr(TCheckBoxTalk.getstate);
      swait := tostr(TCheckBoxWait.getstate);
      sname := TEditUser.Gettext;
      spass := TEditPass.gettext;
      spin := TEditPin.gettext;
      samount := TEditAmount.gettext;
      stype := tostr(TComboBoxType.getitemindex);
      sloc := tostr(TComboBoxLoc.getitemindex);
      santi := TEditAnti.gettext;
      srun := TEditRun.gettext;
      sworld := TEditWorld.gettext;
      sspec := tostr(TCheckBoxSpec.getstate);
      sbank := tostr(TCheckBoxBank.getstate);
      smouse := tostr(TCheckBoxMouse.getstate);
      sbreak := tostr(TCheckBoxBreak.getstate);
      sbfor := TEditbFor.gettext;
      sbrfor := TEditbrFor.gettext;
      sbin := TEditbin.gettext;
      sbrin := TEditbrin.gettext;
      ssound := TEditSound.getText;
      sdismisst := TEditDismissTime.getText;
      slchatt := TEditLookForChatTime.getText;
      schatt := TEditChatTime.getText;
      supdatet := TEditUpdateTime.getText;
      sscreent := TEditScreenTime.getText;
      slevelt := TEditLevelUpTime.getTExt;
      swaitt := TEditWaitTime.getText;
      swaito := TEditWaitOften.getText;
      scloset := TEditCloseTime.getTExt;
      sitemd := TEditItemDis.getText;
      sdrop := tostr(TCheckBoxDropOnly.getstate);
      sitemt := TEditItemTime.getText;
      saving := true;
      TFormMain.Close;
     end;
  end;
end;

procedure _OnChange2;
var i : integer;
begin
  TComboBoxType.Clear;
  TComboBoxType.setText('Type of wood:');
  i := -1;
  case TComboBoxLoc.getItemIndex of
    (i:=i+1):begin   //lumbridge
      TComboBoxType.AddItem('Oaks (sell)', nil);
      TComboBoxType.AddItem('Willows (sell)', nil);
      TComboBoxType.AddItem('West Willows', nil);
      TComboBoxType.AddItem('West Willows(2)', nil);
      TComboBoxType.AddItem('North Willows', nil);
      TComboBoxType.AddItem('Yews', nil);
      TComboBoxType.AddItem('Yews (sell)', nil);
      TComboBoxType.AddItem('Progressive Chopping', nil);
    end;
    (i:=i+1):begin      //draynor
      TComboBoxType.AddItem('Oaks', nil);
      TComboBoxType.AddItem('Willows', nil);
      TComboBoxType.AddItem('Yews', nil);
    end;
    (i:=i+1):begin   //Rimmington
      TComboBoxType.AddItem('Willows (p.s.)', nil);
      TComboBoxType.AddItem('Yews (p.s.)', nil);
      TComboBoxType.AddItem('Willows (sell)', nil);
      TComboBoxType.AddItem('Yews', nil);
      TComboBoxType.AddItem('Yews (sell)', nil);
    end;
    (i:=i+1):begin      //Falador
      TComboBoxType.AddItem('Oaks', nil);
      TComboBoxType.AddItem('Yews', nil);
    end;
    (i:=i+1):begin   //edgeville
      TComboBoxType.AddItem('Yews', nil);
    end;
    (i:=i+1):begin     //varrock
      TComboBoxType.AddItem('Oaks (west)', nil);
      TComboBoxType.AddItem('Yews (palace)', nil);
      TComboBoxType.AddItem('Oaks (east)', nil);
      TComboBoxType.AddItem('Yews (pray)', nil);
      TComboBoxType.AddItem('Yews (east)', nil);
    end;
    (i:=i+1):begin   //seers
      TComboBoxType.AddItem('Oaks', nil);
      TComboBoxType.AddItem('Willows', nil);
      TComboBoxType.AddItem('Maples', nil);
      TComboBoxType.AddItem('Yews', nil);
      TComboBoxType.AddItem('Magics', nil);
      TComboBoxType.AddItem('Magics (2)', nil);
    end;
    (i:=i+1):begin   //catherby
      TComboBoxType.AddItem('Willows', nil);
      TComboBoxType.AddItem('Yews', nil);
    end;
    (i:=i+1):begin   //tree gnome village
      TComboBoxType.AddItem('Yews', nil);
      TComboBoxType.AddItem('Yews (2)', nil);
    end;
    (i:=i+1):begin     //barb
      TComboBoxType.AddItem('Willows', nil);
    end;
    (i:=i+1):begin     //deul
      TComboBoxType.AddItem('Magics', nil);
    end;
    (i:=i+1):begin     //ape
      TComboBoxType.AddItem('Teaks', nil);
    end;
    (i:=i+1):begin     //castle
      TComboBoxType.AddItem('Teaks', nil);
    end;
    (i:=i+1):begin     //two bai
      TComboBoxType.AddItem('Teaks', nil);
      TComboBoxType.AddItem('Teaks(2)', nil);
      TComboBoxType.AddItem('Mahogany', nil);
    end;
    (i:=i+1):begin     //powerchop
      TComboBoxType.AddItem('Normal Trees', nil);
      TComboBoxType.AddItem('Oaks', nil);
      TComboBoxType.AddItem('Willows', nil);
    end;
    (i:=i+1):begin     //wc guild
      TComboBoxType.AddItem('Yews', nil);
      TComboBoxType.AddItem('Magics', nil);
      TComboBoxType.AddItem('Redwood', nil);
      TComboBoxType.AddItem('Redwood(2)', nil);
      TComboBoxType.AddItem('Redwood(3)', nil);
      TComboBoxType.AddItem('Redwood(4)', nil);
    end;
  end;
end;

procedure breakCheck;
begin
  TButtonBreak.setEnabled(toStr(TCheckBoxBreak.getState) = 'cbChecked');
end;

procedure OnChange(Sender: TObject);
{$IFNDEF CODEINSIGHT}
native;
{$ENDIF}
begin
  _OnChange2;
end;

procedure brakeHandle(Sender: TObject);
{$IFNDEF CODEINSIGHT}
native;
{$ENDIF}
begin
  breakCheck;
end;

procedure OnlyPostiveNumbers(Sender: TObject; var Key:Char);
{$IFNDEF CODEINSIGHT}
native;
{$ENDIF}
begin
  case toStr(key) of
    #8, '0'..'9':begin
    end;
    else begin
      Key := #0;
    end;
  end;
end;

procedure OnlyNumbers(Sender: TObject; var Key: Char);
{$IFNDEF CODEINSIGHT}
native;
{$ENDIF}
var _sender : TEdit;
begin
  _sender := sender;
  case toStr(key) of
    #8, '0'..'9', '-':begin
      if(toStr(key) = '-')then begin
        if(_sender.getSelStart <> 0)then begin
          Key := #0;
        end;
      end;
    end;
    else begin
      Key := #0;
    end;
  end;
end;

procedure NoKeys(Sender: TObject; var Key: Char);
{$IFNDEF CODEINSIGHT}
native;
{$ENDIF}
begin
  Key := #0;
end;

procedure OnlyPostiveNumbers2(Sender: TObject; var Key:Char);
{$IFNDEF CODEINSIGHT}
native;
{$ENDIF}
begin
  case toStr(key) of
    #8, ',', '0'..'9':begin
    end;
    else begin
      Key := #0;
    end;
  end;
end;

procedure InitForm;
var
  tempFont : TFont;
begin
  tempFont.Init;
  tempFont.setColor(0);
//TFormMain\\
 TFormMain.Init(nil);
  with TFormMain do
    begin
      SetCaption('ineedbot''s AIO Woodcutter');
      setBorderStyle(bsSingle);
      SetBounds(0,0,374,208);
      SetPosition(poScreenCenter);
  end;
  TMainImage.init(TFormMain);
  with TMainImage do
    begin
      setParent(TFormMain);
      SetBounds(0,0,374,208);
      setPicture(TMainBMP);
  end;
//TLabelPin\\
 TLabelPin.Init(TFormMain);
  with TLabelPin do
    begin
      SetParent(TFormMain);
      SetCaption('Pin:');
      SetBounds(2,57,53,16);
      setFont(tempFont);
  end;
//TLabelWorld\\
 TLabelWorld.Init(TFormMain);
  with TLabelWorld do
    begin
      SetParent(TFormMain);
      SetCaption('World:');
      SetBounds(2,82,68,16);
      setFont(tempFont);
  end;
//TLabelRun\\
 TLabelRun.Init(TFormMain);
  with TLabelRun do
    begin
      SetParent(TFormMain);
      SetCaption('When to run:');
      SetBounds(2,107,57,16);
      setFont(tempFont);
  end;
//TLabelAnti\\
 TLabelAnti.Init(TFormMain);
  with TLabelAnti do
    begin
      SetParent(TFormMain);
      SetCaption('Antiban often:');
      SetBounds(2,132,58,16);
      setFont(tempFont);
  end;
//TLabelAmount\\
 TLabelAmount.Init(TFormMain);
  with TLabelAmount do
    begin
      SetParent(TFormMain);
      SetCaption('Amount to cut:');
      SetBounds(2,157,80,16);
      setFont(tempFont);
  end;
//TLabelPlayNum\\
 TLabelPlayNum.Init(TFormMain);
  with TLabelPlayNum do
    begin
      SetParent(TFormMain);
      SetCaption('Player number:');
      SetBounds(116,182,85,16);
      setFont(tempFont);
  end;
//TEditUser\\
 TEditUser.Init(TFormMain);
  with TEditUser do
    begin
      SetParent(TFormMain);
      SetText('Username or email');
      SetBounds(2,27,219,23);
      setFont(tempFont);
  end;
//TEditPass\\
 TEditPass.Init(TFormMain);
  with TEditPass do
    begin
      SetParent(TFormMain);
      SetText('Password');
      SetBounds(225,27,147,23);
      setFont(tempFont);
      setPasswordChar('*');
      setMaxLength(20);
  end;
//TEditPin\\
 TEditPin.Init(TFormMain);
  with TEditPin do
    begin
      SetParent(TFormMain);
      SetText('');
      SetBounds(26,52,36,23);
      setFont(tempFont);
      setPasswordChar('*');
      setMaxLength(4);
      setONKEYPRESS(OnlyPostiveNumbers);
  end;
//TEditWorld\\
 TEditWorld.Init(TFormMain);
  with TEditWorld do
    begin
      SetParent(TFormMain);
      SetText('');
      SetBounds(40,77,80,23);
      setFont(tempFont);
      setONKEYPRESS(OnlyPostiveNumbers2);
  end;
//TEditRun\\
 TEditRun.Init(TFormMain);
  with TEditRun do
    begin
      SetParent(TFormMain);
      SetText('75');
      SetBounds(75,102,30,23);
      setFont(tempFont);
      setMaxLength(3);
      setONKEYPRESS(OnlyPostiveNumbers);
  end;
//TEditAnti\\
 TEditAnti.Init(TFormMain);
  with TEditAnti do
    begin
      SetParent(TFormMain);
      SetText('1000');
      SetBounds(82,127,48,23);
      setFont(tempFont);
      setMaxLength(6);
      setONKEYPRESS(OnlyPostiveNumbers);
  end;
//TEditAmount\\
 TEditAmount.Init(TFormMain);
  with TEditAmount do
    begin
      SetParent(TFormMain);
      SetText('-1');
      SetBounds(88,152,48,23);
      setFont(tempFont);
      setMaxLength(6);
      setONKEYPRESS(OnlyPostiveNumbers);
  end;
//TEditPlayNum\\
 TEditPlayNum.Init(TFormMain);
  with TEditPlayNum do
    begin
      SetParent(TFormMain);
      SetText('0');
      SetBounds(200,180,20,23);
      setFont(tempFont);
      setMaxLength(2);
      setONKEYPRESS(OnlyPostiveNumbers);
  end;
//TButtonPlay\\
 TButtonPlay.Init(TFormMain);
  with TButtonPlay do
    begin
      SetParent(TFormMain);
      SetCaption('Play');
      SetBounds(296,180,75,25);
      setFont(tempFont);
      setOnClick(YourClickProcedure);
  end;
//TButtonLoad\\
 TButtonLoad.Init(TFormMain);
  with TButtonLoad do
    begin
      SetParent(TFormMain);
      SetCaption('Load');
      SetBounds(2,180,50,25);
      setFont(tempFont);
      setOnClick(YourClickProcedure);
  end;
//TButtonSave\\
 TButtonSave.Init(TFormMain);
  with TButtonSave do
    begin
      SetParent(TFormMain);
      SetCaption('Save');
      SetBounds(54,180,50,25);
      setFont(tempFont);
      setOnClick(YourClickProcedure);
  end;
//TButtonBreak\\
 TButtonBreak.Init(TFormMain);
  with TButtonBreak do
    begin
      SetParent(TFormMain);
      SetCaption('Break handler');
      SetBounds(160,152,85,25);
      setFont(tempFont);
      setOnClick(YourClickProcedure);
      setEnabled(false);
  end;
//TButtonExtra\\
 TButtonExtra.Init(TFormMain);
  with TButtonExtra do
    begin
      SetParent(TFormMain);
      SetCaption('Extras');
      SetBounds(304,152,60,25);
      setFont(tempFont);
      setOnClick(YourClickProcedure);
  end;
//TCheckBoxBreak\\
 TCheckBoxBreak.Init(TFormMain);
  with TCheckBoxBreak do
    begin
      SetParent(TFormMain);
      SetCaption('');
      SetBounds(140,154,23,19);
      setState(0);
      setOnChange(brakeHandle);
      setFont(tempFont);
  end;
//TCheckBoxTalk\\
 TCheckBoxTalk.Init(TFormMain);
  with TCheckBoxTalk do
    begin
      SetParent(TFormMain);
      SetCaption('Use auto responder?');
      SetBounds(140,52,101,19);
      setState(0);
      setFont(tempFont);
  end;
//TCheckBoxWait\\
 TCheckBoxWait.Init(TFormMain);
  with TCheckBoxWait do
    begin
      SetParent(TFormMain);
      SetCaption('Force waits after actions?');
      SetBounds(140,72,103,19);
      setState(0);
      setFont(tempFont);
  end;
//TCheckBoxMouse\\
 TCheckBoxMouse.Init(TFormMain);
  with TCheckBoxMouse do
    begin
      SetParent(TFormMain);
      SetCaption('Use mouse keys?');
      SetBounds(140,92,115,19);
      setState(0);
      setFont(tempFont);
  end;
//TCheckBoxSpec\\
 TCheckBoxSpec.Init(TFormMain);
  with TCheckBoxSpec do
    begin
      SetParent(TFormMain);
      SetCaption('Use DAxe Spec?');
      SetBounds(140,112,107,19);
      setState(0);
      setFont(tempFont);
  end;
//TCheckBoxBank\\
 TCheckBoxBank.Init(TFormMain);
  with TCheckBoxBank do
    begin
      SetParent(TFormMain);
      SetCaption('Force disable banking?');
      SetBounds(140,132,105,19);
      setState(0);
      setFont(tempFont);
  end;
//TComboBoxLoc\\
 TComboBoxLoc.Init(TFormMain);
  with TComboBoxLoc do
    begin
      SetParent(TFormMain);
      SetBounds(2,2,219,23);
      setCaption('Location:');
      //add your items here
      AddItem('Lumbridge', nil);
      AddItem('Draynor', nil);
      AddItem('Rimmington', nil);
      AddItem('Falador', nil);
      AddItem('Edgeville', nil);
      AddItem('Varrock', nil);
      AddItem('Seers', nil);
      AddItem('Catherby', nil);
      AddItem('Gnome Stronghold', nil);
      AddItem('Barb. Assault', nil);
      AddItem('Duel Arena', nil);
      AddItem('Ape Atoll', nil);
      AddItem('Castle Wars', nil);
      AddItem('Tai Bwo Wannai', nil);
      AddItem('Powerchop', nil);
      AddItem('Woodcutting Guild', nil);
      //End items
      setFont(tempFont);
      setONKEYPRESS(NoKeys);
      setOnExit(OnChange);
  end;
//TComboBoxType\\
 TComboBoxType.Init(TFormMain);
  with TComboBoxType do
    begin
      SetParent(TFormMain);
      SetBounds(225,2,147,23);
      setCaption('Type of wood:');
      setFont(tempFont);
      setONKEYPRESS(NoKeys);
  end;

  TFormBreak.init(nil);
  with TFormBreak do
    begin
      SetCaption('Break Handler');
      setBorderStyle(bsSingle);
      SetBounds(0,0,255,120);
      SetPosition(poScreenCenter);
  end;
  TLabelbIn.init(TFormBreak);
  with TLabelbIn do
    begin
      setParent(TFormBreak);
      setCaption('Break after/every/within:');
      SetBounds(5,5,68,16);
      setFont(tempFont);
  end;
  TLabelbrIn.init(TFormBreak);
  with TLabelbrIn do
    begin
      setParent(TFormBreak);
      setCaption('Random:');
      SetBounds(5,30,68,16);
      setFont(tempFont);
  end;
  TLabelbFor.init(TFormBreak);
  with TLabelbFor do
    begin
      setParent(TFormBreak);
      setCaption('Break for:');
      SetBounds(5,65,68,16);
      setFont(tempFont);
  end;
  TLabelbrFor.init(TFormBreak);
  with TLabelbrFor do
    begin
      setParent(TFormBreak);
      setCaption('Random:');
      SetBounds(5,90,68,16);
      setFont(tempFont);
  end;
  TEditbIn.init(TFormBreak);
  with TEditbIn do
    begin
      setParent(TFormBreak);
      setText('90');
      SetBounds(150,2,100,23);
      setONKEYPRESS(OnlyPostiveNumbers);
      setMaxLength(9);
      setFont(tempFont);
  end;
  TEditbrIn.init(TFormBreak);
  with TEditbrIn do
    begin
      setParent(TFormBreak);
      setText('30');
      SetBounds(150,30,100,23);
      setONKEYPRESS(OnlyPostiveNumbers);
      setMaxLength(9);
      setFont(tempFont);
  end;
  TEditbFor.init(TFormBreak);
  with TEditbFor do
    begin
      setParent(TFormBreak);
      setText('10');
      SetBounds(150,67,100,23);
      setONKEYPRESS(OnlyPostiveNumbers);
      setMaxLength(9);
      setFont(tempFont);
  end;
  TEditbrFor.init(TFormBreak);
  with TEditbrFor do
    begin
      setParent(TFormBreak);
      setText('5');
      SetBounds(150,92,100,23);
      setONKEYPRESS(OnlyPostiveNumbers);
      setMaxLength(9);
      setFont(tempFont);
  end;

  TFormExtra.init(nil);
  with TFormExtra do
    begin
      setCaption('Extras');
      setBorderStyle(bsSingle);
      SetBounds(0,0,255,330);
      SetPosition(poScreenCenter);
  end;
  TLabelSound.init(TFormExtra);
  with TLabelSound do
    begin
      setParent(TFormExtra);
      setCaption('Sound:');
      SetBounds(5,5,68,16);
      setFont(tempFont);
  end;
  TEditSound.init(TFormExtra);
  with TEditSound do
    begin
      setParent(TFormExtra);
      setText('C:\Windows\Media\Windows Notify.wav');
      SetBounds(150,5,100,23);
      setFont(tempFont);
  end;
  TLabelChatTime.init(TFormExtra);
  with TLabelChatTime do
    begin
      setParent(TFormExtra);
      setCaption('Chat time often:');
      SetBounds(5,30,68,16);
      setFont(tempFont);
  end;
  TEditChatTime.init(TFormExtra);
  with TEditChatTime do
    begin
      setParent(TFormExtra);
      setText('200000');
      SetBounds(150,30,100,23);
      setONKEYPRESS(OnlyNumbers);
      setMaxLength(9);
      setFont(tempFont);
  end;
  TLabelScreenTime.init(TFormExtra);
  with TLabelScreenTime do
    begin
      setParent(TFormExtra);
      setCaption('Screen time often:');
      SetBounds(5,55,68,16);
      setFont(tempFont);
  end;
  TEditScreenTime.init(TFormExtra);
  with TEditScreenTime do
    begin
      setParent(TFormExtra);
      setText('1000');
      SetBounds(150,55,100,23);
      setONKEYPRESS(OnlyNumbers);
      setMaxLength(9);
      setFont(tempFont);
  end;
  TLabelWaitTime.init(TFormExtra);
  with TLabelWaitTime do
    begin
      setParent(TFormExtra);
      setCaption('Wait time:');
      SetBounds(5,80,68,16);
      setFont(tempFont);
  end;
  TEditWaitTime.init(TFormExtra);
  with TEditWaitTime do
    begin
      setParent(TFormExtra);
      setText('-1');
      SetBounds(150,80,100,23);
      setONKEYPRESS(OnlyNumbers);
      setMaxLength(9);
      setFont(tempFont);
  end;
  TLabelWaitOften.init(TFormExtra);
  with TLabelWaitOften do
    begin
      setParent(TFormExtra);
      setCaption('Wait often:');
      SetBounds(5,105,68,16);
      setFont(tempFont);
  end;
  TEditWaitOften.init(TFormExtra);
  with TEditWaitOften do
    begin
      setParent(TFormExtra);
      setText('250');
      SetBounds(150,105,100,23);
      setONKEYPRESS(OnlyPostiveNumbers);
      setMaxLength(9);
      setFont(tempFont);
  end;
  TLabelDismissTime.init(TFormExtra);
  with TLabelDismissTime do
    begin
      setParent(TFormExtra);
      setCaption('Dismiss time:');
      SetBounds(5,130,68,16);
      setFont(tempFont);
  end;
  TEditDismissTime.init(TFormExtra);
  with TEditDismissTime do
    begin
      setParent(TFormExtra);
      setText('10000');
      SetBounds(150,130,100,23);
      setONKEYPRESS(OnlyNumbers);
      setMaxLength(9);
      setFont(tempFont);
  end;
  TLabelUpdateTime.init(TFormExtra);
  with TLabelUpdateTime do
    begin
      setParent(TFormExtra);
      setCaption('Update time:');
      SetBounds(5,155,68,16);
      setFont(tempFont);
  end;
  TEditUpdateTime.init(TFormExtra);
  with TEditUpdateTime do
    begin
      setParent(TFormExtra);
      setText('45000');
      SetBounds(150,155,100,23);
      setONKEYPRESS(OnlyNumbers);
      setMaxLength(9);
      setFont(tempFont);
  end;
  TLabelLevelUpTime.init(TFormExtra);
  with TLabelLevelUpTime do
    begin
      setParent(TFormExtra);
      setCaption('Level up time:');
      SetBounds(5,180,68,16);
      setFont(tempFont);
  end;
  TEditLevelUpTime.init(TFormExtra);
  with TEditLevelUpTime do
    begin
      setParent(TFormExtra);
      setText('2500');
      SetBounds(150,180,100,23);
      setONKEYPRESS(OnlyNumbers);
      setMaxLength(9);
      setFont(tempFont);
  end;
  TLabelCloseTime.init(TFormExtra);
  with TLabelCloseTime do
    begin
      setParent(TFormExtra);
      setCaption('Close stuff time:');
      SetBounds(5,205,68,16);
      setFont(tempFont);
  end;
  TEditCloseTime.init(TFormExtra);
  with TEditCloseTime do
    begin
      setParent(TFormExtra);
      setText('10000');
      SetBounds(150,205,100,23);
      setONKEYPRESS(OnlyNumbers);
      setMaxLength(9);
      setFont(tempFont);
  end;
  TLabelLookForChatTime.init(TFormExtra);
  with TLabelLookForChatTime do
    begin
      setParent(TFormExtra);
      setCaption('Look for chat time:');
      SetBounds(5,230,68,16);
      setFont(tempFont);
  end;
  TEditLookForChatTime.init(TFormExtra);
  with TEditLookForChatTime do
    begin
      setParent(TFormExtra);
      setText('2000');
      SetBounds(150,230,100,23);
      setONKEYPRESS(OnlyNumbers);
      setMaxLength(9);
      setFont(tempFont);
  end;
  TLabelItemDis.init(TFormExtra);
  with TLabelItemDis do
    begin
      setParent(TFormExtra);
      setCaption('Nest check distance:');
      SetBounds(5,255,68,16);
      setFont(tempFont);
  end;
  TEditItemDis.init(TFormExtra);
  with TEditItemDis do
    begin
      setParent(TFormExtra);
      setText('20');
      SetBounds(150,255,100,23);
      setONKEYPRESS(OnlyPostiveNumbers);
      setMaxLength(3);
      setFont(tempFont);
  end;
  TCheckBoxDropOnly.init(TFormExtra);
  with TCheckBoxDropOnly do
    begin
      setFont(tempFont);
      setParent(TFormExtra);
      setCaption('Drop only?');
      setState(0);
      SetBounds(5,280,68,16);
  end;
  TLabelItemTime.init(TFormExtra);
  with TLabelItemTime do
    begin
      setParent(TFormExtra);
      setCaption('Look for nest time:');
      SetBounds(5,305,68,16);
      setFont(tempFont);
  end;
  TEditItemTime.init(TFormExtra);
  with TEditItemTime do
    begin
      setParent(TFormExtra);
      setText('5000');
      SetBounds(150,305,100,23);
      setONKEYPRESS(OnlyNumbers);
      setMaxLength(9);
  end;
  tempFont.Free;
end;

procedure ShowFormModal;
{$IFNDEF CODEINSIGHT}
native;
{$ENDIF}
var
  i, h : integer;
  strings : TStringArray;
begin
  InitForm;

  if loading or saving then begin
    saving := false;
    loading := false;
    TEditUser.setText(sname);
    TEditPass.setText(spass);
    TEditPin.setText(spin);
    TEditWorld.setText(sworld);

    if (Length(santi) > 0) then
      TEditAnti.setText(santi)
    else
      TEditAnti.setText('0');

    if (Length(srun) > 0) then
      TEditRun.setText(srun)
    else
      TEditRun.setText('0');

    if (Length(samount) > 0) then
      TEditAmount.setText(samount)
    else
      TEditAmount.setText('0');

    if (Length(sloc) > 0) then
      TComboBoxLoc.setItemIndex(StrToInt(sloc))
    else
      TComboBoxLoc.setItemIndex(0);
    _OnChange2;

    if (Length(stype) > 0) then
      TComboBoxType.setItemIndex(StrToInt(stype))
    else
      TComboBoxType.setItemIndex(0);

    if(sbank = 'cbUnchecked')then
      TCheckBoxBank.setState(0)
    else
      TCheckBoxBank.setState(1);

    if(sspec = 'cbUnchecked')then
      TCheckBoxSpec.setState(0)
    else
      TCheckBoxSpec.setState(1);

    if(schat = 'cbUnchecked')then
      TCheckBoxTalk.setState(0)
    else
      TCheckBoxTalk.setState(1);

    if(swait = 'cbUnchecked')then
      TCheckBoxWait.setState(0)
    else
      TCheckBoxWait.setState(1);

    if(smouse = 'cbUnchecked')then
      TCheckBoxMouse.setState(0)
    else
      TCheckBoxMouse.setState(1);

    if(sbreak = 'cbUnchecked')then
      TCheckBoxBreak.setState(0)
    else
      TCheckBoxBreak.setState(1);
    breakCheck;

    TEditbin.setText(sbin);
    TEditbrin.setText(sbrin);
    TEditbfor.setText(sbfor);
    TEditbrfor.setText(sbrfor);

    if(sdrop = 'cbUnchecked')then
      TCheckBoxDropOnly.setState(0)
    else
      TCheckBoxDropOnly.setState(1);

    TEditSound.setText(ssound);
    TEditCloseTime.setText(scloset);
    TEditWaitOften.setText(swaito);
    TEditWaitTime.setText(swaitt);
    TEditLevelUpTime.setText(slevelt);
    TEditScreenTime.setText(sscreent);
    TEditUpdateTime.setText(supdatet);
    TEditChatTime.setText(schatt);
    TEditLookForChatTime.setText(slchatt);
    TEditDismissTime.setText(sdismisst);

    TEditItemDis.setText(sitemd);

    TEditItemTime.setText(sitemt);

    TEditPlayNum.setText(tostr(playNum));
  end;

  TFormMain.ShowModal;

  i := -1;
  h := -1;
  case TComboBoxLoc.getItemIndex of
    (i:=i+1):begin //lumb
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=0;  //    oak sell
        (h:=h+1):Job:=1;  //            willow sell
        (h:=h+1):Job:=2;  //    west will
        (h:=h+1):Job:=3;  //            west willow 2
        (h:=h+1):Job:=4;  //  north will
        (h:=h+1):Job:=5;  //   yew
        (h:=h+1):Job:=6;  //    yew sell
        (h:=h+1):Job:=7;  //    prog chop
      end;
    end;
    (i:=i+1):begin //draynor
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=8;  //oak
        (h:=h+1):Job:=9;  // willow
        (h:=h+1):Job:=10;  //  yew
      end;
    end;
    (i:=i+1):begin // rimm
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=11;  // will ps
        (h:=h+1):Job:=12;  //     yew ps
        (h:=h+1):Job:=13;  // will sell
        (h:=h+1):Job:=14;  //     yew
        (h:=h+1):Job:=15;  // yew sell
      end;
    end;
    (i:=i+1):begin //fala
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=16;  //  oak
        (h:=h+1):Job:=17;  //   yew
      end;
    end;
    (i:=i+1):begin // edge
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=18;  //       yew
      end;
    end;
    (i:=i+1):begin //varr
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=19;  //   oak west
        (h:=h+1):Job:=20;  //    yew palc
        (h:=h+1):Job:=21;  //   oak east
        (h:=h+1):Job:=22;  //    yew pray
        (h:=h+1):Job:=23;  //   yew east
      end;
    end;
    (i:=i+1):begin //seers
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=24;  // oak
        (h:=h+1):Job:=25;  //   willow
        (h:=h+1):Job:=26;  //     maople
        (h:=h+1):Job:=27;  //      yew
        (h:=h+1):Job:=28;  //          mage
        (h:=h+1):Job:=29;  //          mage2
      end;
    end;
    (i:=i+1):begin //cath
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=30;  //  will
        (h:=h+1):Job:=31;  //      yew
      end;
    end;
    (i:=i+1):begin //tree g
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=32;  //  yew
        (h:=h+1):Job:=33;  //  yew 2
      end;
    end;
    (i:=i+1):begin //      barb
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=34;  //   will
      end;
    end;
    (i:=i+1):begin //      deul
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=35;  //   mag
      end;
    end;
    (i:=i+1):begin //      ape
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=36;  //   teak
      end;
    end;
    (i:=i+1):begin //      castle wars
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=37;  //   teak
      end;
    end;
    (i:=i+1):begin //      two baw
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=38;  //   teak
        (h:=h+1):Job:=39;  //   teak 2
        (h:=h+1):Job:=40;  //   mah
      end;
    end;
    (i:=i+1):begin //      power
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=41;  //   tree
        (h:=h+1):Job:=42;  //       oak
        (h:=h+1):Job:=43;  //          willow
      end;
    end;
    (i:=i+1):begin //      wc guild
      case TComboBoxType.getItemIndex of
        (h:=h+1):Job:=45;  //          Yews
        (h:=h+1):Job:=46;  //          Magics
        (h:=h+1):Job:=47;  //          red
        (h:=h+1):Job:=48;  //          red2
        (h:=h+1):Job:=49;  //          red3
        (h:=h+1):Job:=50;  //          red4
      end;
    end;
  end;

  ReflectPlayer.Username := TEditUser.getText;
  ReflectPlayer.Password := TEditPass.getText;
  ReflectPlayer.Pin := TEditPin.getText;
  ReflectPlayer.Active := true;

  SmartShowConsole := false;
  case random(8) of
    0:SmartUserAgent := 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:36.0) Gecko/20100101 Firefox/36.0';
    1:SmartUserAgent := 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:39.0) Gecko/20100101 Firefox/39.0';
    2:SmartUserAgent := 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:36.0) Gecko/20100101 Firefox/36.0';
    3:SmartUserAgent := 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:39.0) Gecko/20100101 Firefox/39.0';
    4:SmartUserAgent := 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:37.0) Gecko/20100101 Firefox/37.0';
    5:SmartUserAgent := 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:37.0) Gecko/20100101 Firefox/37.0';
    6:SmartUserAgent := 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0';
    7:SmartUserAgent := 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0';
  end;

  strings := GetWordsEx(TEditWorld.getText, '1234567890');
  if (length(strings) > 0) then
    SmartWorld := StrToInt(Strings[0]);

  setLength(WorldList, length(strings));
  for i := 0 to high(strings) do
    WorldList[i] := StrToInt(strings[i]);

  MouseKeys := (toStr(TCheckBoxMouse.getState) = 'cbChecked');
  DisableBank := (toStr(TCheckBoxBank.getState) = 'cbChecked');
  UseSpec := (toStr(TCheckBoxSpec.getState) = 'cbChecked');
  useBreaks := (toStr(TCheckBoxBreak.getState) = 'cbChecked');
  useAutoResponder := (toStr(TCheckBoxTalk.getState) = 'cbChecked');
  useFakeWaitTime := (toStr(TCheckBoxWait.getState) = 'cbChecked');
  dropOnly := (toStr(TCheckBoxDropOnly.getState) = 'cbChecked');

  if (Length(TEditRun.getText) > 0) then
    RunAmount := StrToInt(TEditRun.getText)
  else
    RunAmount := 0;

  if (Length(TEditAmount.getText) > 0) then
    AmountAmount := StrToInt(TEditAmount.getText)
  else
    AmountAmount := 0;

  if (Length(TEditAnti.getText) > 0) then
    AntiAmount := StrToInt(TEditAnti.getText)
  else
    AntiAmount := 0;

  if (Length(TEditPlayNum.getText) > 0) then
    playNum := StrToInt(TEditPlayNum.getText)
  else
    playNum := 0;

  if (Length(TEditCloseTime.getText) > 0) then
    closeAllOften := StrToInt(TEditCloseTime.GetText)
  else
    closeAllOften := 0;

  if (Length(TEditDismissTime.getText) > 0) then
    dismissAllOften := StrToInt(TEditDismissTime.GetText)
  else
    dismissAllOften := 0;

  if (Length(TEditLookForChatTime.getText) > 0) then
    lookForChatOften := StrToInt(TEditLookForChatTime.GetText)
  else
    lookForChatOften := 0;

  if (Length(TEditLevelupTime.getText) > 0) then
    checkForLevelOften := StrToInt(TEditLevelupTime.GetText)
  else
    checkForLevelOften := 0;

  if (Length(TEditChatTime.getText) > 0) then
    chatTimeOften := StrToInt(TEditChatTime.GetText)
  else
    chatTimeOften := 0;

  if (Length(TEditUpdateTime.getText) > 0) then
    updateAllOften := StrToInt(TEditUpdateTime.GetText)
  else
    updateAllOften := 0;

  if (Length(TEditWaitOften.getText) > 0) then
    cpuLoadOften := StrToInt(TEditWaitOften.GetText)
  else
    cpuLoadOften := 0;

  if (Length(TEditWaitTime.getText) > 0) then
    cpuLoadWait := StrToInt(TEditWaitTime.GetText)
  else
    cpuLoadWait := 0;

  if (Length(TEditScreenTime.getText) > 0) then
    updateScreenOften := StrToInt(TEditScreenTime.GetText)
  else
    updateScreenOften := 0;

  if (Length(TEditbin.getText) > 0) then
    breakIn := StrToInt(TEditbin.getText)
  else
    breakIn := 0;

  if (Length(TEditbrin.getText) > 0) then
    breakInRandom := StrToInt(TEditbrin.getText)
  else
    breakInRandom := 0;

  if (Length(TEditbfor.getText) > 0) then
    breakFor := StrToInt(TEditbfor.getText)
  else
    breakFor := 0;

  if (Length(TEditbrfor.getText) > 0) then
    breakForRandom := StrToInt(TEditbrfor.getText)
  else
    breakForRandom := 0;

  if (Length(TEditItemDis.getText) > 0) then
    ItemCheckDistance := StrToInt(TEditItemDis.GetText)
  else
    ItemCheckDistance := 0;

  if (Length(TEditItemTime.getText) > 0) then
    gItemOften := StrToInt(TEditItemTime.GetText)
  else
    gItemOften := 0;

  SoundString := TEditSound.getText;

  breakIn := breakIn*60000;
  breakInRandom := breakInRandom*60000;
  breakFor := breakFor*60000;
  breakForRandom := breakForRandom*60000;

  breakInTimer.restart;
  breakInFinal := breakIn + randomRange(-breakInRandom, breakInRandom);

  TFormBreak.Free;
  TFormExtra.Free;
  TFormMain.Free;
end;

procedure ShowForm();
var
  tempBMP : integer;
  IniString, picString, crypt : string;
begin
  daLogger.Init('Script', TReflectLoggerLevel.Status);

  picString := GetPage(PicturePage);

  tempBMP := BitmapFromString(374, 208, picString);
  TMainBMP.Init;
  TMainBMP := GetMufasaBitmap(tempBMP).ToTBitmap;
  freeBitmap(tempBMP);

  started := false;
  saving := false;
  loading := false;
  job := -1;
  playNum := 0;
  IniString := scriptPath+'ineedbot''s AIO Woodcutter user details.ini';

  sync(ShowFormModal);
  while saving or loading do begin
    if saving then begin
      writeini('chat', intToStr(playNum), schat, IniString);
      writeini('wait', intToStr(playNum), swait, IniString);
      writeini('name', intToStr(playNum), sname, IniString);

      crypt := spass;
      rc2_encrypt('ineedbotschop', htMD5, crypt);
      writeini('pass', intToStr(playNum), crypt, IniString);

      writeini('pin', intToStr(playNum), spin, IniString);
      writeini('world', intToStr(playNum), sworld, IniString);
      writeini('amount', intToStr(playNum), samount, IniString);
      writeini('run', intToStr(playNum), srun, IniString);
      writeini('anti', intToStr(playNum), santi, IniString);
      writeini('type', intToStr(playNum), stype, IniString);
      writeini('loc', intToStr(playNum), sloc, IniString);
      writeini('mouse', intToStr(playNum), smouse, IniString);
      writeini('bank', intToStr(playNum), sbank, IniString);
      writeini('spec', intToStr(playNum), sspec, IniString);
      writeini('bfor', intToStr(playNum), sbfor, IniString);
      writeini('brfor', intToStr(playNum), sbrfor, IniString);
      writeini('bin', intToStr(playNum), sbin, IniString);
      writeini('brin', intToStr(playNum), sbrin, IniString);
      writeini('brake', intToStr(playNum), sbreak, IniString);
      writeini('sound', intToStr(playNum), ssound, IniString);
      writeini('dismisst', intToStr(playNum), sdismisst, IniString);
      writeini('lchatt', intToStr(playNum), slchatt, IniString);
      writeini('chatt', intToStr(playNum), schatt, IniString);
      writeini('updatet', intToStr(playNum), supdatet, IniString);
      writeini('screent', intToStr(playNum), sscreent, IniString);
      writeini('levelt', intToStr(playNum), slevelt, IniString);
      writeini('waitt', intToStr(playNum), swaitt, IniString);
      writeini('waito', intToStr(playNum), swaito, IniString);
      writeini('closet', intToStr(playNum), scloset, IniString);
      writeini('itemd', intToStr(playNum), sitemd, IniString);
      writeini('drop', intToStr(playNum), sdrop, IniString);
      writeini('itemt', intToStr(playNum), sitemt, IniString);
    end;
    if (loading or saving) and FileExists(IniString) then begin
      schat := ReadINI('chat', intToStr(playNum), IniString);
      swait := ReadINI('wait', intToStr(playNum), IniString);
      sname := ReadINI('name', intToStr(playNum), IniString);

      crypt := ReadINI('pass', intToStr(playNum), IniString);
      rc2_decrypt('ineedbotschop', htMD5, crypt);
      spass := crypt;

      spin := ReadINI('pin', intToStr(playNum), IniString);
      sworld := ReadINI('world', intToStr(playNum), IniString);
      samount := ReadINI('amount', intToStr(playNum), IniString);
      srun := ReadINI('run', intToStr(playNum), IniString);
      santi := ReadINI('anti', intToStr(playNum), IniString);
      stype := ReadINI('type', intToStr(playNum), IniString);
      sloc := ReadINI('loc', intToStr(playNum), IniString);
      smouse := ReadINI('mouse', intToStr(playNum), IniString);
      sbank := ReadINI('bank', intToStr(playNum), IniString);
      sspec := ReadINI('spec', intToStr(playNum), IniString);
      sbfor := ReadINI('bfor', intToStr(playNum), IniString);
      sbrfor := ReadINI('brfor', intToStr(playNum), IniString);
      sbin := ReadINI('bin', intToStr(playNum), IniString);
      sbrin := ReadINI('brin', intToStr(playNum), IniString);
      sbreak := ReadINI('brake', intToStr(playNum), IniString);
      ssound := ReadINI('sound', intToStr(playNum), IniString);
      sdismisst := ReadINI('dismisst', intToStr(playNum), IniString);
      slchatt := ReadINI('lchatt', intToStr(playNum), IniString);
      schatt := ReadINI('chatt', intToStr(playNum), IniString);
      supdatet := ReadINI('updatet', intToStr(playNum), IniString);
      sscreent := ReadINI('screent', intToStr(playNum), IniString);
      slevelt := ReadINI('levelt', intToStr(playNum), IniString);
      swaitt := ReadINI('waitt', intToStr(playNum), IniString);
      swaito := ReadINI('waito', intToStr(playNum), IniString);
      scloset := ReadINI('closet', intToStr(playNum), IniString);
      sitemd := ReadINI('itemd', intToStr(playNum), IniString);
      sdrop := ReadINI('drop', intToStr(playNum), IniString);
      sitemt := ReadINI('itemt', intToStr(playNum), IniString);
    end;
    sync(showFormModal);
  end;

  TMainBMP.free;
end;

procedure doUpdateScreen;
var currentWoodXp, CurrentWoodLevel, currentFletchXp, currentFireXP, tempInt, i, h, tempCheck, tempCheck2, TimeRunning, myPlane: integer;
    _items : TReflectInvItemArray;
    perHour : extended;
    _eitems : TReflectWornEquipmentArray;
    tB : TBox;
    tObj : TReflectObject;
    RSTile, rsTile2 : TPoint;
    BankNPCIDs : TIntegerArray;
    _npcs : TReflectNpcArray;
    t_string : string;
begin
  graphicOpti.DrawClear(0);

  currentWoodLevel := ReflectPlayer.GetMaxSkillLevel(SKILL_WOODCUTTING);
  currentFletchXP := ReflectPlayer.GetSkillExp(SKILL_Fletching);
  currentWoodXP := ReflectPlayer.GetSkillExp(SKILL_WOODCUTTING);
  currentFireXP := ReflectPlayer.GetSkillExp(SKILL_FireMaking);

  TimeRunning := GetTimeRunning;
  perHour := 3600000/TimeRunning;

  myPlane := Reflect.Tiles.GetPlane;

  tempInt := Reflect.Gametab.CurrentColor;
  if tempInt = Gametab_Inventory then begin
    _items.GetAll;
    for i:=0 to high(_items) do begin
      h := _items[i].getid;
      if(inIntArray(AxeIDs, h))then begin
        tB := _items[i].GetBox;
        graphicOpti.DrawClippedText('Axe', 'upchars07', Point(tB.x1 - 5, tB.y1), true, 65280);
      end else begin
        if(inIntArray(KnifeIDs, h))then begin
          tB := _items[i].GetBox;
          graphicOpti.DrawClippedText('Knife', 'upchars07', Point(tB.x1 - 5, tB.y1), true, 65280);
        end else begin
          if(inIntArray(TinderIDs, h))then begin
            tB := _items[i].GetBox;
            graphicOpti.DrawClippedText('Tind.', 'upchars07', Point(tB.x1 - 5, tB.y1), true, 65280);
          end else begin
            if(inIntArray(CoinsIDs, h))then begin
              tB := _items[i].GetBox;
              graphicOpti.DrawClippedText('Coins', 'upchars07', Point(tB.x1 - 5, tB.y1), true, 65280);
            end else begin
              if(inIntArray(NestIDs, h))then begin
                tB := _items[i].GetBox;
                graphicOpti.DrawClippedText('Nest', 'upchars07', Point(tB.x1 - 5, tB.y1), true, 65280);
              end else begin
                if(inIntArray(ShaftIDs, h))then begin
                  tB := _items[i].GetBox;
                  graphicOpti.DrawClippedText('Shaft', 'upchars07', Point(tB.x1 - 5, tB.y1), true, 65280);
                end else begin
                  if(inIntArray(GreeGreeIds, h))then begin
                    tB := _items[i].GetBox;
                    graphicOpti.DrawClippedText('Gree', 'upchars07', Point(tB.x1 - 5, tB.y1), true, 65280);
                  end else begin
                    if(inIntArray(TradingSticksIds, h))then begin
                      tB := _items[i].GetBox;
                      graphicOpti.DrawClippedText('Sticks', 'upchars07', Point(tB.x1 - 5, tB.y1), true, 65280);
                    end else begin
                      for tempCheck := 0 to high(DaLocation.Logs) do
                        if h = DaLocation.Logs[tempCheck].ID then begin
                          tB := _items[i].GetBox;
                          graphicOpti.DrawClippedText('Log', 'upchars07', Point(tB.x1 - 5, tB.y1), true, 65280);
                        end;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end else begin
    if tempInt = Gametab_WornEquipment then begin
      _eitems.GetAll;
      for i:=0 to high(_eitems) do begin
        h := _eitems[i].getID;
        if(inIntArray(AxeIDs, h))then begin
          tB := _eitems[i].getBox;
          graphicOpti.DrawClippedText('Axe', 'upchars07', Point(tB.x1 - 5, tB.y1), true, 65280);
        end;
      end;
    end;
  end;

  for i:=0 to high(DaLocation.BankLocations) do begin
    if myPlane = DaLocation.BankLocations[i].Plane then begin
      if R_TileOnMM(DaLocation.BankLocations[i].Tile, RSTile) then begin
        graphicOpti.DrawEllipse(RSTile, 5, 5, clBlue, false);
        if R_TileOnMS(DaLocation.BankLocations[i].Tile, RSTile, DaLocation.BankLocations[i].Offset[0], DaLocation.BankLocations[i].Offset[1], DaLocation.BankLocations[i].Offset[2]) then begin
          graphicOpti.DrawClippedText(DaLocation.BankLocations[i].Name, 'upchars07', RSTile, true, clBlue);
        end;
      end;
    end;
  end;

  for i:=0 to high(DaLocation.TreeLocations) do begin
    if R_TileOnMM(DaLocation.TreeLocations[i], RSTile) then begin
      graphicOpti.DrawEllipse(RSTile, 5, 5, clGreen, false);
      if R_TileOnMS(DaLocation.TreeLocations[i], RSTile) then begin
        graphicOpti.DrawClippedText('Trees', 'upchars07', RSTile, true, clGreen);
      end;
    end;
  end;

  for i:=0 to high(DaLocation.FireLanes) do begin
    if myPlane = DaLocation.FireLanes[i].Plane then begin
      if R_TileOnMM(daLocation.FireLanes[i].Tile, RSTile) then begin
        graphicOpti.DrawEllipse(RSTile, 5, 5, clOrange, false);
        if R_TileOnMS(daLocation.FireLanes[i].Tile, RSTile) then begin
          graphicOpti.DrawClippedText('FireStart', 'upchars07', RSTile, true, clOrange);
        end;
      end;
      if R_TileOnMM(Point(daLocation.FireLanes[i].Tile.x-daLocation.FireLanes[i].Length, daLocation.FireLanes[i].Tile.y), RSTile) then begin
        graphicOpti.DrawEllipse(RSTile, 5, 5, clOrange, false);
        if R_TileOnMS(Point(daLocation.FireLanes[i].Tile.x-daLocation.FireLanes[i].Length, daLocation.FireLanes[i].Tile.y), RSTile) then begin
          graphicOpti.DrawClippedText('FireEnd', 'upchars07', RSTile, true, clOrange);
        end;
      end;
    end;
  end;

  for i:=0 to high(daLocation.BankNPCs) do
    for h:=0 to high(daLocation.BankNPCs[i].IDs) do begin
      setLength(BankNPCIDs, length(BankNPCIDs)+1);
      BankNPCIDs[high(BankNPCIDs)] := daLocation.BankNPCs[i].IDs[h];
    end;
  _npcs.GetAll;
  for i:=0 to high(_npcs) do begin
    if(inIntArray(BankNPCIDs, _npcs[i].getid))then begin
      rsTile2 := _npcs[i].gettile;
      if R_TileOnMM(rsTile2, RSTile) then begin
        graphicOpti.DrawEllipse(RSTile, 5, 5, clBlue, false);
        if R_TileOnMS(rsTile2, RSTile) then
          graphicOpti.DrawClippedText(_npcs[i].getname, 'upchars07', RSTile, true, clBlue);
      end;
    end;
  end;

  for i:=0 to high(daLocation.DoorObjects) do begin
    if myPlane = daLocation.DoorObjects[i].Plane then begin
      if R_TileOnMM(daLocation.DoorObjects[i].Tile, RSTile) then begin
        graphicOpti.DrawEllipse(RSTile, 5, 5, clGray, false);
        if R_TileOnMS(daLocation.DoorObjects[i].Tile, RSTile, daLocation.DoorObjects[i].Offset[0], daLocation.DoorObjects[i].Offset[1], daLocation.DoorObjects[i].Offset[2]) then begin
          tObj.GetAt(ObjBoundary, daLocation.DoorObjects[i].Tile);
          if not Reflect.Smart.IsNull(tObj.Reference) then begin
            graphicOpti.DrawClippedText('Closed door', 'upchars07', RSTile, true, clGray);
          end else begin
            graphicOpti.DrawClippedText('Opened door', 'upchars07', RSTile, true, clGray);
          end;
        end;
      end;
    end;
  end;

  for i:=0 to high(daLocation.TreeObjects) do begin
    if myPlane = daLocation.TreeObjects[i].Plane then begin
      tObj.GetAt(ObjGame, daLocation.TreeObjects[i].Tile);
      if not Reflect.Smart.IsNull(tObj.Reference) then
        h := tObj.GetId
      else
        h := -1;
      if inIntArray(daLocation.TreeObjects[i].AliveIDs, h) then begin
        t_string := 'Alive '+daLocation.TreeObjects[i].Name;
        daLocation.TreeObjects[i].Timer.Restart;
        daLocation.TreeObjects[i].Timer.StartTime := -1;
      end else begin
        if inIntArray(daLocation.TreeObjects[i].DeadIDs, h) then begin
          if (daLocation.TreeObjects[i].Timer.StartTime = -1) then
            daLocation.TreeObjects[i].Timer.reStart;
          t_string := 'Dead '+daLocation.TreeObjects[i].Name+'('+floatToStr(daLocation.TreeObjects[i].Timer.Elapsedtime / 1000)+')';
        end else begin
          if (daLocation.TreeObjects[i].Timer.StartTime = -1) then
            daLocation.TreeObjects[i].Timer.reStart;
          t_string := 'Unknown '+daLocation.TreeObjects[i].Name+' ID('+intToStr(h)+')';
        end;
      end;

      if R_TileOnMM(daLocation.TreeObjects[i].Tile, RSTile) then begin
        graphicOpti.DrawEllipse(RSTile, 5, 5, clAqua, false);
        if R_TileOnMS(daLocation.TreeObjects[i].Tile, RSTile, daLocation.TreeObjects[i].Offset[0], daLocation.TreeObjects[i].Offset[1], daLocation.TreeObjects[i].Offset[2]) then begin
          graphicOpti.DrawClippedText(t_string, 'upchars07', RSTile, true, clAqua);
        end;
      end;
    end;
  end;

  tempInt := 20;
  graphicOpti.DrawClippedText('Status: '+scriptStatus, 'upchars07', Point(5, tempInt), true, 65280);
  tempInt:=tempInt+15;
  tempCheck := currentWoodXP-startWoodXP;
  if (tempCheck > 0) then begin
    tempCheck2 := Round(tempCheck*perHour);
    graphicOpti.DrawClippedText('Woodcutting XP gained: '+intToStr(tempCheck)+'('+InttoStr(tempCheck2)+'), level: '+intToStr(currentWoodLevel)+'('+InttoStr(CurrentWoodLevel-StartWoodLevel)+') TTL: '+Reflect.Time.msToTime(Round(varExpToGoal(CurrentWoodXP, CurrentWoodLevel+1)/(((CurrentWoodXP-startWoodXP))/GetTimeRunning)), Time_Bare), 'upchars07', Point(5, tempInt), true, 65280);
    tempInt:=tempInt+15;
  end;
  tempCheck := currentFletchXP-startFletchXP;
  if (tempCheck > 0) then begin
    tempCheck2 := Round(tempCheck*perHour);
    graphicOpti.DrawClippedText('Fletching XP gained: '+intToStr(tempCheck)+'('+InttoStr(tempCheck2)+')', 'upchars07', Point(5, tempInt), true, 65280);
    tempInt:=tempInt+15;
  end;
  tempCheck := currentFireXP-startFireXP;
  if (tempCheck > 0) then begin
    tempCheck2 := Round(tempCheck*perHour);
    graphicOpti.DrawClippedText('Firemaking XP gained: '+intToStr(tempCheck)+'('+InttoStr(tempCheck2)+')', 'upchars07', Point(5, tempInt), true, 65280);
    tempInt:=tempInt+15;
  end;
  tempCheck := 0;
  for i:=0 to high(DaLocation.Logs) do
    tempCheck := tempCheck + DaLocation.Logs[i].chopped;
  if (tempCheck > 0) then begin
    tempCheck2 := Round(tempCheck*perHour);
    graphicOpti.DrawClippedText('Chopped: '+intToStr(tempCheck)+'('+InttoStr(tempCheck2)+'), nests: '+intToStr(nests), 'upchars07', Point(5, tempInt), true, 65280);
    tempInt:=tempInt+15;
    if daLocation.canBank and not daLocation.canFire and not daLocation.isSell and not daLocation.canFletch then begin
      tempCheck := 0;
      for i:=0 to high(DaLocation.Logs) do
        tempCheck := tempCheck + (DaLocation.Logs[i].price*DaLocation.Logs[i].chopped);
      tempCheck2 := Round(tempCheck*perHour);
      graphicOpti.DrawClippedText('Profit: '+intToStr(tempCheck)+'('+InttoStr(tempCheck2)+')', 'upchars07', Point(5, tempInt), true, 65280);
      tempInt:=tempInt+15;
    end;
  end;
  if useBreaks then begin
    graphicOpti.DrawClippedText('Breaks taken: '+intToStr(breaks)+', next break in: '+Reflect.Time.msToTime(breakInFinal-breakInTimer.Elapsedtime, Time_Bare), 'upchars07', Point(5, tempInt), true, 65280);
    tempInt:=tempInt+15;
  end;
  graphicOpti.DrawClippedText('Current job: '+daLocation.Name+', bank:'+boolToStr(daLocation.canBank)+', fletch:'+boolToStr(daLocation.canfletch)+', fire:'+boolToStr(daLocation.canfire), 'upchars07', Point(5, tempInt), true, 65280);
  tempInt:=tempInt+15;
  graphicOpti.DrawClippedText('Ran for '+Reflect.Time.msToTime(getTimeRunning(), TIME_FORMAL)+'. Script version: '+floatToStr(version)+'('+floatToStr(fversion)+')', 'upchars07', Point(5, tempInt), true, 65280);

  Reflect.Smart.Graphics.DrawBitmap(graphicOpti, Point(0, 0), true);
end;

procedure sleepScript(tim:integer);override;
var _t : treflecttimer;
begin
  if cpuLoadWait < 0 then begin
    sleep(tim);
  end else begin
    if cpuLoadWait = 0 then begin

    end else begin
      _t.restart;
      while (_t.Elapsedtime < tim) do
        sleep(cpuLoadWait);
    end;
  end;
end;

procedure updateScreen(_string:string);override;
begin
  if (_string <> '') then
    scriptStatus := _string;
  if cpuLoadOften > 0 then
    sleepScript(cpuLoadOften);
  if updateScreenTimer.Elapsedtime > updateScreenOften then begin
    doUpdateScreen;
    updateScreenTimer.restart;
  end;
end;

procedure TReflectObjectArray.GetAll2(ObjType: TObjectType; Distance: Integer; Position: TPoint);
var
  Multi, BaseX, BaseY, X, Y, I, Count, Plane, HighX, HighY: integer;
  Temp: TReflectObject;
  ObjectHook, SceneHook: THook;
begin
  if not Reflect.Mem.IsNull(ckObject) then
    Reflect.Mem.FreeObjects(ckObject, True);
  Distance := Round(Distance / 2);
  if HookCache[TCacheKey.ckRegion][0] = 0 then
    Reflect.Mem.GetObject(ckNull, ckRegion, Client_Region, 0, 0);
  BaseX := Reflect.Misc.BaseX;
  BaseY := Reflect.Misc.BaseY;
  Position := Point(Position.X - BaseX, Position.Y - BaseY);
  Plane := Reflect.Tiles.GetPlane;
  HighX := Position.X + Distance;
  HighY := Position.Y + Distance;
  if HighX > 103 then
    HighX := 103;
  if HighY > 103 then
    HighY := 103;
  SetLength(Self, 10817);
  for X := Position.X - Distance to HighX do
    for Y := Position.Y - Distance to HighY do
    begin
      Reflect.Mem.Get3DObject(ckRegion, ckSceneTile, Region_SceneTiles,
        Count, 0, Plane, X, Y);
      Temp._ObjType := ObjType;
      Temp._GetObject(Count, Point(BaseX + X, BaseY + Y));
      Inc(Count);
      if Temp.Reference = 0 then
        Continue;
      Self[I] := Temp;
      Inc(I);
    end;
    SetLength(Self, I);
    Reflect.Mem.FreeObjects(ckSceneTile, Count);
    Self.Sort;
end;

function apeAtollIsChopping(_treeTile : TPoint;_ids:TIntegerArray):boolean;
var invC, _id : integer;
    timer : treflecttimer;
    tObj : TReflectObject;
begin
  if daLocation.ID <> 36 then
    exit(false);
  timer.restart;
  invC := Reflect.Inv.Count;
  tObj.GetAt(ObjGame, _treeTile);
  if not Reflect.Smart.IsNull(tObj.Reference) then
    _id := tObj.GetId
  else
    _id := -1;
  while ReflectPlayer.IsLoggedIn and (timer.Elapsedtime < 5000) and (invC = Reflect.Inv.Count) and
  not ReflectPlayer.IsUnderAttack and inIntArray(_ids, _id) do begin
    randomHandler;
    FixActive;
    UpdateScreen('Chopping tree...');
    tObj.GetAt(ObjGame, _treeTile);
    if not Reflect.Smart.IsNull(tObj.Reference) then
      _id := tObj.GetId
    else
      _id := -1;
  end;
  result := (invC <> Reflect.Inv.Count);
end;

function daLocation.getLogIDs: TIntegerArray;
var i : integer;
begin
  for i:=0 to high(daLocation.Logs) do begin
    setLength(result, length(result)+1);
    result[high(result)] := daLocation.Logs[i].ID;
  end;
end;

function getActivatedSlot:integer;
var i : integer;
begin
  result := -1;
  for i:=1 to 28 do begin
    if slotActivated(i) then begin
      exit(i);
    end;
  end;
end;

function getActiveItemID:integer;
var i, h : integer;
    _items : TReflectInvItemArray;
begin
   _items.GetAll;
   h := getActivatedSlot;

   for i:=0 to high(_items) do
      if (_items[i].GetInvSlot = h) then
        exit(_items[i].GetID);
end;

function getGoodFireLaneIndices : TIntegerArray;
var i, h : integer;
    _obj : TReflectObject;
    goodArray : boolean;
begin
  for i:=0 to high(daLocation.Firelanes) do begin
    if Reflect.Tiles.GetPlane = daLocation.Firelanes[i].Plane then begin
      goodArray := true;
      for h:=daLocation.Firelanes[i].Tile.x downto (daLocation.Firelanes[i].Tile.x - daLocation.Firelanes[i].Length) do begin
        _obj.GetAt(ObjGame, Point(h, daLocation.Firelanes[i].Tile.Y));
        if not Reflect.Smart.IsNull(_obj.Reference) and inIntArray(FireIDs, _obj.GetId) then begin
          goodArray := false;
          break;
        end;
      end;
      if goodArray then begin
        setLength(result, length(result)+1);
        result[high(result)] := i;
      end;
    end;
  end;
end;

procedure dynChop;
var wclevel, i, coins : integer;
    equ : string;
    tP : TPoint;
    tB : TBox;
    _item : TReflectInvItem;
    _obj : TReflectObject;
    foundAxe : boolean;
    logIDs : TIntegerArray;
begin
  case job of
    7:begin
      equ := R_GetEquipText;
      foundAxe := ((equ = 'Steel axe') or (_item.Find('Steel axe')));

      if (equ = 'Unarmed') and _item.Find('Bronze axe') then begin
        if Reflect.Gametab.CurrentColor <> Gametab_Inventory then
          Reflect.Gametab.Open(Gametab_Inventory);
        _item.Interact(Mouse_left);
        sleepScript(1000+random(1000));
      end;

      wclevel := ReflectPlayer.GetMaxSkillLevel(SKILL_WOODCUTTING);

      logIDs := daLocation.getLogIDs;

      if _item.Find('Coins') then
        coins := _item.GetQuantity
      else
        coins := 0;

      setLength(daLocation.DoorObjects, 2);
      with daLocation.DoorObjects[0] do begin
        TileOffset := [0, 0];
        Plane := 0;
        Actions := ['Open'];
        Tile := Point(3215, 3245);
        Offset := [-62, 0, 100];
        TileEncompass := [Point(3208, 3244), Point(3210, 3242), Point(3212, 3242), Point(3214, 3244), Point(3214, 3249), Point(3212, 3251), Point(3210, 3251), Point(3208, 3249)];
      end;
      with daLocation.DoorObjects[1] do begin
        Plane := 0;
        TileOffset := [0, 0];
        Tile := Point(3234, 3203);
        Actions := ['Open'];
        Offset := [-62, 0, 100];
        TileEncompass := [Point(3233, 3205), Point(3233, 3201), Point(3228, 3201), Point(3228, 3205)];
      end;

      if wclevel >= 6 then begin
        if coins >= 208 then begin
          if not foundAxe then begin
            while ReflectPlayer.IsLoggedIn and not foundAxe and (coins >= 208) do begin
              foundAxe := ((R_GetEquipText = 'Steel axe') or (_item.Find('Steel axe')));
              if _item.Find('Coins') then
                coins := _item.GetQuantity
              else
                coins := 0;

              updateScreen('Going to go buy axe.');
              if Reflect.Inv.IsFull then begin
                if _item.Find(LogIDs) then begin
                  _item.Interact('Drop');
                  sleepScript(1000+random(1000));
                end;
              end;

              daLocation.DoorObjects[1].Open(false);
              if not Reflect.Shop.IsOpen then begin
                updateScreen('Trading Bob.');
                R_TryInteractNPC([505], ['Trade'], 5, 0, 0, 50);
                ReflectPlayer.FFlag(0, 5000+random(500));
                sleepScript(random(1000));
              end;
              updateScreen('Buying axe.');
              if Reflect.Shop.IsOpen then begin
                Reflect.Mouse.Move(Point(235, 81), 5, 5, Mouse_right);
                if Reflect.Text.ChooseOption('Buy 1') then
                  foundAxe := true;
                sleepScript(1000+random(1000));
                Reflect.Mouse.Move(Point(488, 43), 5, 5, Mouse_Left);
                sleepScript(1000+random(1000));
              end;
            end;
          end;
        end;
      end;

      daLocation.DoorObjects[1].Open(true);
      if wclevel >= 15 then begin
        if wclevel >= 30 then begin
          daLocation.ID := 1;

          daLocation.canBank := true;
          setLength(daLocation.BankNPCs, 1);
          with daLocation.BankNPCs[0] do begin
            Locations := [Point(3212, 3246)];
            Names := [];
            Plane := 0;
            IDs := [507, 506];
            Options := ['Trade S'];
            Offset := [0, 0, 50];
          end;
          daLocation.isSell := true;

          daLocation.isPower := false;
          daLocation.canFletch := true;
          daLocation.fletchPoint := Point(264, 413);
          daLocation.TreeLocations := [Point(3234, 3242)];

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.TreeObjects, 2)
          with daLocation.TreeObjects[0] do begin
            Offset := [62, 62, 200];
            TileOffset := [0, 2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 0;
            Tile := Point(3234, 3238);
            AliveIDs := [7482, 7422, 7480, 7424, 1760, 1750, 1756, 1758];
            DeadIds := [9471, 9711];
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [-62, 62, 200];
            TileOffset := [-1, -1];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 1;
            Tile := Point(3234, 3244);
            AliveIDs := [7482, 7422, 7480, 7424, 1760, 1750, 1756, 1758];
            DeadIds := [9471, 9711];
            Plane := 0;
          end;
        end else begin
          daLocation.ID := 0;

          daLocation.canBank := true;
          setLength(daLocation.BankNPCs, 1);
          with daLocation.BankNPCs[0] do begin
            Locations := [Point(3212, 3246)];
            Names := [];
            Plane := 0;
            IDs := [507, 506];
            Options := ['Trade S'];
            Offset := [0, 0, 50];
          end;
          daLocation.isSell := true;

          daLocation.isPower := false;
          daLocation.canFletch := true;
          daLocation.fletchPoint := Point(264, 413);

          daLocation.RunDirections := ['rand'];
          daLocation.TreeLocations := [Point(3206, 3242)];

          setLength(daLocation.TreeObjects, 2)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, -2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Oak';
            Index := 0;
            Tile := Point(3204, 3247);
            AliveIDs := [7417, 1751];
            DeadIDs := [1356];
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Oak';
            Index := 1;
            Tile := Point(3205, 3240);
            AliveIDs := [7417, 1751];
            DeadIDs := [1356];
            Plane := 0;
          end;
        end;
      end else begin
        daLocation.ID := 41;
        setLength(daLocation.customIDs, 1);
        daLocation.customIDs[0] := [1278, 1276, 1286, 1282, 2091, 2092];
        daLocation.canFletch := true;
        daLocation.fletchPoint := Point(62, 421);

        daLocation.isPower := true;
        daLocation.RunDirections := ['n'];

        daLocation.TreeLocations := [Point(3171, 3233)];
        daLocation.distanceCheck := 26;
      end;
    end;
  end;
end;

procedure setupScript;
var i : integer;
    AliveTreeIDs, DeadTreeIDs, AliveOakIDs, DeadOakIDs, AliveWillowIDs, DeadWillowIDs, AliveMapleIDs, DeadMapleIDs, AliveYewIDs, DeadYewIDs, AliveMagicIDs, DeadMagicIDs : TIntegerArray;
begin
  graphicOpti.Init(Client.GetMBitmaps);
  graphicOpti.SetSize(765, 503);
  graphicOpti.SetTransparentColor(0);

  AddOnTerminate('FreeDTMZ');

  Reflect.Interfaces.CloseAll;
  updateAllRefVars;
  updateScreen('Setting up...');
  useStats := true;
  if useStats then
    statsServer.Setup('6');

  StartWoodXP := ReflectPlayer.GetSkillExp(SKILL_WOODCUTTING);
  StartWoodLevel := ReflectPlayer.GetMaxSkillLevel(SKILL_WOODCUTTING);
  StartFletchXP := ReflectPlayer.GetSkillExp(SKILL_FLETCHING);
  StartFireXP := ReflectPlayer.GetSkillExp(SKILL_FIREMAKING);

  LastXPXP := StartWoodXP;
  LastXPCheck.restart;
  statsWoodXP := StartWoodXP;
  statsFletchXP := StartFletchXP;
  statsFireXp := StartFireXP;
  statsProfit := 0;
  StatsTimer.restart;
  gItemTim.restart;
  StatsTime := 50000 + random(400000);

  Nests := 0;

  wasWorking := false;

  ChopAnimationIDs := [879, 877, 875, 873, 871, 869, 867, 2846];
  FletchAnimationIDs := [1248];
  ShaftIDs := [52];
  CoinsIDs := [995];
  KnifeIDs := [946];
  AxeIDs := [1351, 1349, 1357, 1359, 6739, 1355, 1361, 1353];
  NestIDs := [5069, 5070, 5071, 5072, 5073, 5074, 7412, 11965];
  TinderIDs := [590];
  FireIDs := [26185, 2986, 9380];
  FireAnimIDs := [733];
  GreeGreeIDs := [4030, 4026, 4031, 4024];
  TradingSticksIDs := [6306];

  AliveTreeIDs := [1276, 1278];
  DeadTreeIDs := [1342];
  AliveOakIDs := [7417, 1751];
  DeadOakIDs := [1356];
  AliveWillowIDs := [7482, 7422, 7480, 7424, 1760, 1750, 1756, 1758];
  DeadWillowIDs := [9471, 9711];
  AliveMapleIDs := [7481, 1759];
  DeadMapleIDs := [9712];
  AliveYewIDs := [7420, 7419, 1754, 1753];
  DeadYewIDs := [9714];
  AliveMagicIDs := [7483, 1762, 1761];
  DeadMagicIDs  := [9713];

  daLocation.BankLocations := [];
  daLocation.BankNPCs := [];
  daLocation.customIDs := [];
  daLocation.customTPAs := [];
  daLocation.DoorObjects := [];
  daLocation.FireLanes := [];
  daLocation.Logs := [];
  daLocation.PathToBank := [];
  daLocation.PathToTree := [];
  daLocation.RunDirections := [];
  daLocation.TreeLocations := [];
  daLocation.TreeObjects := [];
  daLocation.canBank := false;
  daLocation.canFire := false;
  daLocation.canFletch := false;
  daLocation.isDynamic := false;
  daLocation.isSell := false;
  daLocation.ID := -1;
  daLocation.Name := '';
  daLocation.isFar := false;
  daLocation.isPower := false;
  daLocation.fletchPoint := Point(-1, -1);

  PreviousTree.Tile := Point(-1, -1);

  case job of
    8..10:begin
      daLocation.canBank := true;
      setLength(daLocation.BankLocations, 3);
      with daLocation.BankLocations[0] do begin
        Offset := [0, 0, 50];
        TileOffset := [2, -1];
        Tile := Point(3091, 3245);
        Options := ['Bank Bank booth'];
        Plane := 0;
        Name := 'Bank';
      end;
      with daLocation.BankLocations[1] do begin
        Offset := [0, 0, 50];
        TileOffset := [2, 0];
        Tile := Point(3091, 3243);
        Options := ['Bank Bank booth'];
        Plane := 0;
        Name := 'Bank';
      end;
      with daLocation.BankLocations[2] do begin
        Offset := [0, 0, 50];
        TileOffset := [2, 1];
        Tile := Point(3091, 3242);
        Options := ['Bank Bank booth'];
        Plane := 0;
        Name := 'Bank';
      end;

      case job of
        8:begin
          daLocation.ID := 8;
          daLocation.Name := 'Draynor Oaks';

          daLocation.canFletch := true;
          daLocation.fletchPoint := Point(264, 413);

          daLocation.RunDirections := ['n', 'w'];

          daLocation.canFire := true;

          setLength(daLocation.FireLanes, 5);
          with daLocation.FireLanes[0] do begin
            Plane := 0;
            Length := 17;
            Tile := Point(3098, 3247);
          end;
          with daLocation.FireLanes[1] do begin
            Plane := 0;
            Length := 26;
            Tile := Point(3098, 3248);
          end;
          with daLocation.FireLanes[2] do begin
            Plane := 0;
            Length := 20;
            Tile := Point(3097, 3249);
          end;
          with daLocation.FireLanes[3] do begin
            Plane := 0;
            Length := 16;
            Tile := Point(3105, 3250);
          end;
          with daLocation.FireLanes[4] do begin
            Plane := 0;
            Length := 10;
            Tile := Point(3087, 3250);
          end;

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1521;

          daLocation.TreeLocations := [Point(3103, 3243)];

          setLength(daLocation.TreeObjects, 1);
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 250];
            TileOffset := [-2, 2];
            Tile := Point(3103, 3243);
            Options := ['Chop down Oak'];
            Name := 'Oak';
            Index := 0;
            AliveIDs := AliveOakIDs;
            DeadIds := DeadOakIDs;
            Timer.Restart;
            Timer.StartTime := -1;
          end;
        end;
        9:begin
          daLocation.ID := 9;
          daLocation.Name := 'Draynor Willows';

          daLocation.canFletch := true;
          daLocation.fletchPoint := Point(264, 413);

          daLocation.RunDirections := ['n', 's', 'e'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1519;

          daLocation.canFire := true;

          setLength(daLocation.FireLanes, 5);
          with daLocation.FireLanes[0] do begin
            Plane := 0;
            Length := 17;
            Tile := Point(3102, 3237);
          end;
          with daLocation.FireLanes[1] do begin
            Plane := 0;
            Length := 17;
            Tile := Point(3102, 3238);
          end;
          with daLocation.FireLanes[2] do begin
            Plane := 0;
            Length := 22;
            Tile := Point(3102, 3239);
          end;
          with daLocation.FireLanes[3] do begin
            Plane := 0;
            Length := 26;
            Tile := Point(3116, 3234);
          end;
          with daLocation.FireLanes[4] do begin
            Plane := 0;
            Length := 21;
            Tile := Point(3111, 3235);
          end;

          daLocation.TreeLocations := [Point(3083, 3237)];

          setLength(daLocation.TreeObjects, 2);
          with daLocation.TreeObjects[0] do begin
            Offset := [75, 125, 200];
            TileOffset := [2, 0];
            Tile := Point(3083, 3237);
            Options := ['Chop down Willow'];
            Name := 'Willow';
            Index := 0;
            AliveIDs := AliveWillowIDs;
            DeadIds := DeadWillowIDs;
            Timer.Restart;
            Timer.StartTime := -1;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [75, 75, 200];
            TileOffset := [0, 2];
            Tile := Point(3085, 3235);
            Options := ['Chop down Willow'];
            Name := 'Willow';
            Index := 1;
            AliveIDs := AliveWillowIDs;
            DeadIds := DeadWillowIDs;
            Timer.Restart;
            Timer.StartTime := -1;
            Plane := 0;
          end;
          {with daLocation.TreeObjects[2] do begin
            Offset := [75, 75, 200];
            TileOffset := [0, 2];
            Tile := Point(3088, 3234);
            Options := ['Chop down Willow'];
            Name := 'Willow';
            Index := 2;
            AliveIDs := AliveWillowIDs;
            DeadIds := DeadWillowIDs;
            Timer.Restart;
            Timer.StartTime := -1;
            Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
            Offset := [75, 75, 200];
            TileOffset := [0, 2];
            Tile := Point(3087, 3231);
            Options := ['Chop down Willow'];
            Name := 'Willow';
            Index := 3;
            AliveIDs := AliveWillowIDs;
            DeadIds := DeadWillowIDs;
            Timer.Restart;
            Timer.StartTime := -1;
            Plane := 0;
          end;
          with daLocation.TreeObjects[4] do begin
            Offset := [75, 75, 200];
            TileOffset := [0, 2];
            Tile := Point(3088, 3227);
            Options := ['Chop down Willow'];
            Name := 'Willow';
            Index := 4;
            AliveIDs := AliveWillowIDs;
            DeadIds := DeadWillowIDs;
            Timer.Restart;
            Timer.StartTime := -1;
            Plane := 0;
          end; }
        end;
        10:begin
          daLocation.ID := 10;
          daLocation.Name := 'Draynor Yews';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1515;

          daLocation.isFar := true;

          daLocation.TreeLocations := [Point(3152, 3231)];

          daLocation.PathToBank := [Point(3152, 3229), Point(3147, 3229), Point(3142, 3229), Point(3137, 3229), Point(3132, 3229), Point(3127, 3228), Point(3122, 3228), Point(3117, 3228), Point(3112, 3230), Point(3108, 3234), Point(3104, 3238), Point(3105, 3243), Point(3104, 3248), Point(3099, 3250), Point(3094, 3248), Point(3093, 3243)];
          daLocation.PathToTree := [Point(3093, 3244), Point(3096, 3249), Point(3101, 3250), Point(3105, 3246), Point(3105, 3241), Point(3105, 3236), Point(3109, 3233), Point(3113, 3230), Point(3118, 3228), Point(3123, 3228), Point(3128, 3228), Point(3133, 3228), Point(3138, 3228), Point(3143, 3228), Point(3148, 3229)];

          setLength(daLocation.TreeObjects, 4)
          with daLocation.TreeObjects[0] do begin
           Offset := [0, 0, 250];
           TileOffset := [0, -2];
           Options := ['Chop down Yew'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Yew';
           Index := 0;
           Tile := Point(3147, 3255);
           AliveIDs := AliveYewIDs;
           DeadIDs := DeadYewIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
           Offset := [0, 0, 250];
           TileOffset := [0, 0];
           Options := ['Chop down Yew'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Yew';
           Index := 1;
           Tile := Point(3152, 3231);
           AliveIDs := AliveYewIDs;
           DeadIDs := DeadYewIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
           Offset := [0, 0, 250];
           TileOffset := [0, 0];
           Options := ['Chop down Yew'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Yew';
           Index := 2;
           Tile := Point(3166, 3220);
           AliveIDs := AliveYewIDs;
           DeadIDs := DeadYewIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
           Offset := [0, 0, 250];
           TileOffset := [-2, 0];
           Options := ['Chop down Yew'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Yew';
           Index := 3;
           Tile := Point(3185, 3227);
           AliveIDs := AliveYewIDs;
           DeadIDs := DeadYewIDs;
           Plane := 0;
          end;
        end;
      end;
    end;
    24..29:begin
      daLocation.canBank := true;
      setLength(daLocation.BankLocations, 1);
      with daLocation.BankLocations[0] do begin
        Offset := [0, 0, 50];
        TileOffset := [0, -2];
        Tile := Point(2727, 3494);
        Options := ['Bank Bank booth'];
        Plane := 0;
        Name := 'Bank';
      end;

      case job of
        24:begin
          daLocation.ID := 24;
          daLocation.Name := 'Seers Oaks';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1521;

          daLocation.TreeLocations := [Point(2731, 3485)];

          setLength(daLocation.TreeObjects, 1)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Oak';
            Index := 0;
            Tile := Point(2731, 3485);
            AliveIDs := AliveOakIDs;
            DeadIDs := DeadOakIDs;
            Plane := 0;
          end;
        end;
        25:begin
          daLocation.ID := 25;
          daLocation.Name := 'Seers Willows';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1519;

          daLocation.TreeLocations := [Point(2711, 3510)];

          setLength(daLocation.TreeObjects, 5)
          with daLocation.TreeObjects[0] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Willow';
           Index := 0;
           Tile := Point(2719, 3506);
           AliveIDs := AliveWillowIDs;
           DeadIDs := DeadWillowIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Willow';
           Index := 1;
           Tile := Point(2711, 3512);
           AliveIDs := AliveWillowIDs;
           DeadIDs := DeadWillowIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Willow';
           Index := 2;
           Tile := Point(2709, 3511);
           AliveIDs := AliveWillowIDs;
           DeadIDs := DeadWillowIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Willow';
           Index := 3;
           Tile := Point(2712, 3509);
           AliveIDs := AliveWillowIDs;
           DeadIDs := DeadWillowIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[4] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Willow';
           Index := 4;
           Tile := Point(2708, 3514);
           AliveIDs := AliveWillowIDs;
           DeadIDs := DeadWillowIDs;
           Plane := 0;
          end;
        end;
        26:begin
          daLocation.ID := 26;
          daLocation.Name := 'Seers Maples';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1517;

          daLocation.TreeLocations := [Point(2728, 3500)];

          daLocation.PathToBank := [Point(2725, 3501), Point(2720, 3499), Point(2718, 3494), Point(2720, 3489), Point(2724, 3486), Point(2725, 3491)];
          daLocation.PathToTree := [Point(2725, 3491), Point(2725, 3486), Point(2720, 3489), Point(2718, 3494), Point(2721, 3499), Point(2726, 3499)];

          setLength(daLocation.TreeObjects, 4)
          with daLocation.TreeObjects[0] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Maple';
           Index := 0;
           Tile := Point(2721, 3502);
           AliveIDs := AliveMapleIDs;
           DeadIDs := DeadMapleIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Maple';
           Index := 1;
           Tile := Point(2727, 3502);
           AliveIDs := AliveMapleIDs;
           DeadIDs := DeadMapleIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Maple';
           Index := 2;
           Tile := Point(2730, 3502);
           AliveIDs := AliveMapleIDs;
           DeadIDs := DeadMapleIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Maple';
           Index := 3;
           Tile := Point(2732, 3500);
           AliveIDs := AliveMapleIDs;
           DeadIDs := DeadMapleIDs;
           Plane := 0;
          end;
        end;
        27:begin
          daLocation.ID := 27;
          daLocation.Name := 'Seers Yews';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1515;

          daLocation.TreeLocations := [Point(2710, 3462)];

          daLocation.PathToBank := [Point(2714, 3462), Point(2718, 3465), Point(2719, 3470), Point(2723, 3474), Point(2725, 3479), Point(2724, 3484), Point(2725, 3489), Point(2725, 3491)];
          daLocation.PathToTree := [Point(2726, 3491), Point(2726, 3486), Point(2727, 3481), Point(2726, 3476), Point(2724, 3471), Point(2723, 3466), Point(2718, 3463), Point(2714, 3462)];

          setLength(daLocation.TreeObjects, 3)
          with daLocation.TreeObjects[0] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Yew';
           Index := 0;
           Tile := Point(2715, 3460);
           AliveIDs := AliveYewIds;
           DeadIDs := DeadYewIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Yew';
           Index := 1;
           Tile := Point(2706, 3460);
           AliveIDs := AliveYewIds;
           DeadIDs := DeadYewIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Yew';
           Index := 2;
           Tile := Point(2706, 3465);
           AliveIDs := AliveYewIds;
           DeadIDs := DeadYewIDs;
           Plane := 0;
          end;
        end;
        28:begin
          daLocation.ID := 28;
          daLocation.Name := 'Seers Magics';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1513;

          daLocation.TreeLocations := [Point(2693, 3425)];

          daLocation.PathToBank := [Point(2695, 3425), Point(2700, 3425), Point(2702, 3430), Point(2702, 3435), Point(2701, 3440), Point(2704, 3444), Point(2708, 3448), Point(2713, 3451), Point(2717, 3454), Point(2719, 3459), Point(2719, 3464), Point(2719, 3469), Point(2722, 3473), Point(2725, 3478), Point(2727, 3483), Point(2726, 3488), Point(2725, 3491)];
          daLocation.PathToTree := [Point(2726, 3490), Point(2726, 3485), Point(2727, 3480), Point(2727, 3475), Point(2727, 3470), Point(2728, 3465), Point(2727, 3460), Point(2725, 3455), Point(2721, 3452), Point(2721, 3447), Point(2719, 3442), Point(2714, 3440), Point(2713, 3435), Point(2711, 3430), Point(2707, 3426), Point(2702, 3425), Point(2697, 3425), Point(2693, 3424)];

          setLength(daLocation.TreeObjects, 3)
          with daLocation.TreeObjects[0] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Magic';
           Index := 0;
           Tile := Point(2692, 3425);
           AliveIDs := AliveMagicIDs;
           DeadIDs := DeadMagicIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Magic';
           Index := 1;
           Tile := Point(2691, 3428);
           AliveIDs := AliveMagicIDs;
           DeadIDs := DeadMagicIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Magic';
           Index := 2;
           Tile := Point(2696, 3424);
           AliveIDs := AliveMagicIDs;
           DeadIDs := DeadMagicIDs;
           Plane := 0;
          end;
        end;
        29:begin
          daLocation.ID := 29;
          daLocation.Name := 'Seers Magics(2)';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1513;

          daLocation.TreeLocations := [Point(2700, 3397)];

          daLocation.PathToBank := [Point(2701, 3396), Point(2704, 3392), Point(2709, 3392), Point(2714, 3393), Point(2714, 3398), Point(2716, 3403), Point(2715, 3408), Point(2715, 3413), Point(2714, 3418), Point(2714, 3423), Point(2713, 3428), Point(2713, 3433), Point(2713, 3438), Point(2710, 3442), Point(2712, 3447), Point(2717, 3449), Point(2720, 3453), Point(2720, 3458), Point(2720, 3463), Point(2720, 3468), Point(2722, 3473), Point(2725, 3478), Point(2727, 3483), Point(2726, 3488), Point(2726, 3491)];
          daLocation.PathToTree := [Point(2725, 3491), Point(2726, 3486), Point(2727, 3481), Point(2726, 3476), Point(2724, 3471), Point(2723, 3466), Point(2723, 3461), Point(2719, 3457), Point(2716, 3453), Point(2713, 3448), Point(2710, 3444), Point(2710, 3439), Point(2711, 3434), Point(2713, 3429), Point(2713, 3424), Point(2713, 3419), Point(2715, 3414), Point(2715, 3409), Point(2716, 3404), Point(2716, 3399), Point(2715, 3394), Point(2710, 3393), Point(2705, 3392), Point(2701, 3395), Point(2702, 3397)];

          setLength(daLocation.TreeObjects, 4)
          with daLocation.TreeObjects[0] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Magic';
           Index := 0;
           Tile := Point(2705, 3397);
           AliveIDs := AliveMagicIDs;
           DeadIDs := DeadMagicIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Magic';
           Index := 1;
           Tile := Point(2705, 3399);
           AliveIDs := AliveMagicIDs;
           DeadIDs := DeadMagicIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Magic';
           Index := 2;
           Tile := Point(2699, 3397);
           AliveIDs := AliveMagicIDs;
           DeadIDs := DeadMagicIDs;
           Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
           Offset := [0, 0, 200];
           TileOffset := [0, 0];
           Options := ['Chop down'];
           Timer.Restart;
           Timer.StartTime := -1;
           Name := 'Magic';
           Index := 3;
           Tile := Point(2699, 3399);
           AliveIDs := AliveMagicIDs;
           DeadIDs := DeadMagicIDs;
           Plane := 0;
          end;
        end;
      end;
    end;
    30..31:begin
      daLocation.canBank := true;
      setLength(daLocation.BankLocations, 1);
      with daLocation.BankLocations[0] do begin
        Offset := [0, 0, 50];
        TileOffset := [0, -2];
        Tile := Point(2809, 3442);
        Options := ['Bank Bank booth'];
        Plane := 0;
        Name := 'Bank';
      end;
      case job of
        30:begin
          daLocation.ID := 30;
          daLocation.Name := 'Catherby Willows';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1519;

          daLocation.TreeLocations := [Point(2783, 3428)];

          setLength(daLocation.TreeObjects, 5)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 0;
            Tile := Point(2786, 3430);
            AliveIDs := AliveWillowIDs;
            DeadIDs := DeadWillowIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 1;
            Tile := Point(2783, 3427);
            AliveIDs := AliveWillowIDs;
            DeadIDs := DeadWillowIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 2;
            Tile := Point(2781, 3428);
            AliveIDs := AliveWillowIDs;
            DeadIDs := DeadWillowIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 3;
            Tile := Point(2768, 3427);
            AliveIDs := AliveWillowIDs;
            DeadIDs := DeadWillowIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[4] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 4;
            Tile := Point(2771, 3428);
            AliveIDs := AliveWillowIDs;
            DeadIDs := DeadWillowIDs;
            Plane := 0;
          end;
        end;
        31:begin
          daLocation.ID := 31;
          daLocation.Name := 'Catherby Yews';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1515;

          daLocation.TreeLocations := [Point(2758, 3432)];

          daLocation.PathToBank := [Point(2760, 3430), Point(2765, 3430), Point(2770, 3431), Point(2775, 3433), Point(2780, 3435), Point(2785, 3432), Point(2790, 3432), Point(2795, 3433), Point(2800, 3433), Point(2805, 3433), Point(2808, 3437), Point(2809, 3439)];
          daLocation.PathToTree := [Point(2809, 3439), Point(2805, 3436), Point(2801, 3433), Point(2796, 3433), Point(2791, 3433), Point(2786, 3432), Point(2781, 3434), Point(2776, 3435), Point(2771, 3433), Point(2766, 3431), Point(2761, 3430), Point(2759, 3430)];

          setLength(daLocation.TreeObjects, 6)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 0;
            Tile := Point(2758, 3434);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 1;
            Tile := Point(2756, 3431);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 2;
            Tile := Point(2761, 3432);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 3;
            Tile := Point(2755, 3434);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[4] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 4;
            Tile := Point(2760, 3428);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[5] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 5;
            Tile := Point(2766, 3428);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
        end;
      end;
    end;
    19:begin
      daLocation.canBank := true;
      setLength(daLocation.BankLocations, 1);
      with daLocation.BankLocations[0] do begin
        Offset := [0, 0, 50];
        TileOffset := [-2, 0];
        Tile := Point(3186, 3436);
        Options := ['Bank Bank booth'];
        Plane := 0;
        Name := 'Bank';
      end;

      daLocation.ID := 19;
      daLocation.Name := 'Varrock Oaks (west)';

      daLocation.RunDirections := ['rand'];

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 1521;

      daLocation.PathToBank := [Point(3170, 3422), Point(3174, 3425), Point(3178, 3428), Point(3182, 3432), Point(3184, 3436)];
      daLocation.PathToTree := [Point(3184, 3436), Point(3181, 3432), Point(3177, 3429), Point(3173, 3426), Point(3170, 3421), Point(3170, 3423)];
      daLocation.TreeLocations := [Point(3170, 3422)];

      setLength(daLocation.TreeObjects, 3)
      with daLocation.TreeObjects[0] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Oak';
        Index := 0;
        Tile := Point(3168, 3421);
        AliveIDs := AliveOakIDs;
        DeadIDs := DeadOakIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[1] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Oak';
        Index := 1;
        Tile := Point(3166, 3412);
        AliveIDs := AliveOakIDs;
        DeadIDs := DeadOakIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[2] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Oak';
        Index := 2;
        Tile := Point(3162, 3417);
        AliveIDs := AliveOakIDs;
        DeadIDs := DeadOakIDs;
        Plane := 0;
      end;
    end;
    20:begin
      daLocation.Name := 'Varrock Yews (palace)';
      daLocation.ID := 20;

      daLocation.RunDirections := ['rand'];

      daLocation.canBank := true;
      setLength(daLocation.BankNPCs, 1);
      with daLocation.BankNPCs[0] do begin
        Locations := [Point(3167, 3489)];
        Names := [];
        Plane := 0;
        IDs := [5456, 5455, 5454, 5453];
        Options := ['Bank B'];
        Offset := [0, 0, 50];
      end;

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 1515;

      daLocation.TreeLocations := [Point(3207, 3502)];

      daLocation.PathToTree := [Point(3167, 3489), Point(3173, 3490), Point(3179, 3490), Point(3185, 3490), Point(3191, 3491), Point(3196, 3494), Point(3197, 3500), Point(3203, 3502), Point(3206, 3502)];
      daLocation.PathToBank := [Point(3206, 3502), Point(3200, 3502), Point(3195, 3499), Point(3192, 3494), Point(3187, 3491), Point(3181, 3491), Point(3175, 3491), Point(3169, 3491), Point(3167, 3489)];

      setLength(daLocation.TreeObjects, 3)
      with daLocation.TreeObjects[0] do begin
        Offset := [0, 0, 250];
        TileOffset := [2, -2];
        Options := ['Chop down Yew'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Yew';
        Index := 0;
        Tile := Point(3205, 3504);
        AliveIDs := AliveYewIDs;
        DeadIDs := DeadYewIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[1] do begin
        Offset := [0, 0, 250];
        TileOffset := [0, 2];
        Options := ['Chop down Yew'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Yew';
        Index := 1;
        Tile := Point(3209, 3500);
        AliveIDs := AliveYewIDs;
        DeadIDs := DeadYewIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[2] do begin
        Offset := [0, 0, 250];
        TileOffset := [-2, -2];
        Options := ['Chop down Yew'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Yew';
        Index := 2;
        Tile := Point(3222, 3503);
        AliveIDs := AliveYewIDs;
        DeadIDs := DeadYewIDs;
        Plane := 0;
      end;
    end;
    21..23:begin
      daLocation.canBank := true;

      setLength(daLocation.BankLocations, 1);
      with daLocation.BankLocations[0] do begin
        Offset := [0, 0, 50];
        TileOffset := [0, 0];
        Tile := Point(3254, 3419);
        Options := ['Bank B'];
        Plane := 0;
        Name := 'Bank';
      end;

      case job of
        21:begin
          daLocation.ID := 21;

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1521;

          daLocation.Name := 'Varrock East Oaks';

          daLocation.TreeLocations := [Point(3280, 3431)];

          setLength(daLocation.TreeObjects, 3)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Oak';
            Index := 0;
            Tile := Point(3280, 3431);
            AliveIDs := AliveOakIDs;
            DeadIDs := DeadOakIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Oak';
            Index := 1;
            Tile := Point(3282, 3425);
            AliveIDs := AliveOakIDs;
            DeadIDs := DeadOakIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Oak';
            Index := 2;
            Tile := Point(3277, 3437);
            AliveIDs := AliveOakIDs;
            DeadIDs := DeadOakIDs;
            Plane := 0;
          end;
        end;
        22:begin
          daLocation.ID := 22;

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1515;

          daLocation.Name := 'Varrock East Yews (pray)';

          daLocation.TreeLocations := [Point(3249, 3473)];

          setLength(daLocation.TreeObjects, 1)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 0;
            Tile := Point(3249, 3473);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
        end;
        23:begin
          daLocation.ID := 23;

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1515;

          daLocation.Name := 'Varrock East Yews';

          daLocation.TreeLocations := [Point(3271, 3471)];

          daLocation.isFar := true;

          setLength(daLocation.TreeObjects, 3)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 0;
            Tile := Point(3271, 3471);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 1;
            Tile := Point(3267, 3494);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 2;
            Tile := Point(3305, 3470);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
        end;
      end;
    end;
    16..17:begin
      daLocation.canBank := true;
      setLength(daLocation.BankLocations, 1);
      with daLocation.BankLocations[0] do begin
        Offset := [0, 0, 50];
        TileOffset := [0, 0];
        Tile := Point(3012, 3354);
        Options := ['Bank Bank booth'];
        Plane := 0;
        Name := 'Bank';
      end;

      case job of
        12:begin
          daLocation.ID := 16;
          daLocation.Name := 'Falador Oaks';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1521;

          daLocation.TreeLocations := [Point(3001, 3365)];

          setLength(daLocation.TreeObjects, 1)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Oak';
            Index := 0;
            Tile := Point(3001, 3367);
            AliveIDs := AliveOakIDs;
            DeadIDs := DeadOakIDs;
            Plane := 0;
          end;
        end;
        13:begin
          daLocation.ID := 17;
          daLocation.Name := 'Falador Yews';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1515;

          daLocation.isFar := true;

          daLocation.PathToBank := [Point(3006, 3317), Point(3006, 3322), Point(3006, 3327), Point(3006, 3332), Point(3006, 3337), Point(3006, 3342), Point(3006, 3347), Point(3006, 3352), Point(3006, 3357), Point(3011, 3359), Point(3013, 3357)];
          daLocation.PathToTree := [Point(3012, 3355), Point(3009, 3359), Point(3008, 3354), Point(3008, 3349), Point(3008, 3344), Point(3008, 3339), Point(3008, 3334), Point(3008, 3329), Point(3008, 3324), Point(3007, 3319), Point(3002, 3319), Point(2998, 3315), Point(2997, 3314)];
          daLocation.TreeLocations := [Point(2997, 3314)];

          setLength(daLocation.TreeObjects, 3)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 0;
            Tile := Point(2997, 3312);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 1;
            Tile := Point(3020, 3316);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 2;
            Tile := Point(3042, 3320);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
        end;
      end;
    end;
    11..12, 14:begin
      daLocation.canBank := true;
      setLength(daLocation.BankLocations, 1);
      with daLocation.BankLocations[0] do begin
        Offset := [0, 0, 50];
        TileOffset := [0, 0];
        Tile := Point(3045, 3234);
        Options := ['Deposit'];
        Plane := 0;
        Name := 'Bank';
      end;

      case job of
        11:begin
          daLocation.ID := 11;
          daLocation.Name := 'Port Sarim Willows';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1519;

          daLocation.PathToBank := [Point(3059, 3252), Point(3054, 3252), Point(3052, 3247), Point(3047, 3246), Point(3042, 3245), Point(3042, 3240), Point(3042, 3235), Point(3045, 3235)];
          daLocation.PathToTree := [Point(3045, 3235), Point(3042, 3239), Point(3042, 3244), Point(3047, 3246), Point(3052, 3247), Point(3054, 3252), Point(3059, 3253)];
          daLocation.TreeLocations := [Point(3059, 3252)];

          setLength(daLocation.TreeObjects, 4)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 0;
            Tile := Point(3057, 3255);
            AliveIDs := AliveWillowIDs;
            DeadIDs := DeadWillowIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 1;
            Tile := Point(3062, 3255);
            AliveIDs := AliveWillowIDs;
            DeadIDs := DeadWillowIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 2;
            Tile := Point(3063, 3253);
            AliveIDs := AliveWillowIDs;
            DeadIDs := DeadWillowIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 3;
            Tile := Point(3057, 3252);
            AliveIDs := AliveWillowIDs;
            DeadIDs := DeadWillowIDs;
            Plane := 0;
          end;
        end;
        14:begin
          daLocation.ID := 14;
          daLocation.Name := 'Rimmington Yews';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.BankLocations, 1);
          with daLocation.BankLocations[0] do begin
            Offset := [0, 0, 50];
            TileOffset := [0, 0];
            Tile := Point(3045, 3234);
            Options := ['Deposit'];
            Plane := 0;
            Name := 'Bank';
          end;

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1515;

          daLocation.PathToBank := [Point(2935, 3228), Point(2940, 3228), Point(2945, 3229), Point(2950, 3228), Point(2955, 3228), Point(2960, 3227), Point(2965, 3225), Point(2970, 3225), Point(2975, 3225), Point(2980, 3225), Point(2985, 3223), Point(2990, 3223), Point(2995, 3222), Point(3000, 3222), Point(3005, 3219), Point(3009, 3215), Point(3014, 3215), Point(3019, 3217), Point(3024, 3217), Point(3027, 3221), Point(3027, 3226), Point(3027, 3231), Point(3029, 3236), Point(3034, 3236), Point(3039, 3236), Point(3044, 3236), Point(3045, 3235)];
          daLocation.PathToTree := [Point(3045, 3235), Point(3040, 3236), Point(3035, 3236), Point(3030, 3236), Point(3028, 3231), Point(3028, 3226), Point(3028, 3221), Point(3024, 3218), Point(3019, 3218), Point(3014, 3216), Point(3009, 3215), Point(3004, 3215), Point(2999, 3214), Point(2994, 3214), Point(2989, 3213), Point(2984, 3213), Point(2979, 3211), Point(2975, 3214), Point(2971, 3217), Point(2966, 3217), Point(2961, 3217), Point(2956, 3217), Point(2951, 3219), Point(2946, 3220), Point(2943, 3224), Point(2939, 3228), Point(2938, 3229)];
          daLocation.TreeLocations := [Point(2938, 3229)];

          setLength(daLocation.TreeObjects, 4)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 0;
            Tile := Point(2936, 3230);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 1;
            Tile := Point(2941, 3233);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 2;
            Tile := Point(2934, 3234);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 3;
            Tile := Point(2935, 3226);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
        end;
        12:begin
          daLocation.ID := 12;
          daLocation.Name := 'Port Sarim Yews';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1515;

          daLocation.TreeLocations := [Point(3054, 3271)];

          setLength(daLocation.TreeObjects, 1)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 0;
            Tile := Point(3054, 3271);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
        end;
      end;
    end;
    13, 15:begin
      daLocation.canBank := true;
      setLength(daLocation.BankNPCs, 1);
      with daLocation.BankNPCs[0] do begin
        Locations := [Point(2949, 3215)];
        Names := [];
        Plane := 0;
        IDs := [516, 517];
        Options := ['Trade'];
        Offset := [0, 0, 50];
      end;
      daLocation.isSell := true;

      case job of
        13:begin
          daLocation.Name := 'Rimmington Willows (sell)';
          daLocation.ID := 13;

          daLocation.canFletch := true;
          daLocation.fletchPoint := Point(264, 413);

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1519;

          daLocation.TreeLocations := [Point(2962, 3198)];

          setLength(daLocation.TreeObjects, 4)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 0;
            Tile := Point(2962, 3198);
            AliveIDs := AliveWillowIDs;
            DeadIds := DeadWillowIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 1;
            Tile := Point(2963, 3195);
            AliveIDs := AliveWillowIDs;
            DeadIds := DeadWillowIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 2;
            Tile := Point(2966, 3199);
            AliveIDs := AliveWillowIDs;
            DeadIds := DeadWillowIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 3;
            Tile := Point(2961, 3195);
            AliveIDs := AliveWillowIDs;
            DeadIds := DeadWillowIDs;
            Plane := 0;
          end;
        end;
        15:begin
          daLocation.Name := 'Rimmington Yews (sell)';
          daLocation.ID := 15;

          daLocation.canFletch := true;
          daLocation.fletchPoint := Point(264, 413);

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1515;

          daLocation.TreeLocations := [Point(2938, 3229)];

          setLength(daLocation.TreeObjects, 4)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 0;
            Tile := Point(2936, 3230);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 1;
            Tile := Point(2941, 3233);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 2;
            Tile := Point(2934, 3234);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 3;
            Tile := Point(2935, 3226);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
        end;
      end;
    end;
    35:begin
      daLocation.ID := 35;
      daLocation.Name := 'Duel Arena Magics';

      daLocation.RunDirections := ['rand'];

      daLocation.canBank := true;

      setLength(daLocation.BankLocations, 1);
      with daLocation.BankLocations[0] do begin
        Offset := [0, 0, 50];
        TileOffset := [0, 0];
        Tile := Point(3381, 3269);
        Options := ['Open', 'Bank'];
        Plane := 0;
        Name := 'Bank';
      end;

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 1513;

      daLocation.treeLocations := [Point(3369, 3312)];
      daLocation.pathToTree := [Point(3381, 3268), Point(3386, 3265), Point(3388, 3271), Point(3385, 3276), Point(3384, 3282), Point(3382, 3288), Point(3379, 3293), Point(3373, 3293), Point(3367, 3293), Point(3363, 3295)];
      daLocation.pathToBank := [Point(3363, 3295), Point(3369, 3293), Point(3375, 3293), Point(3379, 3289), Point(3382, 3284), Point(3382, 3278), Point(3385, 3273), Point(3385, 3267), Point(3382, 3269)];

      setLength(daLocation.TreeObjects, 2);
      with daLocation.TreeObjects[0] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Magic';
        Index := 0;
        Tile := Point(3357, 3311);
        AliveIDs := AliveMagicIDs;
        DeadIDs := DeadMagicIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[1] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Magic';
        Index := 1;
        Tile := Point(3369, 3312);
        AliveIDs := AliveMagicIDs;
        DeadIDs := DeadMagicIDs;
        Plane := 0;
      end;
    end;
    18:begin
      daLocation.ID := 18;
      daLocation.Name := 'Edgeville Yews';

      daLocation.canBank := true;

      daLocation.RunDirections := ['rand'];

      setLength(daLocation.BankLocations, 1);
      with daLocation.BankLocations[0] do begin
        Offset := [0, 0, 50];
        TileOffset := [0, 0];
        Tile := Point(3095, 3491);
        Options := ['Bank B'];
        Plane := 0;
        Name := 'Bank';
      end;

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 1515;

      daLocation.PathToBank := [Point(3094, 3470), Point(3094, 3475), Point(3094, 3480), Point(3093, 3485), Point(3090, 3489), Point(3093, 3491)];
      daLocation.PathToTree := [Point(3093, 3491), Point(3090, 3487), Point(3093, 3483), Point(3093, 3478), Point(3094, 3473), Point(3093, 3470)];
      daLocation.TreeLocations := [Point(3087, 3471)];

      setLength(daLocation.DoorObjects, 1);
      with daLocation.DoorObjects[0] do begin
        Plane := 0;
        Tile := Point(3091, 3470);
        TileOffset := [0, 0];
        Actions := ['Open'];
        Offset := [62, 0, 100];
        TileEncompass := [Point(3091, 3468), Point(3085, 3468), Point(3085, 3482), Point(3089, 3482), Point(3089, 3473), Point(3091, 3473)];
      end;

      setLength(daLocation.TreeObjects, 2)
      with daLocation.TreeObjects[0] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 2];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Yew';
        Index := 0;
        Tile := Point(3086, 3469);
        AliveIDs := AliveYewIDs;
        DeadIDs := DeadYewIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[1] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, -2];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Yew';
        Index := 1;
        Tile := Point(3086, 3481);
        AliveIDs := AliveYewIDs;
        DeadIDs := DeadYewIDs;
        Plane := 0;
      end;
    end;
    34:begin
      daLocation.ID := 34;
      daLocation.Name := 'Barb. Assault Willows';

      daLocation.RunDirections := ['rand'];

      daLocation.canBank := true;
      setLength(daLocation.BankLocations, 1);
      with daLocation.BankLocations[0] do begin
        Offset := [0, 0, 50];
        TileOffset := [0, 0];
        Tile := Point(2537, 3573);
        Options := ['Bank'];
        Plane := 0;
        Name := 'Bank';
      end;

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 1519;

      daLocation.treeLocations := [Point(2520, 3579)];

      setLength(daLocation.TreeObjects, 5)
      with daLocation.TreeObjects[0] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 0;
        Tile := Point(2517, 3598);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[1] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 1;
        Tile := Point(2518, 3577);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[2] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 2;
        Tile := Point(2517, 3579);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[3] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 3;
        Tile := Point(2519, 3581);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[4] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 4;
        Tile := Point(2517, 3582);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
    end;
    32..33:begin
      daLocation.canBank := true;
      setLength(daLocation.BankLocations, 1);
      with daLocation.BankLocations[0] do begin
        Offset := [0, 0, 50];
        TileOffset := [0, 0];
        Tile := Point(2447, 3427);
        Options := ['Bank'];
        Plane := 0;
        Name := 'Bank';
      end;
      setLength(daLocation.customTPAs, 1);
      daLocation.customTPAs[0] := [Point(2445, 3435){plane 0 stairs}, Point(2445, 3434){plane 1 stairs}];

      case job of
        32:begin
          daLocation.ID := 32;
          daLocation.Name := 'Gnome Yews';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1515;

          daLocation.TreeLocations := [Point(2441, 3435)];

          setLength(daLocation.TreeObjects, 3)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 2;
            Tile := Point(2433, 3426);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 0;
            Tile := Point(2439, 3436);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 1;
            Tile := Point(2433, 3441);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
        end;
        33:begin
          daLocation.ID := 33;
          daLocation.Name := 'Gnome Yews (2)';

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1515;

          daLocation.TreeLocations := [Point(2494, 3395)];

          setLength(daLocation.TreeObjects, 4)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 2;
            Tile := Point(2493, 3401);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 0;
            Tile := Point(2494, 3395);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 1;
            Tile := Point(2479, 3393);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 3;
            Tile := Point(2489, 3394);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
        end;
      end;
    end;
    44:begin
      //11764   2490 3414
      //11764   2372 3426     gate closed 2380 3425
      writeln('Gnome Magics are not yet completed.');
    end;
    5:begin
      daLocation.ID := 5;
      daLocation.Name := 'Lumbridge Yews';

      daLocation.canBank := true;

      daLocation.RunDirections := ['rand'];

      setLength(daLocation.BankLocations, 1);
      with daLocation.BankLocations[0] do begin
        Offset := [0, 0, 50];
        TileOffset := [0, 0];
        Tile := Point(3208, 3221);
        Options := ['Bank B'];
        Plane := 2;
        Name := 'Bank';
      end;

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 1515;

      daLocation.TreeLocations := [Point(3248, 3202)];
      daLocation.PathToBank := [Point(3248, 3202), Point(3243, 3201), Point(3238, 3201), Point(3236, 3206), Point(3236, 3211), Point(3234, 3216), Point(3229, 3218), Point(3224, 3218), Point(3219, 3218), Point(3215, 3215), Point(3214, 3210), Point(3209, 3210), Point(3206, 3209)];
      daLocation.PathToTree := [Point(3206, 3210), Point(3211, 3210), Point(3215, 3213), Point(3215, 3218), Point(3220, 3218), Point(3225, 3218), Point(3230, 3218), Point(3232, 3213), Point(3234, 3208), Point(3236, 3203), Point(3241, 3201), Point(3246, 3201), Point(3248, 3201)];
      setLength(daLocation.customTPAs, 1);
      daLocation.customTPAs[0] := [Point(3205, 3208){'Climb-'}];

      setLength(daLocation.TreeObjects, 1)
      with daLocation.TreeObjects[0] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Yew';
        Index := 0;
        Tile := Point(3250, 3202);
        AliveIDs := AliveYewIDs;
        DeadIDs := DeadYewIDs;
        Plane := 0;
      end;
    end;
    4:begin
      daLocation.ID := 4;
      daLocation.Name := 'North Lum. Willows';

      daLocation.RunDirections := ['rand'];

      daLocation.TreeLocations := [Point(3222, 3306)];

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 1519;

      daLocation.canFire := true;

      setLength(daLocation.FireLanes, 3);
      with daLocation.FireLanes[0] do begin
        Plane := 0;
        Length := 23;
        Tile := Point(3243, 3307);
      end;
      with daLocation.FireLanes[1] do begin
        Plane := 0;
        Length := 18;
        Tile := Point(3244, 3308);
      end;
      with daLocation.FireLanes[2] do begin
        Plane := 0;
        Length := 17;
        Tile := Point(3245, 3309);
      end;

      setLength(daLocation.TreeObjects, 3)
      with daLocation.TreeObjects[0] do begin
        Offset := [100, -100, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 0;
        Tile := Point(3220, 3306);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[1] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 1;
        Tile := Point(3221, 3308);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[2] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 2;
        Tile := Point(3222, 3302);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
    end;
    3:begin
      daLocation.ID := 3;
      daLocation.Name := 'West Lum. Willows(2)';

      daLocation.RunDirections := ['rand'];

      daLocation.TreeLocations := [Point(3176, 3272)];

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 1519;

      daLocation.canFire := true;

      setLength(daLocation.FireLanes, 2);
      with daLocation.FireLanes[0] do begin
        Plane := 0;
        Length := 26;
        Tile := Point(3180, 3263);
      end;
      with daLocation.FireLanes[1] do begin
        Plane := 0;
        Length := 14;
        Tile := Point(3172, 3262);
      end;

      setLength(daLocation.TreeObjects, 4)
      with daLocation.TreeObjects[0] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 0;
        Tile := Point(3167, 3273);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[1] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 1;
        Tile := Point(3164, 3271);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[2] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 2;
        Tile := Point(3162, 3268);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[3] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 3;
        Tile := Point(3165, 3266);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
    end;
    2:begin
      daLocation.ID := 2;
      daLocation.Name := 'West Lum. Willows';

      daLocation.RunDirections := ['rand'];

      daLocation.TreeLocations := [Point(3176, 3272)];

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 1519;

      daLocation.canFire := true;

      setLength(daLocation.FireLanes, 3);
      with daLocation.FireLanes[0] do begin
        Plane := 0;
        Length := 25;
        Tile := Point(3183, 3276);
      end;
      with daLocation.FireLanes[1] do begin
        Plane := 0;
        Length := 17;
        Tile := Point(3183, 3277);
      end;
      with daLocation.FireLanes[2] do begin
        Plane := 0;
        Length := 13;
        Tile := Point(3171, 3275);
      end;

      setLength(daLocation.TreeObjects, 2)
      with daLocation.TreeObjects[0] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 0;
        Tile := Point(3178, 3274);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
      with daLocation.TreeObjects[1] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Willow';
        Index := 1;
        Tile := Point(3179, 3271);
        AliveIDs := AliveWillowIDs;
        DeadIds := DeadWillowIDs;
        Plane := 0;
      end;
    end;
    0..1, 6:begin
      daLocation.canBank := true;
      setLength(daLocation.BankNPCs, 1);
      with daLocation.BankNPCs[0] do begin
        Locations := [Point(3212, 3246)];
        Names := [];
        Plane := 0;
        IDs := [507, 506];
        Offset := [0, 0, 50];
        Options := ['Trade'];
      end;
      daLocation.isSell := true;

      setLength(daLocation.DoorObjects, 1);
      with daLocation.DoorObjects[0] do begin
        TileOffset := [0, 0];
        Plane := 0;
        Actions := ['Open'];
        Tile := Point(3215, 3245);
        Offset := [-62, 0, 100];
        TileEncompass := [Point(3208, 3244), Point(3210, 3242), Point(3212, 3242), Point(3214, 3244), Point(3214, 3249), Point(3212, 3251), Point(3210, 3251), Point(3208, 3249)];
      end;

      case job of
        0:begin
          daLocation.Name := 'Lumbridge Oaks (sell)';
          daLocation.ID := 0;

          daLocation.canFletch := true;
          daLocation.fletchPoint := Point(264, 413);
          daLocation.TreeLocations := [Point(3206, 3242)];

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1521;

          setLength(daLocation.TreeObjects, 2)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, -2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Oak';
            Index := 0;
            Tile := Point(3204, 3247);
            AliveIDs := AliveOakIDs;
            DeadIDs := DeadOakIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Oak';
            Index := 1;
            Tile := Point(3205, 3240);
            AliveIDs := AliveOakIDs;
            DeadIDs := DeadOakIDs;
            Plane := 0;
          end;
        end;
        1:begin
          daLocation.Name := 'Lumbridge Willows (sell)';
          daLocation.ID := 1;

          daLocation.canFletch := true;
          daLocation.fletchPoint := Point(264, 413);

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1519;

          daLocation.TreeLocations := [Point(3234, 3242)];

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.TreeObjects, 2)
          with daLocation.TreeObjects[0] do begin
            Offset := [62, 62, 200];
            TileOffset := [0, 2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 0;
            Tile := Point(3234, 3238);
            AliveIDs := AliveWillowIDs;
            DeadIds := DeadWillowIDs;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [-62, 62, 200];
            TileOffset := [-1, -1];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Willow';
            Index := 1;
            Tile := Point(3234, 3244);
            AliveIDs := AliveWillowIDs;
            DeadIds := DeadWillowIDs;
            Plane := 0;
          end;
        end;
        6:begin
          daLocation.Name := 'Lumbridge Yews (sell)';
          daLocation.ID := 6;

          daLocation.canFletch := true;
          daLocation.fletchPoint := Point(264, 413);
          daLocation.TreeLocations := [Point(3234, 3244)];

          daLocation.RunDirections := ['rand'];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1515;

          setLength(daLocation.TreeObjects, 1)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 0;
            Tile := Point(3250, 3202);
            AliveIDs := AliveYewIDs;
            DeadIDs := DeadYewIDs;
            Plane := 0;
          end;
        end;
      end;
    end;
    36:begin
      daLocation.ID := 36;
      daLocation.Name := 'Ape Atoll Teaks';

      daLocation.RunDirections := ['rand'];

      daLocation.TreeLocations := [Point(2774, 2698)];

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 6333;

      setLength(daLocation.TreeObjects, 3)
      with daLocation.TreeObjects[0] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Teak';
        Index := 0;
        Tile := Point(2773, 2698);
        AliveIDs := [9036];
        DeadIDs := [9036];
        Plane := 0;
      end;
      with daLocation.TreeObjects[1] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Teak';
        Index := 1;
        Tile := Point(2776, 2698);
        AliveIDs := [9036];
        DeadIDs := [9036];
        Plane := 0;
      end;
      with daLocation.TreeObjects[2] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Teak';
        Index := 2;
        Tile := Point(2773, 2700);
        AliveIDs := [9036];
        DeadIDs := [9036];
        Plane := 0;
      end;
    end;
    37:begin
      daLocation.ID := 37;
      daLocation.Name := 'Castle Wars Teaks';

      daLocation.RunDirections := ['rand'];

      daLocation.TreeLocations := [Point(2334, 3048)];

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 6333;

      daLocation.canFire := true;
      setLength(daLocation.FireLanes, 6);
      with daLocation.FireLanes[0] do begin
        Plane := 0;
        Length := 4;
        Tile := Point(2333, 3051);
      end;
      with daLocation.FireLanes[1] do begin
        Plane := 0;
        Length := 4;
        Tile := Point(2333, 3050);
      end;
      with daLocation.FireLanes[2] do begin
        Plane := 0;
        Length := 6;
        Tile := Point(2336, 3049);
      end;
      with daLocation.FireLanes[3] do begin
        Plane := 0;
        Length := 4;
        Tile :=Point(2334, 3048);
      end;
      with daLocation.FireLanes[4] do begin
        Plane := 0;
        Length := 5;
        Tile := Point(2335, 3047);
      end;
      with daLocation.FireLanes[5] do begin
        Plane := 0;
        Length := 4;
        Tile := Point(2335, 3046);
      end;

      setLength(daLocation.TreeObjects, 1)
      with daLocation.TreeObjects[0] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Teak';
        Index := 0;
        Tile := Point(2335, 3048);
        AliveIDs := [9036];
        DeadIDs := [9037];
        Plane := 0;
      end;
    end;
    38:begin
      daLocation.ID := 38;
      daLocation.Name := 'Tai Bwo Wannai Teaks';

      daLocation.RunDirections := ['rand'];

      daLocation.TreeLocations := [Point(2827, 3081)];

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 6333;

      setLength(daLocation.TreeObjects, 4)
      with daLocation.TreeObjects[0] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Teak';
        Index := 1;
        Tile := Point(2827, 3080);
        AliveIDs := [9036];
        DeadIDs := [9037];
        Plane := 0;
      end;
      with daLocation.TreeObjects[1] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Teak';
        Index := 2;
        Tile := Point(2828, 3082);
        AliveIDs := [9036];
        DeadIDs := [9037];
        Plane := 0;
      end;
      with daLocation.TreeObjects[2] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Teak';
        Index := 0;
        Tile := Point(2828, 3079);
        AliveIDs := [9036];
        DeadIDs := [9037];
        Plane := 0;
      end;
      with daLocation.TreeObjects[3] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Teak';
        Index := 3;
        Tile := Point(2822, 3078);
        AliveIDs := [9036];
        DeadIDs := [9037];
        Plane := 0;
      end;
    end;
    39:begin
      daLocation.ID := 39;
      daLocation.Name := 'Tai Bwo Wannai Teaks(2)';

      daLocation.RunDirections := ['rand'];

      daLocation.TreeLocations := [Point(2826, 3086)];

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 6333;

      setLength(daLocation.TreeObjects, 5)
      with daLocation.TreeObjects[0] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Teak';
        Index := 0;
        Tile := Point(2823, 3088);
        AliveIDs := [9036];
        DeadIDs := [9037];
        Plane := 0;
      end;
      with daLocation.TreeObjects[1] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Teak';
        Index := 1;
        Tile := Point(2825, 3087);
        AliveIDs := [9036];
        DeadIDs := [9037];
        Plane := 0;
      end;
      with daLocation.TreeObjects[2] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Teak';
        Index := 2;
        Tile := Point(2827, 3088);
        AliveIDs := [9036];
        DeadIDs := [9037];
        Plane := 0;
      end;
      with daLocation.TreeObjects[3] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Teak';
        Index := 3;
        Tile := Point(2827, 3085);
        AliveIDs := [9036];
        DeadIDs := [9037];
        Plane := 0;
      end;
      with daLocation.TreeObjects[4] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Teak';
        Index := 4;
        Tile := Point(2826, 3084);
        AliveIDs := [9036];
        DeadIDs := [9037];
        Plane := 0;
      end;
    end;
    40:begin
      daLocation.ID := 40;
      daLocation.Name := 'Tai Bwo Wannai Mahogany';

      daLocation.RunDirections := ['rand'];

      daLocation.TreeLocations := [Point(2824, 3084)];

      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 6332;

      setLength(daLocation.TreeObjects, 4)
      with daLocation.TreeObjects[0] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Mahogany';
        Index := 0;
        Tile := Point(2822, 3084);
        AliveIDs := [9034];
        DeadIDs := [9035];
        Plane := 0;
      end;
      with daLocation.TreeObjects[1] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Mahogany';
        Index := 1;
        Tile := Point(2820, 3088);
        AliveIDs := [9034];
        DeadIDs := [9035];
        Plane := 0;
      end;
      with daLocation.TreeObjects[2] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Mahogany';
        Index := 2;
        Tile := Point(2820, 3080);
        AliveIDs := [9034];
        DeadIDs := [9035];
        Plane := 0;
      end;
      with daLocation.TreeObjects[3] do begin
        Offset := [0, 0, 200];
        TileOffset := [0, 0];
        Options := ['Chop down'];
        Timer.Restart;
        Timer.StartTime := -1;
        Name := 'Mahogany';
        Index := 3;
        Tile := Point(2824, 3080);
        AliveIDs := [9034];
        DeadIDs := [9035];
        Plane := 0;
      end;
    end;
    41:begin
      daLocation.ID := 41;
      setLength(daLocation.customIDs, 1);
      daLocation.customIDs[0] := [1278, 1276, 1286, 1282, 2091, 2092];
      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 1511;
      daLocation.canFletch := true;
      daLocation.name := 'Powerchop Normals';
      daLocation.fletchPoint := Point(79, 411);

      daLocation.isPower := true;
    end;
    42:begin
      daLocation.ID := 42;
      setLength(daLocation.customIDs, 1);
      daLocation.customIDs[0] := [7417];
      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 1521;
      daLocation.canFletch := true;
      daLocation.name := 'Powerchop Oaks';
      daLocation.fletchPoint := Point(264, 413);

      daLocation.isPower := true;
    end;
    43:begin
      daLocation.ID := 43;
      setLength(daLocation.customIDs, 1);
      daLocation.customIDs[0] := [7480, 7422, 7482, 7424];
      setLength(daLocation.Logs, 1);
      daLocation.Logs[0].ID := 1519;
      daLocation.canFletch := true;
      daLocation.name := 'Powerchop Willows';
      daLocation.fletchPoint := Point(264, 413);

      daLocation.isPower := true;
    end;
    7:begin
      setLength(daLocation.Logs, 3);
      daLocation.Logs[0].ID := 1511;
      daLocation.Logs[1].ID := 1521;
      daLocation.Logs[2].ID := 1519;

      daLocation.Name := 'Progressive Chopping';
      daLocation.isDynamic := true;
    end;
    45..50:begin
      daLocation.canBank := true;
      setLength(daLocation.BankLocations, 1);
      with daLocation.BankLocations[0] do begin
        Offset := [0, 0, 50];
        TileOffset := [0, 0];
        Tile := Point(1592, 3475);
        Options := ['Bank'];
        Plane := 0;
        Name := 'Bank';
      end;

      case job of
        45:begin
          daLocation.ID := 45;
          daLocation.Name := 'WC Guild Yews';

          daLocation.RunDirections := ['rand'];

          daLocation.TreeLocations := [Point(1593, 3487)];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1515;

          setLength(daLocation.TreeObjects, 9)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [2, 0];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 0;
            Tile := Point(1591, 3487);
            AliveIDs := AliveYewIds;
            DeadIDs := DeadYewIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, -2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 1;
            Tile := Point(1596, 3490);
            AliveIDs := AliveYewIds;
            DeadIDs := DeadYewIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 2;
            Tile := Point(1596, 3485);
            AliveIDs := AliveYewIds;
            DeadIDs := DeadYewIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, -2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 3;
            Tile := Point(1591, 3493);
            AliveIDs := AliveYewIds;
            DeadIDs := DeadYewIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[4] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, -2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 4;
            Tile := Point(1596, 3495);
            AliveIDs := AliveYewIds;
            DeadIDs := DeadYewIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[5] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, 2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 5;
            Tile := Point(1586, 3480);
            AliveIDs := AliveYewIds;
            DeadIDs := DeadYewIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[6] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, -2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 6;
            Tile := Point(1584, 3485);
            AliveIDs := AliveYewIds;
            DeadIDs := DeadYewIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[7] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, -2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 7;
            Tile := Point(1587, 3501);
            AliveIDs := AliveYewIds;
            DeadIDs := DeadYewIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[8] do begin
            Offset := [0, 0, 200];
            TileOffset := [0, -2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Yew';
            Index := 7;
            Tile := Point(1582, 3497);
            AliveIDs := AliveYewIds;
            DeadIDs := DeadYewIds;
            Plane := 0;
          end;
        end;
        46:begin
          daLocation.ID := 46;
          daLocation.Name := 'WC Guild Magics';

          daLocation.RunDirections := ['rand'];

          daLocation.TreeLocations := [Point(1579, 3485)];

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 1517;

          setLength(daLocation.TreeObjects, 8)
          with daLocation.TreeObjects[0] do begin
            Offset := [62, 62, 200];
            TileOffset := [2, -1];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Magic';
            Index := 0;
            Tile := Point(1577, 3485);
            AliveIDs := AliveMagicIds;
            DeadIDs := DeadMagicIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [62, 62, 200];
            TileOffset := [-1, -1];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Magic';
            Index := 1;
            Tile := Point(1580, 3485);
            AliveIDs := AliveMagicIds;
            DeadIDs := DeadMagicIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[2] do begin
            Offset := [62, 62, 200];
            TileOffset := [2, 2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Magic';
            Index := 2;
            Tile := Point(1577, 3482);
            AliveIDs := AliveMagicIds;
            DeadIDs := DeadMagicIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[3] do begin
            Offset := [62, 62, 200];
            TileOffset := [-1, 2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Magic';
            Index := 3;
            Tile := Point(1580, 3482);
            AliveIDs := AliveMagicIds;
            DeadIDs := DeadMagicIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[4] do begin
            Offset := [62, 62, 200];
            TileOffset := [2, 2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Magic';
            Index := 4;
            Tile := Point(1577, 3489);
            AliveIDs := AliveMagicIds;
            DeadIDs := DeadMagicIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[5] do begin
            Offset := [62, 62, 200];
            TileOffset := [-1, 2];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Magic';
            Index := 5;
            Tile := Point(1580, 3489);
            AliveIDs := AliveMagicIds;
            DeadIDs := DeadMagicIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[6] do begin
            Offset := [62, 62, 200];
            TileOffset := [2, -1];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Magic';
            Index := 6;
            Tile := Point(1577, 3492);
            AliveIDs := AliveMagicIds;
            DeadIDs := DeadMagicIds;
            Plane := 0;
          end;
          with daLocation.TreeObjects[7] do begin
            Offset := [62, 62, 200];
            TileOffset := [-1, -1];
            Options := ['Chop down'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Magic';
            Index := 7;
            Tile := Point(1580, 3492);
            AliveIDs := AliveMagicIds;
            DeadIDs := DeadMagicIds;
            Plane := 0;
          end;
        end;
        47:begin
          daLocation.ID := 47;
          daLocation.Name := 'WC Guild Redwood';

          daLocation.RunDirections := ['rand'];

          daLocation.TreeLocations := [Point(1567, 3483)];

          setLength(daLocation.customTPAs, 1);
          daLocation.customTPAs[0] := [Point(1566, 3482)]; //ladder

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 19669;

          setLength(daLocation.TreeObjects, 2)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [-1, 0];
            Options := ['Cut'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Redwood';
            Index := 0;
            Tile := Point(1568, 3482);
            AliveIDs := [28859];
            DeadIDs := [28860];
            Plane := 2;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [-1, 0];
            Options := ['Cut'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Redwood';
            Index := 1;
            Tile := Point(1568, 3483);
            AliveIDs := [28859];
            DeadIDs := [28860];
            Plane := 2;
          end;
        end;
        48:begin
          daLocation.ID := 48;
          daLocation.Name := 'WC Guild Redwood(2)';

          daLocation.RunDirections := ['rand'];

          daLocation.TreeLocations := [Point(1567, 3493)];

          setLength(daLocation.customTPAs, 1);
          daLocation.customTPAs[0] := [Point(1566, 3493)]; //ladder

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 19669;

          setLength(daLocation.TreeObjects, 2)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [-1, 0];
            Options := ['Cut'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Redwood';
            Index := 0;
            Tile := Point(1568, 3493);
            AliveIDs := [28859];
            DeadIDs := [28860];
            Plane := 2;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [-1, 0];
            Options := ['Cut'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Redwood';
            Index := 1;
            Tile := Point(1568, 3492);
            AliveIDs := [28859];
            DeadIDs := [28860];
            Plane := 2;
          end;
        end;
        49:begin
          daLocation.ID := 49;
          daLocation.Name := 'WC Guild Redwood(3)';

          daLocation.RunDirections := ['rand'];

          daLocation.TreeLocations := [Point(1574, 3482)];

          setLength(daLocation.customTPAs, 1);
          daLocation.customTPAs[0] := [Point(1575, 3482)]; //ladder

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 19669;

          setLength(daLocation.TreeObjects, 2)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [-1, 0];
            Options := ['Cut'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Redwood';
            Index := 0;
            Tile := Point(1573, 3482);
            AliveIDs := [28859];
            DeadIDs := [28860];
            Plane := 2;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [-1, 0];
            Options := ['Cut'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Redwood';
            Index := 1;
            Tile := Point(1573, 3483);
            AliveIDs := [28859];
            DeadIDs := [28860];
            Plane := 2;
          end;
        end;
        50:begin
          daLocation.ID := 50;
          daLocation.Name := 'WC Guild Redwood(4)';

          daLocation.RunDirections := ['rand'];

          daLocation.TreeLocations := [Point(1574, 3493)];

          setLength(daLocation.customTPAs, 1);
          daLocation.customTPAs[0] := [Point(1575, 3493)]; //ladder

          setLength(daLocation.Logs, 1);
          daLocation.Logs[0].ID := 19669;

          setLength(daLocation.TreeObjects, 2)
          with daLocation.TreeObjects[0] do begin
            Offset := [0, 0, 200];
            TileOffset := [-1, 0];
            Options := ['Cut'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Redwood';
            Index := 0;
            Tile := Point(1573, 3492);
            AliveIDs := [28859];
            DeadIDs := [28860];
            Plane := 2;
          end;
          with daLocation.TreeObjects[1] do begin
            Offset := [0, 0, 200];
            TileOffset := [-1, 0];
            Options := ['Cut'];
            Timer.Restart;
            Timer.StartTime := -1;
            Name := 'Redwood';
            Index := 1;
            Tile := Point(1573, 3493);
            AliveIDs := [28859];
            DeadIDs := [28860];
            Plane := 2;
          end;
        end;
      end;
    end;
  end;

  for i:=0 to high(DaLocation.Logs) do begin
    daLocation.Logs[i].chopped := 0;
    daLocation.Logs[i].price := getPriceGE(daLocation.Logs[i].ID);
  end;

  for i:=0 to 1000 do begin
    if(not FileExists(ScriptPath+'ineedbot''s AIO Woodcutter proggy '+toStr(i)+'.png'))then begin
      ProggieLocation := ScriptPath+'ineedbot''s AIO Woodcutter proggy '+toStr(i)+'.png';
      break;
    end;
  end;
  doProggy(ProggieLocation);

  if disableBank then
    daLocation.canBank := false;

  if daLocation.canfire and not Reflect.Inv.Contains(TinderIds) then
    daLocation.canfire := false;

  if daLocation.canfletch and not Reflect.Inv.Contains(KnifeIDs) then
    daLocation.canfletch := false;
end;

procedure FreeDTMZ;
begin
  graphicOpti.Free;
  daLogger.Status('Thanks for using ineedbot''s AIO Woodcutter v'+FloatToStr(Version)+'('+floatToStr(fversion)+')'+'! Please post your progress reports! Run time: '+Reflect.Time.msToTime(getTimeRunning(), TIME_FORMAL), []);
  if useStats then
    if statsServer.Commit then
      daLogger.Status('Successfully sent heartbeat to ''stats.grats.pw''.', []);
end;

procedure setupPlayer;
begin
  Reflect.Compass.Make('n');
  Reflect.Compass.MakePitch(10);
  LastXPCheck.restart;
end;

procedure _doCount(howManyToCount:integer);
var _items : TReflectInvItemArray;
    i, h, count: integer;
begin
  count := 0;
  statsServer.IncreaseVariable('43', 1);
  _items.GetAll;
  for i:=0 to high(_items) do begin
    for h:=0 to high(daLocation.Logs) do
      if (_items[i].GetID = daLocation.Logs[h].ID) and (count < howManyToCount) then begin
        inc(count);
        inc(daLocation.Logs[h].chopped);

        if (pos('logs', lowercase(_items[i].getName)) > 0) then begin
          if (pos('oak', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('30', 1)
          else if (pos('willow', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('31', 1)
          else if (pos('maple', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('32', 1)
          else if (pos('yew', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('33', 1)
          else if (pos('magic', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('34', 1)
          else if (pos('teak', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('131', 1)
          else if (pos('arctic pine', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('136', 1)
          else if (pos('mahogany', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('133', 1)
          else
             statsServer.IncreaseVariable('29', 1);
        end;
        if (pos('logs', lowercase(_items[i].getName)) > 0) then begin
          if (pos('oak', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('24', 1)
          else if (pos('willow', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('25', 1)
          else if (pos('maple', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('26', 1)
          else if (pos('yew', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('27', 1)
          else if (pos('magic', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('28', 1)
          else if (pos('teak', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('132', 1)
          else if (pos('arctic pine', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('135', 1)
          else if (pos('mahogany', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('134', 1)
          else
            statsServer.IncreaseVariable('23', 1);
        end;
      end;
  end;
end;

procedure doCount;
var _items : TReflectInvItemArray;
    i, h : integer;
begin
  statsServer.IncreaseVariable('43', 1);
  _items.GetAll;
  for i:=0 to high(_items) do begin
    for h:=0 to high(daLocation.Logs) do
      if (_items[i].GetID = daLocation.Logs[h].ID) then begin
        inc(daLocation.Logs[h].chopped);
        if (pos('logs', lowercase(_items[i].getName)) > 0) then begin
          if (pos('oak', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('30', 1)
          else if (pos('willow', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('31', 1)
          else if (pos('maple', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('32', 1)
          else if (pos('yew', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('33', 1)
          else if (pos('magic', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('34', 1)
          else if (pos('teak', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('131', 1)
          else if (pos('arctic pine', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('136', 1)
          else if (pos('mahogany', lowercase(_items[i].getName)) > 0) then
            statsServer.IncreaseVariable('133', 1)
          else
             statsServer.IncreaseVariable('29', 1);
        end;
      end;
  end;
end;

procedure doDropping(forced:boolean=false);
var _items : TReflectInvItemArray;
    i, _id, _slot : integer;
    tB : TBox;
    tP : TPoint;
    firstTim, didFirstInRow : boolean;
    logIDs, dropPattern : TIntegerArray;
begin
  if not forced then
    doCount;
  updateScreen('Dropping items.');
  doProggy(ProggieLocation);
  firstTim := true;
  logIDs := daLocation.getLogIDs;
  exitMenu;
  dropPattern := [1, 5, 9, 13, 17, 21, 25, 2, 6, 10, 14, 18, 22, 26, 3, 7, 11, 15, 19, 23, 27, 4, 8, 12, 16, 20, 24, 28];
  while ReflectPlayer.isLoggedIn and (firstTim or Reflect.Inv.Contains(logIDs))
  and not ReflectPlayer.IsUnderAttack and not anySlotActivated do begin
    updateScreen('Dropping items.');
    if Reflect.Gametab.CurrentColor <> Gametab_Inventory then
      Reflect.Gametab.Open(Gametab_Inventory);
    randomHandler;
    _items.GetAll(true);
    for i:=0 to high(dropPattern) do begin
      if not ReflectPlayer.isLoggedIn then
        break;
      if ReflectPlayer.IsUnderAttack then
        break;
      if anySlotActivated then
        break;

      _slot := dropPattern[i]-1;

      case _slot of
        0..3: didFirstInRow := false;
      end;

      _id := _items[_slot].getid;
      if _id <= 0 then
        continue;
      if not itemInSlot(_items[_slot].getinvslot) then
        continue;

      if dropOnly then begin
        if not inIntArray(logIDs, _id) then
          continue;
      end else begin
        if inIntArray(KnifeIDs, _id) then
          continue;
        if inIntArray(ShaftIDs, _id) then
          continue;
        if inIntArray(NestIDs, _id) then
          continue;
        if inIntArray(KnifeIDs, _id) then
          continue;
        if inIntArray(GreeGreeIDs, _id) then
          continue;
        if inIntArray(TradingSticksIDs, _id) then
          continue;
        if inIntArray(TinderIDs, _id) then
          continue;
        if inIntArray(CoinsIDs, _id) then
          continue;
        if inIntArray(AxeIDs, _id) then
          continue;
      end;

      tB := _items[_slot].GetBox;
      getMousePos(tP.x, tP.y);

      if not MouseKeys then begin
        if not PointInBox(tP, tB) then
          Reflect.Mouse.Move(tB);
        fastClick(Mouse_right);
        Reflect.Text.ChooseOption('Drop', 2500);
      end else begin
        if not didFirstInRow then begin
          didFirstInRow := true;
          if not PointInBox(tP, tB) then begin
            Reflect.Mouse.Move(tB);
            getMousePos(tP.x, tP.y);
          end;
        end;

        if not PointInBox(tP, tB) then
          MoveMouse(Reflect.Math.iGaussRange(tb.X1, tb.X2), Reflect.Math.iGaussRange(tb.y1, tb.y2));

        fastClick(Mouse_right);
        Reflect.Text.chooseOptionFast('Drop');
      end;
    end;
    firstTim := false;
  end;
end;

procedure doFire;
var goodLanes : TIntegerArray;
    goodLane, h, activeID, i : integer;
    tP, tP2 : TPoint;
    tB : TBox;
    fail, fail2, fail3 : TreflectTimer;
    _item : TReflectInvItem;
    _obj : TReflectObject;
    logIDs : TIntegerArray;
begin
  if not daLocation.canFire then
    exit;

  logIDs := daLocation.getLogIDs;
  if not Reflect.Inv.Contains(LogIDs) then
    exit;

  if not Reflect.Inv.Contains(TinderIds) then
    Exit;

  goodLanes := getGoodFireLaneIndices;
  goodLane := -1;

  if high(goodLanes) <= -1 then begin
    doDropping(true);
    exit;
  end;

  if(random(5) = 1) then begin
    goodLane := goodLanes[random(length(goodLanes))];
  end else begin
    for i:=0 to high(goodLanes) do
      if (goodLane = -1) or (Reflect.Tiles.DistanceFromTile(daLocation.FireLanes[goodLanes[i]].Tile) < Reflect.Tiles.DistanceFromTile(daLocation.FireLanes[goodLane].Tile)) then
        goodLane := goodLanes[i];
  end;

  fail.restart;
  while not R_TileOnMS(daLocation.FireLanes[goodLane].Tile, tP) and (fail.Elapsedtime < 30000) do begin
    updateScreen('Going to firelane.');
    ReflectPlayer.BlindWalkMM(daLocation.FireLanes[goodLane].Tile, 5);
    ReflectPlayer.FFlag(0, 2500+random(500));
    sleepScript(500+random(500));
  end;

  goodLanes := getGoodFireLaneIndices;
  goodLane := -1;

  if high(goodLanes) <= -1 then begin
    doDropping(true);
    exit;
  end;

  for i:=0 to high(goodLanes) do
    if (goodLane = -1) or (Reflect.Tiles.DistanceFromTile(daLocation.FireLanes[goodLanes[i]].Tile) < Reflect.Tiles.DistanceFromTile(daLocation.FireLanes[goodLane].Tile)) then
      goodLane := goodLanes[i];

  fail.restart;
  while not Reflect.Tiles.NearTile(daLocation.FireLanes[goodLane].Tile, 1) and R_TileOnMS(daLocation.FireLanes[goodLane].Tile, tP) and (fail.Elapsedtime < 10000) do begin
    updateScreen('Going to firelane tile.');
    R_InteractTile(daLocation.FireLanes[goodLane].Tile, ['Walk']);
    ReflectPlayer.FFlag(0, 5000+random(500));
    sleepScript(500+random(500));
  end;

  tP := Reflect.Tiles.GetGlobalTile;
  if Reflect.Inv.Contains(LogIDs) and Reflect.Inv.Contains(TinderIds) and
        (tP.Y = daLocation.FireLanes[goodLane].Tile.Y) and (tP.X >= daLocation.FireLanes[goodLane].Tile.x-daLocation.FireLanes[goodLane].Length) and
        (tP.X <= daLocation.FireLanes[goodLane].Tile.x) and ReflectPlayer.isLoggedIn and not ReflectPlayer.IsUnderAttack then
  begin
    _Docount(daLocation.FireLanes[goodLane].Length);
    updateScreen('Making fires...');
    randomHandler;
    doProggy(ProggieLocation);
  end;

  while Reflect.Inv.Contains(LogIDs) and Reflect.Inv.Contains(TinderIds) and
        (tP.Y = daLocation.FireLanes[goodLane].Tile.Y) and (tP.X >= daLocation.FireLanes[goodLane].Tile.x-daLocation.FireLanes[goodLane].Length) and
        (tP.X <= daLocation.FireLanes[goodLane].Tile.x) and ReflectPlayer.isLoggedIn and not ReflectPlayer.IsUnderAttack do
  begin
    if Reflect.Gametab.CurrentColor <> Gametab_Inventory then
      Reflect.Gametab.Open(Gametab_Inventory);

    _obj.GetAt(ObjGame, tP);
    if Reflect.Smart.IsNull(_obj.Reference) or not inIntArray(FireIDs, _obj.GetID) then begin
      if not anySlotActivated(true) then begin
        if _item.Find(TinderIds) then begin
          getMousePos(tP2.x, tP2.y);
          tB := _item.getbox;
          if not PointInBox(tP2, tB) then
            reflect.mouse.move(tB, mouse_left)
          else
            fastClick(mouse_left);
          fail2.restart;
          while not anySlotActivated(true) and (fail2.Elapsedtime < 1000) do
            sleepScript(25);
        end;
      end;

      if anySlotActivated(true) then begin
        activeID := getActiveItemID;
        if inIntArray(LogIDs, activeID) then begin
          if _item.Find(TinderIds) then begin
            getMousePos(tP2.x, tP2.y);
            tB := _item.getbox;
            if not PointInBox(tP2, tB) then
              reflect.mouse.move(tB, mouse_left)
            else
              fastClick(mouse_left);
          end;
        end else begin
          if inIntArray(TinderIds, activeID) then begin
            if _item.Find(LogIDs) then begin
              getMousePos(tP2.x, tP2.y);
              tB := _item.getbox;
              if not PointInBox(tP2, tB) then
                reflect.mouse.move(tB, mouse_left)
              else
                fastClick(mouse_left);
            end;
          end else begin
            fixActive;
          end;
        end;
      end;

      fail.restart;
      fail2.restart;
      fail3.restart;
      while Reflect.Tiles.NearTile(tP, 1) and (fail.Elapsedtime < 2500) do begin
        //updateScreen('Making fires...');  //to slow
        //randomHandler;//to slow
        if inIntArray(fireAnimIDs, ReflectPlayer.getAnimation) then
          fail.restart;
        if (fail3.Elapsedtime > 350) then begin     //used to stop overlap or false postive with wasactive
          if not anySlotActivated(true) then begin
            if (Reflect.Inv.CountQuantities(LogIDs) > 1){cuz theres a delay until the log disappears} and ((tP.X-1) >= daLocation.FireLanes[goodLane].Tile.x-daLocation.FireLanes[goodLane].Length) then begin
              if _item.Find(TinderIds) then begin
                getMousePos(tP2.x, tP2.y);
                tB := _item.getbox;
                if not PointInBox(tP2, tB) then
                  reflect.mouse.move(tB, mouse_left)
                else
                  fastClick(mouse_left);
                fail2.restart;
                while not anySlotActivated(true) and (fail2.Elapsedtime < 1000) do
                  sleepScript(25);
              end;
            end;
          end;
          if anySlotActivated(true) then begin
            activeID := getActiveItemID;
            if inIntArray(LogIDs, activeID) then begin
              if _item.Find(TinderIds) then begin
                getMousePos(tP2.x, tP2.y);
                tB := _item.getbox;
                if not PointInBox(tP2, tB) then
                  reflect.mouse.move(tB);
              end;
            end else begin
              if inIntArray(TinderIds, activeID) then begin
                if _item.Find(LogIDs) then begin
                  getMousePos(tP2.x, tP2.y);
                  tB := _item.getbox;
                  if not PointInBox(tP2, tB) then
                    reflect.mouse.move(tB);
                end;
              end else begin
                fixActive;
              end;
            end;
          end;
        end;
      end;

      fail.restart;
      _obj.GetAt(ObjGame, tP);
      while (Reflect.Smart.IsNull(_obj.Reference) or not inIntArray(FireIDs, _obj.GetId)) and (fail.Elapsedtime < 2500) do
        _obj.GetAt(ObjGame, tP);
      tP := Reflect.Tiles.GetGlobalTile;
    end else begin
      for h:=tP.x downto daLocation.FireLanes[goodLane].Tile.X-daLocation.FireLanes[goodLane].Length do begin
        _obj.GetAt(ObjGame, Point(h, tP.y));
        if Reflect.Smart.IsNull(_obj.Reference) or not inIntArray(FireIDs, _obj.GetID) then begin
          tP := Point(h, tP.y);
          break;
        end else begin
          if (h = daLocation.FireLanes[goodLane].Tile.X-daLocation.FireLanes[goodLane].Length) then
            exit;
        end;
      end;

      fail.restart;
      while not R_TileOnMS(tP, tP2) and (fail.Elapsedtime < 30000) do begin
        updateScreen('Going to fire spot...');
        ReflectPlayer.BlindWalkMM(tP, 5);
        ReflectPlayer.FFlag(0, 2500+random(500));
        sleepScript(500+random(500));
      end;

      fail.restart;
      while not Reflect.Tiles.NearTile(tP, 1) and R_TileOnMS(tP, tP2) and (fail.Elapsedtime < 10000) do begin
        updateScreen('Going to fire spot tile...');
        FixActive;
        R_InteractTile(tP, ['Walk']);
        ReflectPlayer.FFlag(0, 5000+random(500));
        sleepScript(500+random(500));
      end;

      updateScreen('Making fires...');
    end;
  end;
  sleepScript(1000+random(1000));
end;

procedure doFletch;
var _item : TReflectInvItem;
    i : integer;
    logIDs : TIntegerArray;
begin
  if not daLocation.canFletch then
    exit;

  logIDs := daLocation.getLogIDs;
  if not Reflect.Inv.Contains(LogIDs) then
    exit;

  if not Reflect.Inv.Contains(KnifeIDs) then
    exit;

  while ReflectPlayer.IsLoggedIn and Reflect.Inv.Contains(LogIDs) and Reflect.Inv.Contains(KnifeIDs)
  and not ReflectPlayer.IsUnderAttack do begin
    if Reflect.Gametab.CurrentColor <> Gametab_Inventory then
      Reflect.Gametab.Open(Gametab_Inventory);
    UpdateScreen('Going to fletch.');
    if not anySlotActivated then begin
      for i:=0 to high(KnifeIDs) do begin
        if _item.Find(KnifeIDs[i]) then begin
          reflect.mouse.move(_item.getBox, mouse_left);
          sleepScript(500+random(500));
          break;
        end;
      end;
    end;
    if anySlotActivated(true) then begin
      for i:=0 to high(LogIDs) do begin
        if _item.Find(LogIDs[i]) then begin
          reflect.mouse.move(_item.getBox, mouse_left);
          sleepScript(1500+random(500));
          break;
        end;
      end;
    end;
    Reflect.Mouse.Move(daLocation.FletchPoint, 15, 15, mouse_right);
    if Reflect.Text.ChooseOption('Make X') then begin
      sleepScript(750+random(1000));
      Reflect.Keyboard.TypeSend('99', true);
      sleepScript(random(1000));
      if(random(round(AntiAmount/200)) <> 1)then
        Reflect.Antiban.MMouseOffClient('rand');
      sleepScript(1000);
      while ReflectPlayer.IsLoggedIn and ReflectPlayer.isDoingAnim(FletchAnimationIDs, 1000) and
      not ReflectPlayer.IsUnderAttack do begin
        randomHandler;
        FixActive;
        UpdateScreen('Fletching...');
      end;
    end;
  end;
end;

procedure goTobank;
var RsTIle, nearestNPCTile : TPoint;
    i, h : integer;
    nearestBank : BankLocation;
    didPath : boolean;
label normal;
begin
  if not daLocation.canBank or ((length(daLocation.BankLocations) = 0) and (length(daLocation.BankNPCs) = 0)) then
    exit;

  if Reflect.Bank.IsOpen or Reflect.Bank.IsPinOpen or Reflect.Bank.IsDepositBoxOpen or Reflect.Shop.IsOpen then
    exit;

  case daLocation.ID of
    5:begin//lum yew
      if (length(daLocation.PathToBank) <> 0) then begin
        if R_TileOnMM(daLocation.PathToBank[0], RSTile) then begin
          updateScreen('Going to bank.');
          ReflectPlayer.WalkPathMM(daLocation.PathToBank, false);
          ReflectPlayer.FFlag(2+randomRange(-2, 2), 5000+random(500));
          sleepScript(random(1500));
          didPath := true;
        end;
      end;
      while ReflectPlayer.IsLoggedIn and (Reflect.Tiles.GetPlane <> 2) and Reflect.Tiles.NearTile(daLocation.customTPAs[0][0], 100) do begin
        randomHandler;
        if(not R_TileOnMS(daLocation.customTPAs[0][0], rstile))then begin
          UpdateScreen('Going to stairs.');
          ReflectPlayer.BlindWalkMM(daLocation.customTPAs[0][0], 5);
          ReflectPlayer.FFlag(0, 2500+random(500));
          Sleepscript(random(2000));
        end;
        UpdateScreen('Going up stairs.');
        if(R_InteractTile(daLocation.customTPAs[0][0], ['Climb-up']))then begin
          ReflectPlayer.FFlag(0, 2500+random(500));
          Sleepscript(random(2000));
        end;
      end;
      if (Reflect.Tiles.GetPlane = 2) then
        goTo normal;
    end;
    32..33, 44:begin //gnome
      if (length(daLocation.PathToBank) <> 0) then begin
        if R_TileOnMM(daLocation.PathToBank[0], RSTile) then begin
          updateScreen('Going to bank.');
          ReflectPlayer.WalkPathMM(daLocation.PathToBank, false);
          ReflectPlayer.FFlag(2+randomRange(-2, 2), 5000+random(500));
          sleepScript(random(1500));
          didPath := true;
        end;
      end;
      if Reflect.Tiles.GetPlane = 0 then begin
        if(not R_TileOnMS(daLocation.customTPAs[0][0], rstile))then begin
          UpdateScreen('Going to stairs.');
          ReflectPlayer.BlindWalkMM(daLocation.customTPAs[0][0], 5);
          ReflectPlayer.FFlag(0, 2500+random(500));
          Sleepscript(random(2000));
        end;
        UpdateScreen('Going up stairs.');
        if(R_InteractTile(daLocation.customTPAs[0][0], ['Climb-up']))then begin
            ReflectPlayer.FFlag(0, 2500+random(500));
            Sleepscript(random(2000));
        end;
      end;
      if Reflect.Tiles.GetPlane = 1 then
        goto Normal;
    end;
    18:begin//edge
      if daLocation.DoorObjects[0].Open(true) then
        goTo normal;
    end;
    0..1, 6:begin//lumb gen
      if daLocation.DoorObjects[0].Open(false) then
        goTo normal;
    end;
    47..50:begin //redwood
      if Reflect.Tiles.GetPlane = 2 then begin
        if(not R_TileOnMS(daLocation.customTPAs[0][0], rstile))then begin
          UpdateScreen('Going to ladder.');
          ReflectPlayer.BlindWalkMM(daLocation.customTPAs[0][0], 5);
          ReflectPlayer.FFlag(0, 2500+random(500));
          Sleepscript(random(2000));
        end;
        UpdateScreen('Going down ladder.');
        if(R_InteractTile(daLocation.customTPAs[0][0], ['Climb-down']))then begin
            ReflectPlayer.FFlag(0, 2500+random(500));
            Sleepscript(random(2000));
        end;
      end;
      if Reflect.Tiles.GetPlane = 0 then
        goto Normal;
    end;
    else begin
      normal:
      if (length(daLocation.BankNPCs) = 0) then begin
        nearestBank.Tile.x := -1;
        for i:=0 to high(daLocation.BankLocations) do
          if (Reflect.Tiles.DistanceFromTile(daLocation.BankLocations[i].Tile) < Reflect.Tiles.DistanceFromTile(nearestBank.Tile)) or (nearestBank.Tile.x = -1) then
            nearestBank := daLocation.BankLocations[i];
        if R_TileOnMS(nearestBank.Tile, RSTile, nearestBank.Offset[0], nearestBank.Offset[1], nearestBank.Offset[2]) then
          exit;
      end else begin
        nearestNPCTile.x := -1;
        for i:=0 to high(daLocation.BankNPCs) do
          for h:=0 to high(daLocation.BankNPCs[i].Locations) do
            if (Reflect.Tiles.DistanceFromTile(daLocation.BankNPCs[i].Locations[h]) < Reflect.Tiles.DistanceFromTile(nearestNPCTile)) or (nearestNPCTile.x = -1) then
              nearestNPCTile := daLocation.BankNPCs[i].Locations[h];
        if R_TileOnMS(nearestNPCTile, RSTile) then
          exit;
      end;

      if (length(daLocation.PathToBank) <> 0) and not didPath then begin
        if R_TileOnMM(daLocation.PathToBank[0], RSTile) then begin
          updateScreen('Going to bank.');
          ReflectPlayer.WalkPathMM(daLocation.PathToBank, false);
          ReflectPlayer.FFlag(2+randomRange(-2, 2), 5000+random(500));
          sleepScript(random(1500));
          exit;
        end;
      end;

      if (length(daLocation.BankNPCs) = 0) then begin
        nearestBank.Tile.x := -1;
        for i:=0 to high(daLocation.BankLocations) do
          if (Reflect.Tiles.DistanceFromTile(daLocation.BankLocations[i].Tile) < Reflect.Tiles.DistanceFromTile(nearestBank.Tile)) or (nearestBank.Tile.x = -1) then
            nearestBank := daLocation.BankLocations[i];

        updateScreen('Going to bank.');
        ReflectPlayer.BlindWalkMM(Point(nearestBank.Tile.x + nearestBank.TileOffset[0], nearestBank.Tile.y + nearestBank.TileOffset[1]), 5);
        ReflectPlayer.FFlag(2+randomRange(-2, 2), 5000+random(500));
        sleepScript(random(1500));
      end else begin
        nearestNPCTile.x := -1;
        for i:=0 to high(daLocation.BankNPCs) do
          for h:=0 to high(daLocation.BankNPCs[i].Locations) do
            if (Reflect.Tiles.DistanceFromTile(daLocation.BankNPCs[i].Locations[h]) < Reflect.Tiles.DistanceFromTile(nearestNPCTile)) or (nearestNPCTile.x = -1) then
              nearestNPCTile := daLocation.BankNPCs[i].Locations[h];

        updateScreen('Going to bank npc.');
        ReflectPlayer.BlindWalkMM(nearestNPCTile, 5);
        ReflectPlayer.FFlag(2+randomRange(-2, 2), 5000+random(500));
        sleepScript(random(1500));
      end;
    end;
  end;
end;

procedure openBank;
var RsTIle, nearestNPCTile : TPoint;
    i, h : integer;
    nearestBank : BankLocation;
    nearestNPC : BankNPC;
    timer : TReflectTimer;
label normal;
begin
  if not daLocation.canBank or ((length(daLocation.BankLocations) = 0) and (length(daLocation.BankNPCs) = 0)) then
    exit;

  if Reflect.Bank.IsOpen or Reflect.Bank.IsPinOpen or Reflect.Bank.IsDepositBoxOpen or Reflect.Shop.IsOpen then
    exit;

  case daLocation.ID of
    0..1, 6:begin//lumb gen
      if daLocation.DoorObjects[0].Open(false) then
        goTo normal;
    end;
    18:begin//edge
      if daLocation.DoorObjects[0].Open(true) then
        goTo normal;
    end;
    else begin
      normal:
      if (length(daLocation.BankNPCs) = 0) then begin
        Reflect.Compass.Make('n');
        Reflect.Compass.MakePitch(10);

        nearestBank.Tile.x := -1;
        for i:=0 to high(daLocation.BankLocations) do
          if (Reflect.Tiles.DistanceFromTile(daLocation.BankLocations[i].Tile) < Reflect.Tiles.DistanceFromTile(nearestBank.Tile)) or (nearestBank.Tile.x = -1) then
            nearestBank := daLocation.BankLocations[i];

        if (Reflect.Tiles.GetPlane <> nearestBank.Plane) then
          exit;

        if not R_TileOnMS(nearestBank.Tile, RSTile, nearestBank.Offset[0], nearestBank.Offset[1], nearestBank.Offset[2]) then begin
          updateScreen('Going to bank.');
          ReflectPlayer.BlindWalkMM(Point(nearestBank.Tile.x + nearestBank.TileOffset[0], nearestBank.Tile.y + nearestBank.TileOffset[1]), 5);
          ReflectPlayer.FFlag(2+randomRange(-2, 2), 5000+random(500));
          sleepScript(random(1500));
        end;
        if R_TileOnMS(nearestBank.Tile, RSTile, nearestBank.Offset[0], nearestBank.Offset[1], nearestBank.Offset[2]) then begin
          updateScreen('Opening bank.');
          if R_InteractTile(nearestBank.Tile, nearestBank.Options, nearestBank.Offset[0], nearestBank.Offset[1], nearestBank.Offset[2], true) then begin
            ReflectPlayer.FFlag(0, 5000+random(500));
            Timer.Restart;
            while not Reflect.Bank.IsOpen and not Reflect.Bank.IsPinOpen and not Reflect.Bank.IsDepositBoxOpen
            and not Reflect.Shop.IsOpen and (timer.ElapsedTime < 2500) do
              sleepScript(50);
          end;
        end;
      end else begin
        nearestNPCTile.x := -1;
        for i:=0 to high(daLocation.BankNPCs) do
          for h:=0 to high(daLocation.BankNPCs[i].Locations) do
            if (Reflect.Tiles.DistanceFromTile(daLocation.BankNPCs[i].Locations[h]) < Reflect.Tiles.DistanceFromTile(nearestNPCTile)) or (nearestNPCTile.x = -1) then begin
              nearestNPCTile := daLocation.BankNPCs[i].Locations[h];
              nearestNPC := daLocation.BankNPCs[i];
            end;

        if (Reflect.Tiles.GetPlane <> nearestNPC.Plane) then
          exit;

        updateScreen('Opening bank npc.');
        if R_TryInteractNPC(nearestNPC.IDs, nearestNPC.Options, 5, nearestNPC.Offset[0], nearestNPC.Offset[1], nearestNPC.Offset[2]) then begin
          ReflectPlayer.FFlag(0, 5000+random(500));
          Timer.Restart;
          while not Reflect.Bank.IsOpen and not Reflect.Bank.IsPinOpen and not Reflect.Bank.IsDepositBoxOpen
          and not Reflect.Shop.IsOpen and (timer.ElapsedTime < 2500) do
            sleepScript(50);
        end;
      end;
    end;
  end;
end;

procedure goToTrees;
var RsTIle, farest : TPoint;
    i  : integer;
    didPath : boolean;
label normal;
begin
  if length(daLocation.TreeLocations) = 0 then
    exit;

  case daLocation.ID of
    5:begin//lum yew
      while ReflectPlayer.IsLoggedIn and (Reflect.Tiles.GetPlane <> 0) and Reflect.Tiles.NearTile(daLocation.customTPAs[0][0], 100) do begin
        randomHandler;
        if(not R_TileOnMS(daLocation.customTPAs[0][0], rstile))then begin
          UpdateScreen('Going to stairs.');
          ReflectPlayer.BlindWalkMM(daLocation.customTPAs[0][0], 5);
          ReflectPlayer.FFlag(0, 2500+random(500));
          Sleepscript(random(2000));
        end;
        UpdateScreen('Going down stairs.');
        if(R_InteractTile(daLocation.customTPAs[0][0], ['Climb-down']))then begin
          ReflectPlayer.FFlag(0, 2500+random(500));
          Sleepscript(random(2000));
        end;
      end;
      if (Reflect.Tiles.GetPlane = 0) then
        goTo normal;
    end;
    32..33, 44:begin //gnome
      if(Reflect.Tiles.GetPlane <> 0) then begin
        if(not R_TileOnMS(daLocation.customTPAs[0][1], rstile))then begin
          UpdateScreen('Going to stairs.');
          ReflectPlayer.BlindWalkMM(daLocation.customTPAs[0][1], 5);
          ReflectPlayer.FFlag(0, 2500+random(500));
          Sleepscript(random(2000));
        end;
        UpdateScreen('Going down stairs.');
        if(R_InteractTile(daLocation.customTPAs[0][1], ['Climb-down']))then begin
          ReflectPlayer.FFlag(0, 2500+random(500));
          Sleepscript(random(2000));
        end;
      end;
      if(Reflect.Tiles.GetPlane = 0) then
        goTO normal;
    end;
    18:begin//edge
      if daLocation.DoorObjects[0].Open(false) then
        goTo normal;
    end;
    0..1, 6:begin//lumb gen
      if daLocation.DoorObjects[0].Open(true) then
        goTo normal;
    end;
    47..50:begin //redwood
      if(Reflect.Tiles.GetPlane <> 2) then begin
        if(not R_TileOnMS(daLocation.customTPAs[0][0], rstile))then begin
          UpdateScreen('Going to ladder.');
          ReflectPlayer.BlindWalkMM(daLocation.customTPAs[0][0], 5);
          ReflectPlayer.FFlag(0, 2500+random(500));
          Sleepscript(random(2000));
        end;
        UpdateScreen('Going up ladder.');
        if(R_InteractTile(daLocation.customTPAs[0][0], ['Climb-up']))then begin
          ReflectPlayer.FFlag(0, 2500+random(500));
          Sleepscript(random(2000));
        end;
      end;
      if(Reflect.Tiles.GetPlane = 2) then
        goTO normal;
    end;
    else begin
      normal:
      if (length(daLocation.PathToTree) <> 0) and not didPath then begin
        if R_TileOnMM(daLocation.PathToTree[0], RSTile) then begin
          updateScreen('Going to trees.');
          ReflectPlayer.WalkPathMM(daLocation.PathToTree, false);
          ReflectPlayer.FFlag(2+randomRange(-2, 2), 5000+random(500));
          sleepScript(random(1500));
          exit;
        end;
      end;

      farest.x := -1;
      for i:=0 to high(daLocation.TreeLocations) do
        if (Reflect.Tiles.DistanceFromTile(daLocation.TreeLocations[i]) > Reflect.Tiles.DistanceFromTile(farest)) or (farest.x = -1) then
          farest := daLocation.TreeLocations[i];

      updateScreen('Going to tree spots.');
      ReflectPlayer.BlindWalkMM(farest, 5);
      ReflectPlayer.FFlag(2+randomRange(-2, 2), 5000+random(500));
      sleepScript(random(1500));
    end;
  end;
end;

procedure doBanking;
var _items : TReflectInvItemArray;
    i, count, _id : integer;
    firstTim : boolean;
    logIDs : TIntegerArray;
    tB : TBox;
    tim : treflecttimer;
begin
  if not daLocation.canBank then
    exit;

  firstTim := true;
  logIDs := daLocation.getLogIDs;
  if daLocation.isSell then begin
    if not Reflect.Shop.IsOpen then
      exit;
    doCount;
    updateScreen('Selling items.');
    doProggy(ProggieLocation);
    while ReflectPlayer.isLoggedIn and (Reflect.Inv.Contains(LogIDs) or firstTim) and
    Reflect.Shop.IsOpen do begin
      updateScreen('Selling items.');
      _items.GetAll;
      for i:=0 to high(_items) do begin
        if not ReflectPlayer.IsLoggedIn then
          break;
        if not Reflect.Shop.IsOpen then
          break;

        if not itemInSlot(_items[i].getinvslot) then
          continue;

        _id := _items[i].getId;
        if dropOnly then begin
          if not inIntArray(LogIDs, _id) then
            continue;
        end else begin
          if inIntArray(KnifeIDs, _id) then
            continue;
          if inIntArray(AxeIDs, _id) then
            continue;
          if inIntArray(CoinsIDs, _id) then
            continue;
          if inIntArray(ShaftIDs, _id) then
            continue;
        end;

        count := Reflect.Inv.Count;
        tB := _items[i].getbox;
        Reflect.Mouse.Move(tB, mouse_right);
        sleepScript(100+random(100));
        Reflect.Text.ChooseOption('Sell 50');
        tim.restart;
        while (tim.Elapsedtime < 2500) and (Reflect.Inv.Count = count) do
          sleepScript(20 + Random(20));
        sleepScript(500+random(250));
        if pos('highly over-stocked', Reflect.Chat.GetTextOnLine(1)) > 1 then begin
          Reflect.Interfaces.Close(Interface_ShopMenu);
          sleepScript(1000+random(1500));
          doDropping(true);
          exit;
        end;
      end;
      firstTim := false;
    end;
    if(random(2) = 1)then
      Reflect.Interfaces.Close(Interface_ShopMenu);
    sleepScript(random(1500));
    goToTrees;
  end else begin
    if not Reflect.Bank.IsOpen and not Reflect.Bank.IsDepositBoxOpen and not Reflect.Bank.IsPinOpen then
      exit;

    if Reflect.Bank.IsPinOpen then begin
      if length(ReflectPlayer.Pin) = 4 then
        Reflect.Bank.EnterPin(ReflectPlayer.Pin)
      else begin
        Reflect.Bank.Close;
        daLogger.Status('Invalid pin.', []);
        UpdateScreen('Invalid pin.');
        ReflectPlayer.Active := false;
        ReflectPlayer.Logout;
        sleepScript(2500);
        exit;
      end;
      sleepScript(random(2500));
    end;

    if not Reflect.Bank.IsOpen and not Reflect.Bank.IsDepositBoxOpen then
      exit;
    doCount;
    updateScreen('Banking items.');
    doProggy(ProggieLocation);
    while ReflectPlayer.IsLoggedIn and (Reflect.Inv.Contains(LogIDs) or firstTim) and
    (Reflect.Bank.IsOpen or Reflect.Bank.IsDepositBoxOpen) do begin
      updateScreen('Banking items.');
      if not Reflect.Inv.Contains(KnifeIDs) and not Reflect.Inv.Contains(AxeIDs) and
      not Reflect.Inv.Contains(CoinsIDs) and not Reflect.Inv.Contains(ShaftIDs) and (random(2) = 0) then begin
        Reflect.Bank.DepositAll('inv');
        sleepScript(1000+random(1000));
      end else begin
        _items.GetAll;
        for i:=0 to high(_items) do begin
          if not ReflectPlayer.IsLoggedIn then
            break;
          if not Reflect.Bank.IsOpen and not Reflect.Bank.IsDepositBoxOpen then
            break;

          if not itemInSlot(_items[i].getinvslot) then
            continue;

          _id := _items[i].getId;
          if dropOnly then begin
            if not inIntArray(LogIDs, _id) then
              continue;
          end else begin
            if inIntArray(KnifeIDs, _id) then
              continue;
            if inIntArray(AxeIDs, _id) then
              continue;
            if inIntArray(CoinsIDs, _id) then
              continue;
            if inIntArray(ShaftIDs, _id) then
              continue;
          end;

          if not Reflect.Bank.IsDepositBoxOpen then
            tB := _items[i].GetBox
          else
            tB := Reflect.Bank.DepositBoxBox(_items[i].GetInvSlot);
          count := Reflect.Inv.Count;
          Reflect.Mouse.Move(tB, mouse_right);
          sleepScript(100+random(100));
          Reflect.Text.ChooseOption('Deposit-All');
          tim.restart;
          while (tim.Elapsedtime < 2500) and (Reflect.Inv.Count = count) do
            sleepScript(20 + Random(20));
          sleepScript(500+random(250));
        end;
      end;
      firstTim := false;
    end;
    if(random(2) = 1)then
      Reflect.Bank.Close;

    sleepScript(random(1500));
    goToTrees;
  end;
end;

function TReflectObject.ToTree:TreeObject;
begin
  with result do begin
    AliveIDs := [self.GetId];
    DeadIDs := [];
    Options := ['Chop down'];
    TileOffset := [0, 0];
    Tile := self.GetTile;
    Index := 0;
    Name := '';
    Timer.Restart;
    Timer.StartTime := -1;
    if inIntArray([1278, 1276, 7482, 7480, 7424, 7422], self.GetId) then
      Offset := [75, 75, 200]
    else if inIntArray([7417, 7419, 7420], self.GetId) then
      Offset := [150, 150, 250]
    else
      Offset := [0, 0, 100];
  end;
end;

procedure chopTree;
var tempTree : TreeObject;
    rSTile : Tpoint;
    tempObject : TReflectObject;
    i, objectID : integer;
    _objects : TReflectobjecTArray;
    tempTrees : TreeObjectArray;
begin
  if useFakeWaitTime and wasWorking then begin
    updateScreen('Doing fake ''antiban'' wait.');
    sleepScript(1000+random(7500));
  end;
  if R_DidLevelUp or R_DidLevelUpExtra then begin
    updateScreen('Clicking level up!');

    for i:=0 to 1000 do
      if not FileExists(ScriptPath+'ineedbot''s clicking level up '+toStr(i)+'.png')then
        break;
    doProggy(ScriptPath+'ineedbot''s clicking level up '+toStr(i)+'.png');

    R_DidLevelUp(true);
    R_DidLevelUpExtra(true);
  end;

  case daLocation.ID of
    18:begin//edge
      if not daLocation.DoorObjects[0].Open(false) then
        exit;
    end;
    0..1, 6:begin//lum gen
      if not daLocation.DoorObjects[0].Open(true) then
        exit;
    end;
    5:begin //lum yew
      if Reflect.Tiles.GetPlane <> 0 then begin
        goToTrees;
        exit;
      end;
    end;
    32..33, 44:begin     //gnome
      if Reflect.Tiles.GetPlane <> 0 then begin
        goToTrees;
        exit;
      end;
    end;
    47..50:begin //redwood
      if Reflect.Tiles.GetPlane <> 2 then begin
        goToTrees;
        exit;
      end;
    end;
  end;

  updateScreen('Looking for tree...');
  tempTree.Tile.X := 0;

  if daLocation.isPower then begin
    wasWorking := false;
    if daLocation.distanceCheck < 1 then
      _objects.GetAll(ObjGame, 30)
    else
      _objects.GetAll2(ObjGame, daLocation.distanceCheck, daLocation.TreeLocations[0]);
    for i:=0 to high(_objects) do begin
      if inIntArray(daLocation.customIDs[0], _objects[i].getId) then begin
        tempTree := _objects[i].ToTree;
        break;
      end;
    end;
    if not tempTree.isValid then
      goToTrees;
  end else begin
    if daLocation.isFar then begin
      wasWorking := false;
      tempTrees := daLocation.TreeObjects.getAliveTrees;
      if length(tempTrees) <> 0 then begin
        tempTree := tempTrees.getClosestTree;
      end else begin
        tempTree := daLocation.TreeObjects.getNextTree(PreviousTree);
        PreviousTree := daLocation.TreeObjects.getClosestTree;
        UpdateScreen('Going to next tree...');
        if tempTree.isValid and not R_TileOnMS(tempTree.Tile, rsTile, tempTree.Offset[0], tempTree.Offset[1], tempTree.Offset[2]) then begin
          ReflectPlayer.BlindWalkMM(Point(tempTree.Tile.x + tempTree.TileOffset[0], tempTree.Tile.y + tempTree.TileOffset[1]), 5);
          ReflectPlayer.FFlag(2+randomRange(-2, 2), 5000+random(500));
          sleepScript(random(1500));
        end;
      end;
    end else begin
      tempTrees := daLocation.TreeObjects.getAliveTrees;
      if length(tempTrees) <> 0 then begin
        tempTree := tempTrees.getClosestTree;
      end else begin
        tempTrees := daLocation.TreeObjects.getDeadTrees;
        if length(tempTrees) <> 0 then begin
          if daLocation.canFire and (daLocation.ID = 42) then begin
            doFire;
            exit;
          end;
          tempTree := daLocation.TreeObjects.getClosestTreeTime;
          if tempTree.isValid then begin
            if not Reflect.Tiles.NearTile(TempTree.Tile, 5) then begin
              ReflectPlayer.BlindWalkMM(Point(tempTree.Tile.x + tempTree.TileOffset[0], tempTree.Tile.y + tempTree.TileOffset[1]), 5);
              ReflectPlayer.FFlag(2+randomRange(-2, 2), 5000+random(500));
              sleepScript(random(1500));
            end;
            tempTree.Tile.X := 0;
          end;
        end else begin
          goToTrees;
          exit;
        end;
      end;
    end;
  end;

  if tempTree.isValid then begin
    PreviousTree := daLocation.TreeObjects.getClosestTree;
    updateScreen('Going to chop tree.');
    if not R_TileOnMS(tempTree.Tile, rsTile, tempTree.Offset[0], tempTree.Offset[1], tempTree.Offset[2]) then begin
      ReflectPlayer.BlindWalkMM(Point(tempTree.Tile.x + tempTree.TileOffset[0], tempTree.Tile.y + tempTree.TileOffset[1]), 5);
      ReflectPlayer.FFlag(2+randomRange(-2, 2), 5000+random(500));
      sleepScript(random(1500));
    end;

    Reflect.Interfaces.CloseAll;

    if R_TileOnMS(tempTree.Tile, rsTile, tempTree.Offset[0], tempTree.Offset[1], tempTree.Offset[2]) then begin
      if UseSpec and (ReflectPlayer.GetSpecPercent >= 100)then begin
        if Reflect.Gametab.CurrentColor <> Gametab_CombatOptions then
          Reflect.Gametab.Open(Gametab_CombatOptions);
        reflect.mouse.move(Point(645, 432), 5, 5);
        FastClick(mouse_left);
      end;
      if R_InteractTile(tempTree.Tile, tempTree.Options, tempTree.Offset[0], tempTree.Offset[1], tempTree.Offset[2]) then begin
        sleepScript(random(1000));
        if(random(round(AntiAmount/200)) <> 0)then
          Reflect.Antiban.MMouseOffClient('Random');
        ReflectPlayer.FFlag(0, 5000+random(500));
        sleepScript(1000+random(1000));
        tempObject.GetAt(ObjGame, tempTree.Tile);
        if not Reflect.Smart.IsNull(tempObject.Reference) then
          objectID := tempObject.GetId
        else
          objectID := -1;
        while ReflectPlayer.IsLoggedIn and inIntArray(TempTree.AliveIDs, objectID) and
              (inIntArray(ChopAnimationIDs, ReflectPlayer.GetAnimation) or apeAtollIsChopping(tempTree.tile, tempTree.AliveIDs)) and
              not Reflect.Inv.IsFull and not ReflectPlayer.IsUnderAttack do
        begin
          randomHandler;
          FixActive;
          UpdateScreen('Chopping tree...');
          wasWorking := true;
          tempObject.GetAt(ObjGame, tempTree.Tile);
          if not Reflect.Smart.IsNull(tempObject.Reference) then
            objectID := tempObject.GetId
          else
            objectID := -1;
        end;
      end;
    end;
  end;
end;

procedure runAway;
var RSTile : TPoint;
label _random;
begin
  RsTIle := Reflect.Tiles.GetGlobalTile;
  updateScreen('Running away.');
  if length(daLocation.RunDirections) = 0 then begin
    goto _random;
  end else begin
    case daLocation.RunDirections[random(length(daLocation.RunDirections))] of
      'n':begin
        ReflectPlayer.BlindWalkMM(point(RsTIle.x, RsTIle.y+15), 5);
      end;
      's':begin
        ReflectPlayer.BlindWalkMM(point(RsTIle.x, RsTIle.y-15), 5);
      end;
      'w':begin
        ReflectPlayer.BlindWalkMM(point(RsTIle.x-15, RsTIle.y), 5);
      end;
      'e':begin
        ReflectPlayer.BlindWalkMM(point(RsTIle.x+15, RsTIle.y), 5);
      end;
      else begin
        _random:
        case random(8) of
          0:ReflectPlayer.BlindWalkMM(point(RsTIle.x, RsTIle.y-15), 5);
          1:ReflectPlayer.BlindWalkMM(point(RsTIle.x, RsTIle.y+15), 5);
          2:ReflectPlayer.BlindWalkMM(point(RsTIle.x+15, RsTIle.y), 5);
          3:ReflectPlayer.BlindWalkMM(point(RsTIle.x-15, RsTIle.y), 5);
          4:ReflectPlayer.BlindWalkMM(point(RsTIle.x+15, RsTIle.y-15), 5);
          5:ReflectPlayer.BlindWalkMM(point(RsTIle.x-15, RsTIle.y+15), 5);
          6:ReflectPlayer.BlindWalkMM(point(RsTIle.x-15, RsTIle.y-15), 5);
          7:ReflectPlayer.BlindWalkMM(point(RsTIle.x+15, RsTIle.y+15), 5);
        end;
      end;
    end;
  end;
  ReflectPlayer.FFlag(2+randomRange(-2, 2), 5000+random(500));
  sleepScript(random(1500));
end;

procedure doChecks;
var i, tInt : integer;
    _items : TReflectGroundItemArray;
    rsTile, nestTile : TPoint;
begin
  UpdateScreen('');

  randomHandler;
  FixActive;

  if daLocation.canfire and not Reflect.Inv.Contains(TinderIds) then
    daLocation.canfire := false;

  if daLocation.canfletch and not Reflect.Inv.Contains(KnifeIDs) then
    daLocation.canfletch := false;

  if(ReflectPlayer.GetRunEnergy >= RunAmount) and not ReflectPlayer.IsRunOn then
    ReflectPlayer.SetRun(true);

  if gItemTim.Elapsedtime > gItemOften then begin
    _items.GetAll(ItemCheckDistance);
    for i:=0 to high(_items) do begin
      nestTile := _items[i].GetTile;
      if inIntArray(NestIDs, _items[i].getId) and not Reflect.Inv.IsFull {and canBank} then begin
        daLogger.Status('Found nest!', []);
        UpdateScreen('Found nest...');
        if not R_TileOnMS(nestTile, RSTile) then begin
          ReflectPlayer.BlindWalkMM(nestTile, 5);
          ReflectPlayer.FFlag(2+randomRange(-2, 2), 5000+random(500));
          sleepScript(random(1500));
        end;

        UpdateScreen('Taking nest...');
        if R_InteractTile(nestTile, ['Take B']) then begin
          inc(Nests);
          statsServer.IncreaseVariable('119', 1);
          ReflectPlayer.FFlag(0, 5000+random(500));
          sleepScript(random(2000));
        end;
      end;
    end;
    gItemTim.restart;
  end;

  if ReflectPlayer.IsUnderAttack then begin
    UpdateScreen('Under attack! Running away to bank.');
    daLogger.Status('Under attack!', []);
    runAway;
    sleepScript(5000+random(2500));
  end;

  if(LastXPCheck.Elapsedtime > 600000) then begin
    if Reflect.Gametab.CurrentColor <> Gametab_Inventory then
      Reflect.Gametab.Open(Gametab_Inventory);
    setupPlayer;
    if(ReflectPlayer.GetSkillExp(SKILL_WOODCUTTING) <= LastXPXP)then begin
      UpdateScreen('No woodcutting XP gained in 10 minutes.');
      daLogger.Error('No woocutting XP gained in 10 minutes.', []);
      LastXPXP := ReflectPlayer.GetSkillExp(SKILL_WOODCUTTING);
      ReflectPlayer.Active := false;
      ReflectPlayer.Logout;
      sleepScript(2500);
      exit;
    end;
    LastXPXP := ReflectPlayer.GetSkillExp(SKILL_WOODCUTTING);
  end;

  if (StatsTimer.Elapsedtime > StatsTime) then begin
    StatsTimer.restart;
    StatsTime := 50000 + random(400000);
    tInt := 0;
    for i:=0 to high(daLocation.Logs) do
      tInt := tInt + (daLocation.Logs[i].price * daLocation.Logs[i].chopped);

    statsServer.IncreaseVariable('80', (ReflectPlayer.GetSkillExp(SKILL_WOODCUTTING)-statsWoodXP));
    statsServer.IncreaseVariable('79', (ReflectPlayer.GetSkillExp(SKILL_FIREMAKING)-statsFireXP));
    statsServer.IncreaseVariable('65', (ReflectPlayer.GetSkillExp(SKILL_FLETCHING)-statsFletchXP));
    if daLocation.canBank and not daLocation.canFire and not daLocation.isSell and not daLocation.canFletch then
      statsServer.IncreaseVariable('44', (tInt - statsProfit));

    statsWoodXP := ReflectPlayer.GetSkillExp(SKILL_WOODCUTTING);
    statsFletchXP := ReflectPlayer.GetSkillExp(SKILL_FLETCHING);
    statsFireXP := ReflectPlayer.GetSkillExp(SKILL_FIREMAKING);
    statsProfit := tInt;

    if useStats then
      if statsServer.Commit then
        daLogger.Status('Successfully sent heartbeat to ''stats.grats.pw''.', []);
  end;

  tInt := 0;
  for i:=0 to high(daLocation.Logs) do
    tInt := tInt + daLocation.Logs[i].chopped;
  if(tInt >= AmountAmount) and (AmountAmount > -1) then begin
    UpdateScreen('Chopped more or equal to given amount to chop.');
    daLogger.Status('Chopped more or equal to given amount to chop.', []);
    ReflectPlayer.Active := false;
    ReflectPlayer.Logout;
    sleepScript(2500);
    exit;
  end;

  if useBreaks then
    doBreakCheck;
end;

begin
  showForm;
  if started then begin
    ClearDebug;
    Reflect.Setup;
    Reflect.Smart.Graphics.Clear;
    if not(SmartEnabled(Reflect.Smart.Target)) then
      SmartSetEnabled(Reflect.Smart.Target, false);
    setupINeedFuncs;
    doUpdate;
    if (high(WorldList) > -1) and not ReflectPlayer.isLoggedIn then
      ReflectPlayer.ChangeWorld(WorldList[random(length(WorldList))]);
    nullInt := -1337;//so it runs .create at least once and makes sure script is played logged in
    while not(ReflectPlayer.isLoggedIn) or (nullInt = -1337) do begin
      if ReflectPlayer.Active then begin
        daLogger.Status('Logging player in...', []);
        ReflectPlayer.Login;
        if ReflectPlayer.Active then
          setupPlayer;
      end else begin
        sleepScript(1000);
      end;
      nullInt := 0;
    end;
    setupScript;
    while 1 do begin
      if ReflectPlayer.isLoggedIn then begin
        if daLocation.isDynamic then
          dynChop;
        if Reflect.Inv.IsFull then begin
          if useFakeWaitTime and wasWorking then begin
            updateScreen('Doing fake ''antiban'' wait.');
            sleepScript(1000+random(7500));
          end;
          wasWorking := false;
          if daLocation.canfire then begin
            doFire;
          end else begin
            if daLocation.canFletch then
              doFletch;
            if daLocation.canBank then begin
              goToBank;
              openBank;
              doBanking;
            end else begin
              doDropping(false);
            end;
          end;
        end else begin
          chopTree;
        end;
        doChecks;
      end else begin
        if ReflectPlayer.Active then begin
          if (high(WorldList) > -1) then
            ReflectPlayer.ChangeWorld(WorldList[random(length(WorldList))]);
          daLogger.Status('Logging player in...', []);
          ReflectPlayer.Login;
          if ReflectPlayer.Active then
            setupPlayer;
        end else begin
          sleepScript(1000);
        end;
      end;
    end;
  end;
end.
